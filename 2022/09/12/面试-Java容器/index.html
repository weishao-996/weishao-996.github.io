<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>面试-Java容器 | WeiBlog</title><meta name="author" content="Wei Shao"><meta name="copyright" content="Wei Shao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="集合概述常见的集合集合相关类和接又都在java.util中，主要分为 3 种：List（列表）、Map（映射）、Set(集)。  其中Collection是集合List、Set的父接口，它主要有两个子接口：  List ：存储的元素有序，可重复。  Set ：存储的元素无序，不可重复。 Map是另外的接口，是键值对映射结构的集合。   List, Set, Queue, Map 四者的区别 lis">
<meta property="og:type" content="article">
<meta property="og:title" content="面试-Java容器">
<meta property="og:url" content="https://weishao-996.github.io/2022/09/12/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="WeiBlog">
<meta property="og:description" content="集合概述常见的集合集合相关类和接又都在java.util中，主要分为 3 种：List（列表）、Map（映射）、Set(集)。  其中Collection是集合List、Set的父接口，它主要有两个子接口：  List ：存储的元素有序，可重复。  Set ：存储的元素无序，不可重复。 Map是另外的接口，是键值对映射结构的集合。   List, Set, Queue, Map 四者的区别 lis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://weishao-996.github.io/img/bg/WechatIMG48.png">
<meta property="article:published_time" content="2022-09-12T04:16:21.000Z">
<meta property="article:modified_time" content="2022-10-08T05:05:36.000Z">
<meta property="article:author" content="Wei Shao">
<meta property="article:tag" content="Java容器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://weishao-996.github.io/img/bg/WechatIMG48.png"><link rel="shortcut icon" href="/img/bg/%E6%89%8B%E7%BB%98%E7%81%AB%E7%AE%AD.png"><link rel="canonical" href="https://weishao-996.github.io/2022/09/12/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试-Java容器',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-08 13:05:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/bg/WechatIMG48.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bg/iTab-7p3we9.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="WeiBlog"><span class="site-name">WeiBlog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试-Java容器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-12T04:16:21.000Z" title="发表于 2022-09-12 12:16:21">2022-09-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-08T05:05:36.000Z" title="更新于 2022-10-08 13:05:36">2022-10-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试-Java容器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a><strong>集合概述</strong></h1><h2 id="常见的集合"><a href="#常见的集合" class="headerlink" title="常见的集合"></a>常见的集合</h2><p>集合相关类和接又都在java.util中，主要分为 3 种：List（列表）、Map（映射）、Set(集)。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912123038570.png" alt="image-20220912123038570"></p>
<p>其中Collection是集合List、Set的父接口，它主要有两个子接口：</p>
<ul>
<li><p>List ：存储的元素有序，可重复。</p>
</li>
<li><p>Set ：存储的元素无序，不可重复。</p>
<p>Map是另外的接口，是键值对映射结构的集合。</p>
</li>
</ul>
<h2 id="List-Set-Queue-Map-四者的区别"><a href="#List-Set-Queue-Map-四者的区别" class="headerlink" title="List, Set, Queue, Map 四者的区别"></a>List, Set, Queue, Map 四者的区别</h2><ul>
<li><strong>list</strong> (对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><strong>Set</strong> (注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><strong>Queue</strong> (实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><strong>Map</strong> (用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h2 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h2><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap。</p>
<p>当我们只需要存放元素值时，就选择实现Collection接口的集合，需要<strong>保证元素唯一时</strong>选择实现 Set 接口的集合比如 TreeSet 或HashSet，不需要就选择实现 List 接口的比如 ArrayList或 LinkedList，然后再根据实现这些接口的集合的特点来选用。</p>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>先来看一下 Collection 接口下面的集合。</p>
<p><strong>List</strong></p>
<ul>
<li>Arraylist： <strong>Object[]</strong> <strong>数组</strong></li>
<li>Vector：<strong>Object[] 数组</strong></li>
<li>LinkedList： <strong>双向链表</strong>(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<p><strong>Set</strong></p>
<ul>
<li>HashSet(<strong>无序，唯一</strong>): 基于 HashMap实现的，底层采用 HashMap 来保存元素</li>
<li>LinkedHashSet: LinkedHashSet是 HashSet 的子类，并且其内部是通过 LinkedHashMap来实现的。有点类似于我们之前说的 LinkedHashMap其内部是基于 HashMap实现一样，不过还是有一点点区别的</li>
<li>TreeSet(有序，唯一): <strong>红黑树</strong>(自平衡的排序二叉树)。</li>
</ul>
<p><strong>Queue</strong></p>
<ul>
<li>PriorityQueue: Object[] <strong>数组来实现二叉堆</strong></li>
<li>ArrayQueue: Object[] 数组 + 双指针</li>
</ul>
<p><strong>Map</strong></p>
<ul>
<li>HashMap： <strong>JDK1.8</strong> 之前 HashMap由<strong>数组+链表</strong>组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“<strong>拉链法</strong>”解决冲突）。<strong>JDK1.8 以后</strong>在解决哈希冲突时有了较大的变化，当<strong>链表长度大于阈值（默认为 8）</strong>（将链表转换成红黑树前会判断，如果当前<strong>数组的长度小于 64</strong>，那么会选择先进行<strong>数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li>LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。<strong>另外，LinkedHashMap</strong>在上面结构的基础上，增加了一条双向链表<strong>，</strong>使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》</li>
</ul>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>java.util包下的集合类大部分都是<strong>线程不安全</strong>的，例如我们常用的<strong>HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap</strong>，这些都是线程不安全的集合类<strong>，但是它们的优点是性能好。如果需要使用线程安全的集合类，则可以使用</strong>Collections工具类提供的**synchronizedXxx()**方法，将这些集合类包装成线程安全的集合类。</p>
<p>java.util包下也有线程安全的集合类，例如<strong>Vector、Hashtable</strong>。这些集合类都是比较古老的API，虽然实现了线程安全，但是<strong>性能很差</strong>。所以即便是需要使用线程安全的集合类，也建议将线程不安全的集合类包装成线程安全集合类的方式，而不是直接使用这些古老的API。</p>
<p>从Java5开始，Java在<strong>java.util.concurrent</strong>包下提供了大量支持高效并发访问的集合类，它们既能包装良好的访问性能，有能包装线程安全。这些集合类可以分为两部分，它们的特征如下：</p>
<ul>
<li><p><strong>以Concurrent开头的集合类</strong>：</p>
<p>以Concurrent开头的集合类代表了支持并发访问的集合，它们可以支持多个线程并发写入访问，这些写入线程的所有操作都是线程安全的，但读取操作不必锁定。以Concurrent开头的集合类采用了更复杂的算法来保证永远不会锁住整个集合，因此在并发写入时有较好的性能。</p>
</li>
<li><p><strong>以CopyOnWrite开头的集合类</strong>：</p>
<p>以CopyOnWrite开头的集合类采用<strong>复制底层数组的方式</strong>来实现写操作。当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。</p>
</li>
</ul>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h2><p><strong>（ 1 ） 数据结构不同</strong></p>
<ul>
<li>ArrayList基于数组实现</li>
<li>LinkedList基于双向链表实现</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912144741368.png" alt="image-20220912144741368"></p>
<p><strong>（ 2 ） 多数情况下，ArrayList更利于查找，LinkedList更利于增删</strong></p>
<ul>
<li>ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)；LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)；当然，get(Eelement)这种查找，两种集合都需要遍历，时间复杂度都是O(n)。</li>
<li>ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容；双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素。</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912145007734.png" alt="image-20220912145007734"></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912145021262.png" alt="image-20220912145021262"></p>
<p>注意，这个地方可能会出陷阱，LinkedList更利于增删更多是体现在平均步长上，不是体现在时间复杂度上，二者增删的时间复杂度都是O(n)</p>
<p><strong>（ 3 ） 是否支持随机访问</strong></p>
<ul>
<li>ArrayList基于数组，所以它可以根据下标查找，支持随机访问，当然，它也实现了RandmoAccess 接口，这个接口只是用来标识是否支持随机访问。</li>
<li>LinkedList基于链表，所以它没法根据序号直接获取元素，它没有实现RandmoAccess 接口，标记不支持随机访问。</li>
</ul>
<p><strong>（ 4 ）</strong> <strong>内存占用</strong>，ArrayList基于数组，是一块连续的内存空间，LinkedList基于链表，内存空<br>间不连续，它们在空间占用上都有一些额外的消耗：</p>
<ul>
<li>ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费</li>
<li>LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间</li>
</ul>
<h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p>ArrayList是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。所以在插入时候，会先检查是否需要扩容，如果当前容量+1超过数组长度，就会进行扩容。</p>
<p>ArrayList的扩容是创建一个 <strong>1.5倍</strong> 的新数组，然后把原数组的值拷贝过去。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912145559914.png" alt="image-20220912145559914"></p>
<h2 id="ArrayList序列化"><a href="#ArrayList序列化" class="headerlink" title="ArrayList序列化"></a>ArrayList序列化</h2><p>ArrayList的序列化不太一样，它使用transient修饰存储元素的elementData的数组，transient关键字的作用是让被修饰的成员属性不被序列化。</p>
<h3 id="为什么ArrayList不直接序列化元素数组呢？"><a href="#为什么ArrayList不直接序列化元素数组呢？" class="headerlink" title="为什么ArrayList不直接序列化元素数组呢？"></a>为什么ArrayList不直接序列化元素数组呢？</h3><p>出于效率的考虑，数组可能长度 100 ，但实际只用了 50 ，剩下的 50 不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间。</p>
<h3 id="那ArrayList怎么序列化呢？"><a href="#那ArrayList怎么序列化呢？" class="headerlink" title="那ArrayList怎么序列化呢？"></a>那ArrayList怎么序列化呢？</h3><p>ArrayList通过两个方法 <strong>readObject、writeObject</strong> 自定义序列化和反序列化策略，实际直接使用两个流ObjectOutputStream和ObjectInputStream来进行序列化和反序列化。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912145942393.png" alt="image-20220912145942393"></p>
<h2 id="快速失败-fail-fast-和安全失败-fail-safe"><a href="#快速失败-fail-fast-和安全失败-fail-safe" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)"></a>快速失败(fail-fast)和安全失败(fail-safe)</h2><p><strong>快速失败（fail—fast） ：快速失败是Java集合的一种错误检测机制</strong></p>
<ul>
<li>在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除），则会抛出<strong>Concurrent Modification Exception</strong>。</li>
<li>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 <strong>modCount</strong>变量。集合在被遍历期间如果内容发生变化，就会改变modCount 的值。每当迭代器使用**hashNext()/next()**遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>注意：这里异常的抛出条件是检测到 <strong>modCount！=expectedmodCount</strong> 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li>
<li>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。</li>
</ul>
<p><strong>安全失败（fail—safe）</strong></p>
<ul>
<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>
<li>原理：由于迭代器是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li>
<li>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>
<li>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类。</li>
</ul>
<p><strong>官方文档解释</strong></p>
<p>当Iterator这个迭代器被创建后，除了<strong>迭代器本身的方法(remove)**可以改变集合的结构外，其他的因素如若</strong>改变了集合的结构<strong>，都被抛出</strong>ConcurrentModificationException**异常。</p>
<p>迭代器的快速失败行为是不一定能够得到保证的，一般来说，存在非同步的并发修改时，不可能做出任何坚决的保证的。但是快速失败迭代器会做出最大的努力来抛出ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是不正确的。正确的做法应该是：迭代器的快速失败行为应该仅用于检测程序中的bug.</p>
<p><strong>结构上的改变</strong><br>例如集合上的插入和删除就是结构上的改变，但是，如果是对集合中某个元素进行修改的话，并不是结构上的改变。</p>
<p><strong>1、单线程的环境下，fail-fast抛出异常的实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">3</span>)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            list.remove(<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp++;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912160829889.png" alt="image-20220912160829889"></p>
<p><strong>结果分析：</strong>因为当temp==3的时候，执行list.remove()方法，集合的结构被改变了，所以再次遍历迭代器的时候，就会抛出异常。</p>
<p><strong>HashMap发生fail-fast：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++ ) &#123;</span><br><span class="line">                map.put(i+<span class="string">&quot;&quot;</span>, i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           Iterator&lt;Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                     map.remove(<span class="number">3</span>+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>该段代码定义了一个hashmap对象并存放了10个键值对，在迭代遍历过程中，使用map的remove方法移除了一个元素，导致抛出了 ConcurrentModificationException异常：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912160949231.png" alt="image-20220912160949231"></p>
<p><strong>2、多线程环境下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FailFastTest</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">                <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                     <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                     System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;:&quot;</span> + s);</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">super</span>.run();</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                     System.out.println(<span class="string">&quot;thread2:&quot;</span> + i);</span><br><span class="line">                     <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                           list.remove(i);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                     i ++;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            list.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">           <span class="type">MyThread1</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">           <span class="type">MyThread2</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">           thread1.setName(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">           thread2.setName(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">           thread1.start();</span><br><span class="line">           thread2.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动两个线程，分别对其中一个对list进行迭代，另一个在线程1的迭代过程中去remove一个元素，结果也是抛出了java.util.ConcurrentModificationException</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912161045734.png" alt="image-20220912161045734"></p>
<h3 id="fail-fast的工作原理"><a href="#fail-fast的工作原理" class="headerlink" title="fail-fast的工作原理"></a>fail-fast的工作原理</h3><p>fail-fast是如何抛出<strong>ConcurrentModificationException</strong>异常的，又是在什么情况下才会抛出?</p>
<p>我们知道，对于集合如list，map类，我们都可以通过迭代器来遍历，而Iterator其实只是一个接口，具体的实现还是要看具体的集合类中的内部类去实现Iterator并实现相关方法。这里我们就以ArrayList类为例。在ArrayList中，当调用list.iterator()时，其源码是： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即它会返回一个新的Itr类，而Itr类是ArrayList的内部类，实现了Iterator接口，下面是该类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">            checkForComodification();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; consumer)</span> &#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> ArrayList.<span class="built_in">this</span>.size;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中，有三个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br></pre></td></tr></table></figure>

<p>cursor是指集合遍历过程中的即将遍历的元素的索引，lastRet是cursor -1，默认为-1，即不存在上一个时，为-1，它主要用于记录刚刚遍历过的元素的索引。expectedModCount这个就是fail-fast判断的关键变量了，它初始值就为ArrayList中的modCount。（modCount是抽象类AbstractList中的变量，默认为0，而ArrayList 继承了AbstractList ，所以也有这个变量，modCount用于记录集合操作过程中作的修改次数，与size还是有区别的，并不一定等于size）</p>
<p>我们一步一步来看： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器迭代结束的标志就是hasNext()返回false，而该方法就是用cursor游标和size(集合中的元素数目)进行对比，当cursor等于size时，表示已经遍历完成。</p>
<p>接下来看看最关心的next()方法，看看为什么在迭代过程中，如果有线程对集合结构做出改变，就会发生fail-fast：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从源码知道，每次调用next()方法，在实际访问元素前，都会调用checkForComodification方法，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，该<strong>方法才是判断是否抛出ConcurrentModificationException异常的关键</strong>。在该段代码中，当<strong>modCount != expectedModCount</strong>时，就会抛出该异常。但是在一开始的时候，expectedModCount初始值默认等于modCount，为什么会出现modCount != expectedModCount，很明显expectedModCount在整个迭代过程除了一开始赋予初始值modCount外，并没有再发生改变，所以可能发生改变的就只有modCount，在前面关于ArrayList扩容机制的分析中，可以知道在<strong>ArrayList进行add，remove，clear等涉及到修改集合中的元素个数的操作时，modCount就会发生改变(modCount ++)</strong>,所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使modCount发生变化，这样在checkForComodification方法中就会抛出ConcurrentModificationException异常。</p>
<p>类似的，hashMap中发生的原理也是一样的。 </p>
<h3 id="避免fail-fast"><a href="#避免fail-fast" class="headerlink" title="避免fail-fast"></a>避免fail-fast</h3><p>了解了fail-fast机制的产生原理，接下来就看看如何解决fail-fast</p>
<p><strong>方法1</strong></p>
<p>在单线程的遍历过程中，如果要进行remove操作，可以调用<strong>迭代器的remove方法</strong>而不是集合类的remove方法。看看ArrayList中迭代器的remove方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    checkForComodification();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，该remove方法并不会修改modCount的值，并且不会对后面的遍历造成影响，因为该方法remove不能指定元素，<strong>只能remove当前遍历过的那个元素</strong>，所以调用该方法并不会发生fail-fast现象。该方法有局限性。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ ) &#123;</span><br><span class="line">           list.add(i + <span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                iterator.remove(); <span class="comment">//迭代器的remove()方法</span></span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(iterator.next());</span><br><span class="line">           i ++;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法2</strong></p>
<p>使用java并发包(java.util.concurrent)中的类来代替 ArrayList 和hashMap。</p>
<p>比如使用 <strong>CopyOnWriterArrayList</strong>代替 ArrayList， CopyOnWriterArrayList在是使用上跟 ArrayList几乎一样， CopyOnWriter是写时复制的容器(COW)，在读写时是线程安全的。该容器在对add和remove等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于 CopyOnWriterArrayList在迭代过程并不会发生fail-fast现象。但 <strong>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性</strong>。</p>
<p>对于HashMap，可以使用<strong>ConcurrentHashMap</strong>， ConcurrentHashMap采用了锁机制，是线程安全的。在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 ，iterator完成后再将头指针替换为新的数据 ，这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变。即迭代不会发生fail-fast，但不保证获取的是最新的数据。</p>
<h3 id="fail-safe与fail-fast的区别"><a href="#fail-safe与fail-fast的区别" class="headerlink" title="fail-safe与fail-fast的区别"></a><strong>fail-safe与fail-fast的区别</strong></h3><p>当我们对集合结构上做出改变的时候，fail-fast机制就会抛出异常。但是，对于采用fail-safe机制来说，就不会抛出异常。</p>
<p>这是因为，当集合的结构被改变的时候，fail-safe机制会在复制原集合的一份数据出来，然后在复制的那份数据遍历。</p>
<p>因此，虽然fail-safe不会抛出异常，但存在以下缺点</p>
<ul>
<li><strong>复制时需要额外的空间和时间上的开销。</strong></li>
<li><strong>不能保证遍历的是最新内容。</strong></li>
</ul>
<h2 id="线程安全的List"><a href="#线程安全的List" class="headerlink" title="线程安全的List"></a>线程安全的List</h2><ol>
<li><p>**Vector **</p>
<p>Vector是比较古老的API，虽然保证了线程安全，但是由于效率低一般不建议使用。</p>
</li>
<li><p><strong>Collections.SynchronizedList</strong></p>
<p>SynchronizedList是Collections的内部类，Collections提供了<strong>synchronizedList</strong>方法，可以将一个线程不安全的List包装成线程安全的List，即SynchronizedList。它比Vector有更好的扩展性和兼容性，但是它所有的方法都带有同步锁，也不是性能最优的List。</p>
</li>
<li><p><strong>CopyOnWriteArrayList</strong></p>
<p>CopyOnWriteArrayList是Java 1.5在java.util.concurrent包下增加的类，它采用<strong>复制底层数组</strong>的方式来实现写操作。当线程对此类集合执行读取操作时，线程将会直接读取集合本身，无须加锁与阻塞。当线程对此类集合执行写入操作时，集合会在底层复制一份新的数组，接下来对新的数组执行写入操作。由于对集合的写入操作都是对数组的副本执行操作，因此它是线程安全的。在所有线程安全的List中，它是性能最优的方案。</p>
</li>
</ol>
<h2 id="CopyOnWriteArrayList原理"><a href="#CopyOnWriteArrayList原理" class="headerlink" title="CopyOnWriteArrayList原理"></a>CopyOnWriteArrayList原理</h2><p>CopyOnWriteArrayList就是线程安全版本的ArrayList。</p>
<p>它的名字叫<strong>CopyOnWrite</strong>——写时复制，已经明示了它的原理。</p>
<p>CopyOnWriteArrayList采用了一种读写分离的并发策略。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912164440146.png" alt="image-20220912164440146"></p>
<ul>
<li>优点：<strong>读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景</strong>。在遍历传统的List时，若中途有别的线程对其进行修改，则会抛出ConcurrentModificationException异常。而CopyOnWriteArrayList由于其”<strong>读写分离</strong>“的思想，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器进行遍历时候，也就不会抛出ConcurrentModificationException异常了。</li>
<li>缺点：<strong>一是内存占用问题，毕竟每次执行写操作都要将原容器拷贝一份，数据量大时，对内存压力较大，可能会引起频繁GC</strong>。二是无法保证实时性，Vector对于读写操作均加锁同步，可以保证读和写的强一致性。而CopyOnWriteArrayList由于其实现策略的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞但读取到的却是老容器的数据</li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="Queue-与-Deque"><a href="#Queue-与-Deque" class="headerlink" title="Queue 与 Deque"></a>Queue 与 Deque</h2><p><strong>Queue</strong> <strong>是单端队列</strong>，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p>
<p>Queue扩展了Collection 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th><code>Queue</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p><strong>Deque</strong>是双端队列，在队列的两端均可以插入或删除元素。</p>
<p>Deque扩展了 Queue的接口, <strong>增加了在队首和队尾进行插入和删除的方法</strong>，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th><code>Deque</code> 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>PriorityQueue 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是<strong>优先级最高的元素先出队</strong>。</p>
<p>这里列举其相关的一些要点：</p>
<ul>
<li><code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li><code>PriorityQueue</code> 是<strong>非线程安全</strong>的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li>
<li><code>PriorityQueue</code> 默认是<strong>小顶堆</strong>，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p>
<h2 id="ArrayDeque-与-LinkedList"><a href="#ArrayDeque-与-LinkedList" class="headerlink" title="ArrayDeque 与 LinkedList"></a>ArrayDeque 与 LinkedList</h2><ul>
<li><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者<strong>都具有队列的功能</strong>，但两者有什么区别呢？</li>
<li><code>ArrayDeque</code> 是基于可变长的<strong>数组和双指针</strong>来实现，而 LinkedList 则通过<strong>链表</strong>来实现。</li>
<li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li>
<li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li>
<li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="Set概述"><a href="#Set概述" class="headerlink" title="Set概述"></a>Set概述</h2><p>Set 注重<strong>独一无二</strong>的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。</p>
<h3 id="HashSet（Hash-表）"><a href="#HashSet（Hash-表）" class="headerlink" title="HashSet（Hash 表）"></a><strong>HashSet（Hash 表）</strong></h3><p>哈希表存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的 hashcode 方法来获取的, <strong>HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法 如果 equals 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</strong></p>
<p>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相 同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情 况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912193646043.png" alt="image-20220912193646043"></p>
<p>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。</p>
<h3 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h3><ol>
<li><p>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </p>
</li>
<li><p><strong>Integer 和 String</strong> 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 <strong>Comparable</strong> 接口，并且覆写相应的 compareTo()函数，才可以正常使 用。 </p>
</li>
<li><p>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 </p>
</li>
<li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整 数、零或正整数。</p>
</li>
</ol>
<h3 id="LinkHashSet（HashSet-LinkedHashMap）"><a href="#LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（HashSet+LinkedHashMap）"></a>LinkHashSet（HashSet+LinkedHashMap）</h3><p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。 LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法 操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
<h2 id="HashSet的底层结构"><a href="#HashSet的底层结构" class="headerlink" title="HashSet的底层结构"></a>HashSet的底层结构</h2><p>HashSet是基于HashMap实现的，默认构造函数是构建一个<strong>初始容量为16</strong>，<strong>负载因子为0.75</strong> 的HashMap。它封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 <strong>HashMap 的 key 来保存</strong>，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。</p>
<p>HashSet的add方法，直接调用HashMap的put方法，将添加的元素作为key，new一个Object作为value，直接调用HashMap的put方法，它会根据返回值是否为空来判断是否插入元素成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912194458376.png" alt="image-20220912194458376"></p>
<p>而在HashMap的putVal方法中，进行了一系列判断，最后的结果是，只有在key在table数组中不存在的时候，才会返回插入的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">    <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">    e.value = value;</span><br><span class="line">    afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h2><p>你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
<p>在openjdk8中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns: true if this set did not already contain the specified element</span></span><br><span class="line"><span class="comment">// 返回值：当set中没有包含add的元素时返回真</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>HashMap</code>的<code>putVal()</code>方法中也能看到如下说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns : previous value, or null if none</span></span><br><span class="line"><span class="comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在openjdk8中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p>
<p><strong>hashCode()与 equals() 的相关规定：</strong></p>
<ul>
<li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li>
<li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li>
<li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li>
<li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li>
<li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ul>
<p><strong>==与 equals 的区别</strong></p>
<ul>
<li>对于基本类型来说，== 比较的是值是否相等；</li>
<li>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</li>
<li>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</li>
</ul>
<h2 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Map接口的实现类"><a href="#Map接口的实现类" class="headerlink" title="Map接口的实现类"></a>Map接口的实现类</h2><p>Map接口有很多实现类，其中比较常用的有<strong>HashMap、LinkedHashMap、TreeMap、ConcurrentHashMap</strong>。</p>
<p><strong>对于不需要排序的场景</strong>，优先考虑使用<strong>HashMap</strong>，因为它是性能最好的Map实现。如果需要<strong>保证线程安全</strong>，则可以使用ConcurrentHashMap。它的性能好于Hashtable，因为它在put时采用分段锁/CAS的加锁机制，而不是像Hashtable那样，无论是put还是get都做同步处理。</p>
<p><strong>对于需要排序的场景</strong>，如果需要按<strong>插入顺序排序</strong>则可以使用<strong>LinkedHashMap</strong>，如果需要将key按<strong>自然顺序排列</strong>甚至是自定义顺序排列，则可以选择<strong>TreeMap</strong>。如果需要保证线程安全，则可以使用Collections工具类将上述实现类包装成线程安全的Map。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap-中的-key-的类型"><a href="#HashMap-中的-key-的类型" class="headerlink" title="HashMap 中的 key 的类型"></a><strong>HashMap 中的 key 的类型</strong></h3><p>平时可能大家使用的最多的就是使用 <strong>String</strong> 作为 HashMap 的 key，但是现在我们想使用某个<strong>自定义类</strong>作为 HashMap 的 key，那就需要注意以下几点：</p>
<ul>
<li><p>如果类重写了 <strong>equals</strong> 方法，它也应该重写 <strong>hashCode</strong> 方法。 </p>
</li>
<li><p>类的所有实例需要遵循与 equals 和 hashCode 相关的规则。 </p>
</li>
<li><p>如果一个类没有使用 equals，你不应该在 hashCode 中使用它。 </p>
</li>
<li><p>咱们自定义 key 类的最佳实践是使之为不可变的，这样，hashCode 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode 和 equals 在未来不会改变，这样就会解决与 可变相关的问题了。</p>
</li>
<li><p>HashMap是线程不安全的实现；</p>
</li>
<li><p>HashMap<strong>可以使用null</strong>作为key或value。</p>
</li>
</ul>
<h3 id="HashMap-的底层结构"><a href="#HashMap-的底层结构" class="headerlink" title="HashMap 的底层结构"></a>HashMap 的底层结构</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a><strong>JDK1.8 之前</strong></h4><p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912201223402.png" alt="image-20220912201223402"></p>
<p><strong>JDK1.8</strong> 之前 <strong>HashMap</strong> 底层是<strong>数组和链表</strong>结合在一起使用也就是<strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过<strong>扰动函数</strong>处理过后得到 <strong>hash</strong> 值，然后通过**(n - 1) &amp; hash<strong>判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过</strong>拉链法**解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">      <span class="type">int</span> h;</span><br><span class="line">      <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a><strong>JDK1.8 之后</strong></h4><p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912201847436.png" alt="image-20220912201847436"></p>
<p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（<strong>默认为 8</strong>）（将链表转换成红黑树前会判断，如果当前数组的长度<strong>小于 64</strong>，那么会选择先进行<strong>数组扩容</strong>，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
<p>基于hash算法，通过put方法和get方法存储和获取对象。</p>
<p>存储对象时，我们将K/V传给put方法时，它调用K的hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。</p>
<p>如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来。在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。  </p>
<h4 id="HashMap-的长度为什么是-2-的-N-次方"><a href="#HashMap-的长度为什么是-2-的-N-次方" class="headerlink" title="HashMap 的长度为什么是 2 的 N 次方"></a><strong>HashMap 的长度为什么是 2 的 N 次方</strong></h4><p>第一个方面为了能让 HashMap 存数据和取数据的效率高，尽可能地减少 hash 值的碰撞，也就是说尽量把数据能均匀的分配，每个链表或者红黑树长度尽量相等。 我们首先可能会想到 <strong>% 取模</strong>的操作来实现。取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&amp;）操作（<strong>也就是说hash % length == hash &amp;(length - 1) 的前提是 length 是 2 的 n 次方</strong>）。并且，采用二进制位操作 &amp; ，相对于 % 能够提高运算效率。</p>
<p>第二个方面是在扩容时，利用扩容后的大小也是 2 的倍数，将已经产生hash碰撞的元素完美的转移到新的table中去</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><strong>红黑树</strong></h4><h5 id="你对红黑树了解多少？为什么不用二叉树-平衡树呢？"><a href="#你对红黑树了解多少？为什么不用二叉树-平衡树呢？" class="headerlink" title="你对红黑树了解多少？为什么不用二叉树/平衡树呢？"></a>你对红黑树了解多少？为什么不用二叉树/平衡树呢？</h5><p>红黑树本质上是一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：</p>
<ul>
<li>每个节点要么是红色，要么是黑色；</li>
<li>根节点永远是黑色的；</li>
<li>所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；</li>
<li>每个红色节点的两个子节点一定都是黑色；</li>
<li>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912220806132.png" alt="image-20220912220806132"></p>
<p><strong>之所以不用二叉树：</strong></p>
<p>红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为 O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。</p>
<p><strong>之所以不用平衡二叉树：</strong></p>
<p>平衡二叉树是比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。</p>
<h5 id="红黑树怎么保持平衡的知道吗？"><a href="#红黑树怎么保持平衡的知道吗？" class="headerlink" title="红黑树怎么保持平衡的知道吗？"></a>红黑树怎么保持平衡的知道吗？</h5><p>红黑树有两种方式保持平衡：旋转和染色。</p>
<ul>
<li><strong>旋转：旋转分为两种，左旋和右旋</strong></li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912221123370.png" alt="image-20220912221123370"></p>
<ul>
<li><strong>染色：</strong></li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912221149051.png" alt="image-20220912221149051"></p>
<h5 id="为什么HashMap链表转红黑树的阈值为-8-呢？"><a href="#为什么HashMap链表转红黑树的阈值为-8-呢？" class="headerlink" title="为什么HashMap链表转红黑树的阈值为 8 呢？"></a>为什么HashMap链表转红黑树的阈值为 8 呢？</h5><p>树化发生在table数组的长度大于 64 ，且链表的长度大于 8 的时候。</p>
<p>为什么是 8 呢？源码的注释也给出了答案。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913124405034.png" alt="image-20220913124405034"></p>
<p>红黑树节点的大小大概是普通节点大小的两倍，所以转红黑树，牺牲了空间换时间，更多的是一种兜底的策略，保证极端情况下的查找效率。</p>
<p>阈值为什么要选 8 呢？和统计学有关。理想情况下，使用随机哈希码，链表里的节点符合泊松分布，出现节点个数的概率是递减的，节点个数为 8 的情况，发生概率仅为0.00000006。</p>
<p>至于红黑树转回链表的阈值为什么是 6 ，而不是 8 ？是因为如果这个阈值也设置成 8 ，假如发生碰撞，节点增减刚好在 8 附近，会发生链表和红黑树的不断转换，导致资源浪费。</p>
<h3 id="HashMap-的扩容机制"><a href="#HashMap-的扩容机制" class="headerlink" title="HashMap 的扩容机制"></a><strong>HashMap 的扩容机制</strong></h3><h4 id="扩容概述"><a href="#扩容概述" class="headerlink" title="扩容概述"></a><strong>扩容概述</strong></h4><p>数组的<strong>初始容量为16</strong>，而容量是以<strong>2的次方</strong>扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。</p>
<p>数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的<strong>0.75</strong>时，就会扩充数组。这个0.75就是默认的负载因子，可由构造器传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。</p>
<p>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时（7或8），会将链表转换成红黑树提高性能。而当链表长度<strong>缩小到另一个阈值时（6）</strong>，又会将红黑树转换回单向链表提高性能。</p>
<p>对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个<strong>阈值（64）</strong>，如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。</p>
<h4 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a><strong>扩容过程</strong></h4><p>HashMap是基于数组+链表和红黑树实现的，但用于存放key值的桶数组的长度是固定的，由初始化参数确定。</p>
<p>那么，随着数据的插入数量增加以及负载因子的作用下，就需要扩容来存放更多的数据。而扩容中有一个非常重要的点，就是jdk1.8中的优化操作，可以不需要再重新计算每一个元素的哈希值。</p>
<p>因为HashMap的初始容量是 2 的次幂，扩容之后的长度是原来的二倍，新的容量也是 2 的次幂，所以，元素，要么在原位置，要么在原位置再移动 2 的次幂。</p>
<p>看下这张图，n为table的长度，图a表示扩容前的key1和key2两种key确定索引的位置，图b表示扩容后key1和key2两种key确定索引位置。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913125853617.png" alt="image-20220913125853617"></p>
<p>元素在重新计算hash之后，因为n变为 2 倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913125920404.png" alt="image-20220913125920404"></p>
<p>所以在扩容时，只需要看原来的hash值新增的那一位是 0 还是 1 就行了，是 0 的话索引没变，是 1的化变成原索引+oldCap，看看如 16 扩容为 32 的示意图：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913130007253.png" alt="image-20220913130007253"></p>
<p>扩容节点迁移主要逻辑：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913130034249.png" alt="image-20220913130034249"></p>
<h4 id="扩容在什么时候呢？为什么扩容因子是0-75？"><a href="#扩容在什么时候呢？为什么扩容因子是0-75？" class="headerlink" title="扩容在什么时候呢？为什么扩容因子是0.75？"></a><strong>扩容在什么时候呢？为什么扩容因子是0.75？</strong></h4><p>为了减少哈希冲突发生的概率，当当前HashMap的元素个数达到一个临界值的时候，就会触发扩容，把所有元素rehash之后再放在扩容后的容器中，这是一个相当耗时的操作。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913130341824.png" alt="image-20220913130341824"></p>
<p>而这个临界值threshold就是由加载因子和当前容器的容量大小来确定的，假如采用默认的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临界值（threshold ）= 默认容量（DEFAULT_INITIAL_CAPACITY） * 默认扩容因子</span><br><span class="line">（DEFAULT_LOAD_FACTOR）</span><br></pre></td></tr></table></figure>

<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913130458645.png" alt="image-20220913130458645"></p>
<p>那就是大于16x0.75=12时，就会触发扩容操作。</p>
<p>那么为什么选择了0.75作为HashMap的默认加载因子呢？</p>
<p>简单来说，这是对空间成本和时间成本平衡的考虑。</p>
<p>在HashMap中有这样一段注释：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913130552259.png" alt="image-20220913130552259"></p>
<p>我们都知道，HashMap的散列构造方式是Hash取余，负载因子决定元素个数达到多少时候扩容。</p>
<p>假如我们设的比较大，元素比较多，空位比较少的时候才扩容，那么发生哈希冲突的概率就增加了，查找的时间成本就增加了。     </p>
<p>我们设的比较小的话，元素比较少，空位比较多的时候就扩容了，发生哈希碰撞的概率就降低了，查找时间成本降低，但是就需要更多的空间去存储元素，空间成本就增加了。</p>
<h4 id="如果初始化HashMap，传一个-17-的值-new-HashMap-lt-gt-new-HashMap-lt-gt-，它会怎么处理？"><a href="#如果初始化HashMap，传一个-17-的值-new-HashMap-lt-gt-new-HashMap-lt-gt-，它会怎么处理？" class="headerlink" title="如果初始化HashMap，传一个 17 的值 new HashMap&lt;&gt;new HashMap&lt;&gt; ，它会怎么处理？"></a><strong>如果初始化HashMap，传一个 17 的值 new HashMap&lt;&gt;new HashMap&lt;&gt; ，它会怎么处理？</strong></h4><p>简单来说，就是初始化时，传的不是 2 的倍数时，<strong>HashMap会向上寻找离得最近的 2 的倍数</strong>，所以传入 17 ，但HashMap的实际容量是 32 。</p>
<p>我们来看看详情，在HashMap的初始化中，有这样一段方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>阀值 threshold ，通过方法tableSizeFor 进行计算，是根据初始化传的参数来计算的。</li>
<li>同时，这个方法也要要寻找比初始值大的，最小的那个 2 进制数值。比如传了 17 ，我应该找到的是 32 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span> ;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span> ;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span> ;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span> ;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span> ;</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span> ;</span><br><span class="line"><span class="keyword">return</span> (n &lt; <span class="number">0</span> )? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY)? MAXIMUM_CAPACITY : n + <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30，这个是临界范围，也就是最大的Map集合。</li>
<li>计算过程是向右移位 1 、 2 、 4 、 8 、 16 ，和原来的数做| 运算，这主要是为了把二进制的各个位置都填上 1 ，当二进制的各个位置都是 1 以后，就是一个标准的 2 的倍数减 1 了，最后把结果加 1 再返回即可。</li>
</ul>
<p>以 17 为例，看一下初始化计算table容量的过程：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913112429618.png" alt="image-20220913112429618"></p>
<h3 id="HashMap-的线程安全"><a href="#HashMap-的线程安全" class="headerlink" title="HashMap 的线程安全"></a>HashMap 的线程安全</h3><p><strong>HashMap不是线程安全的</strong>，可能会发生这些问题：</p>
<ul>
<li><strong>多线程下扩容死循环</strong>。JDK1.7 中的 HashMap 使用<strong>头插法</strong>插入元素，在多线程的环境下，扩容的时候有可能导致<strong>环形链表</strong>的出现，形成死循环。因此，JDK1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li>
<li><strong>多线程的 put 可能导致元素的丢失</strong>。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK1.7 和 JDK 1.8 中都存在。</li>
<li><strong>put 和 get 并发时，可能导致 get 为 null</strong>。线程 1 执行 put 时，因为元素个数超出 threshold而导致 rehash，线程 2 此时执行 get，有可能导致这个问题。这个问题在 JDK 1.7 和 JDK 1.8 中都存在。</li>
</ul>
<h4 id="有什么办法能解决HashMap线程不安全的问题呢"><a href="#有什么办法能解决HashMap线程不安全的问题呢" class="headerlink" title="有什么办法能解决HashMap线程不安全的问题呢"></a>有什么办法能解决HashMap线程不安全的问题呢</h4><p>Java 中有 HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的 Map。</p>
<ul>
<li>HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大；</li>
<li>Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；</li>
<li>ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized。</li>
</ul>
<h3 id="HashMap-的put流程"><a href="#HashMap-的put流程" class="headerlink" title="HashMap 的put流程"></a>HashMap 的put流程</h3><p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912204443510.png" alt="image-20220912204443510"></p>
<ol>
<li>首先进行哈希值的扰动，获取一个新的哈希值。**(key == null)? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)**;</li>
<li>判断tab是否位空或者长度为 0 ，如果是则进行扩容操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span> )</span><br><span class="line">n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据哈希值计算下标，如果对应小标正好没有存放数据，则直接插入即可否则需要覆</li>
<li>判断tab[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点。</li>
<li>如果链表中插入节点的时候，链表长度大于等于 8 ，则需要把链表转换为红黑树。<strong>treeifyBin(tab, hash)</strong>;</li>
<li>最后所有元素处理完成后，判断是否超过阈值；threshold，超过则扩容。</li>
</ol>
<h3 id="HashMap-的查找元素过程"><a href="#HashMap-的查找元素过程" class="headerlink" title="HashMap 的查找元素过程"></a>HashMap 的查找元素过程</h3><p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912205117553.png" alt="image-20220912205117553"></p>
<p>HashMap的查找就简单很多：</p>
<p><strong>1.</strong> 使用扰动函数，获取新的哈希值<br><strong>2.</strong> 计算数组下标，获取节点<br><strong>3.</strong> 当前节点和key匹配，直接返回<br><strong>4.</strong> 否则，当前节点是否为树节点，查找红黑树<br><strong>5.</strong> 否则，遍历链表查找</p>
<h3 id="HashMap-的哈希-扰动函数"><a href="#HashMap-的哈希-扰动函数" class="headerlink" title="HashMap 的哈希/扰动函数"></a>HashMap 的哈希/扰动函数</h3><p>HashMap的哈希函数是先拿到 key 的hashcode，是一个 32 位的int类型的数值，然后让hashcode的高 16 位和低 16 位进行异或操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="comment">// key的hashCode和key的hashCode右移 16 位做异或运算</span></span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>)? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为什么哈希-扰动函数能降hash碰撞"><a href="#为什么哈希-扰动函数能降hash碰撞" class="headerlink" title="为什么哈希/扰动函数能降hash碰撞"></a>为什么哈希/扰动函数能降hash碰撞</h4><p>因为 key.hashCode() 函数调用的是 key 键值类型自带的哈希函数，返回 int 型散列值。int 值范围为 <strong>-2147483648~2147483647</strong> ，加起来大概 40 亿的映射空间。</p>
<p>只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。</p>
<p>假如 HashMap 数组的初始大小才 16 ，就需要用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>
<p>源码中模运算就是把散列值和数组长度 - 1 做一个 “与&amp;” 操作，位运算比取余 % 运算要快。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bucketIndex = indexFor(hash, table.length);</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> h &amp; (length- <span class="number">1</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便说一下，这也正好解释了为什么 HashMap 的数组长度要取 2 的整数幂。因为这样（数组长度 - 1）正好相当于一个 “低位掩码”。与 操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度 16 为例，16-1=15。 2 进制表示是0000 0000 0000 0000 0000 0000 0000 1111。和某个散列值做 与 操作如下，结果就是截取了最低的四位值。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912205843632.png" alt="image-20220912205843632"></p>
<p>这样是要快捷一些，但是新的问题来了，就算散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。如果散列本身做得不好，分布上成等差数列的漏洞，如果正好让最后几个低位呈现规律性重复，那就更难搞了。</p>
<p>这时候 扰动函数 的价值就体现出来了，看一下扰动函数的示意图：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220912205945315.png" alt="image-20220912205945315"></p>
<p>右移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</p>
<h4 id="你还知道哪些哈希函数的构造方法呢？"><a href="#你还知道哪些哈希函数的构造方法呢？" class="headerlink" title="你还知道哪些哈希函数的构造方法呢？"></a><strong>你还知道哪些哈希函数的构造方法呢？</strong></h4><p>HashMap里哈希构造函数的方法叫：</p>
<p>除留取余法：<strong>H（key)=key%p（p&lt;=N）</strong>,关键字除以一个不大于哈希表长度的正整数p，所得余数为地址，当然HashMap里进行了优化改造，效率更高，散列也更均衡。</p>
<p>除此之外，还有这几种常见的哈希函数构造方法：</p>
<ul>
<li><p><strong>直接定址法</strong></p>
<p>直接根据key来映射到对应的数组位置，例如 1232 放到下标 1232 的位置。</p>
</li>
<li><p><strong>数字分析法</strong></p>
<p>取key的某些数字（例如十位和百位）作为映射的位置</p>
</li>
<li><p><strong>平方取中法</strong></p>
<p>取key平方的中间几位作为映射的位置</p>
</li>
<li><p><strong>折叠法</strong></p>
<p>将key分割成位数相同的几段，然后把它们的叠加和作为映射的位置</p>
</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913112805355.png" alt="image-20220913112805355"></p>
<h4 id="解决哈希冲突有哪些方法呢？"><a href="#解决哈希冲突有哪些方法呢？" class="headerlink" title="解决哈希冲突有哪些方法呢？"></a><strong>解决哈希冲突有哪些方法呢？</strong></h4><p>我们到现在已经知道，HashMap使用链表的原因为了处理哈希冲突，这种方法就是所谓的：</p>
<ul>
<li><strong>链地址法</strong>：在冲突的位置拉一个链表，把冲突的元素放进去。</li>
</ul>
<p>除此之外，还有一些常见的解决冲突的办法：</p>
<ul>
<li><strong>开放定址法</strong> ：开放定址法就是从冲突的位置再接着往下找，给冲突元素找个空位。</li>
</ul>
<p>找到空闲位置的方法也有很多种：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 线行探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置</span><br><span class="line">- 平方探查法: 从冲突的位置x开始，第一次增加1^2 个位置，第二次增加2^2 ...，直</span><br><span class="line">  至找到空闲的位置</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>


<p>​    </p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913114609119.png" alt="image-20220913114609119"></p>
<ul>
<li><strong>再哈希法</strong>：换种哈希函数，重新计算冲突元素的地址。</li>
<li><strong>建立公共溢出区</strong>：再建一个数组，把冲突的元素放进去。</li>
</ul>
<h3 id="HashMap-JDK1-8优化"><a href="#HashMap-JDK1-8优化" class="headerlink" title="HashMap JDK1.8优化"></a>HashMap JDK1.8优化</h3><p><strong>1. 数据结构</strong> ：数组 + 链表改成了数组 + 链表或红黑树<br>原因：发生 hash 冲突，元素会存入链表，链表过长转为红黑树，将时间复杂度由O(n)降为O(logn)<br><strong>2. 链表插入方式</strong> ：链表的插入方式从头插法改成了尾插法<br>简单说就是插入时，如果数组位置上已经有元素，1.7 将新元素放到数组中，原始节点作为新节点的后继节点，1.8 遍历链表，将元素放置到链表的最后。<br>原因：因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环。<br><strong>3. 扩容rehash</strong> ：扩容的时候 1.7 需要对原数组中的元素进行重新 hash 定位在新数组的位置，1.8 采用更简单的判断逻辑，不需要重新通过哈希函数计算位置，新的位置不变或索引 + 新增容量大小。<br>原因：提高扩容的效率，更快地扩容。<br><strong>4. 扩容时机</strong> ：在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容；<br><strong>5. 散列函数</strong> ：1.7 做了四次移位和四次异或，jdk1.8只做一次。<br>原因：做 4 次的话，边际效用也不大，改为一次，提升效率。</p>
<h3 id="HashMap-手写实现"><a href="#HashMap-手写实现" class="headerlink" title="HashMap 手写实现"></a>HashMap 手写实现</h3><p>我们实现的简单的HashMap命名为<code>ThirdHashMap</code>，先确定整体的设计：</p>
<ul>
<li>散列函数：hashCode()+除留余数法</li>
<li>冲突解决：链地址法</li>
</ul>
<p>整体结构如下：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913135034487.png" alt="自定义HashMap整体结构"></p>
<h4 id="内部节点类"><a href="#内部节点类" class="headerlink" title="内部节点类"></a><strong>内部节点类</strong></h4><p>我们需要定义一个节点来作为具体数据的载体，它不仅要承载键值对，同样还得作为单链表的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 节点类</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K, V&gt; &#123;</span><br><span class="line">       <span class="comment">//键值对</span></span><br><span class="line">       <span class="keyword">private</span> K key;</span><br><span class="line">       <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//链表，后继</span></span><br><span class="line">       <span class="keyword">private</span> Node&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.key = key;</span><br><span class="line">           <span class="built_in">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; next)</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.key = key;</span><br><span class="line">           <span class="built_in">this</span>.value = value;</span><br><span class="line">           <span class="built_in">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a><strong>成员变量</strong></h4><p>主要有四个成员变量，其中桶数组作为装载数据元素的结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认容量</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">   <span class="comment">//负载因子</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">   <span class="comment">//HashMap的大小</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">   <span class="comment">//桶数组</span></span><br><span class="line">   Node&lt;K, V&gt;[] buckets;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h4><p>构造方法有两个，无参构造方法，桶数组默认容量，有参指定桶数组容量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造器，设置桶数组默认容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThirdHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">Node</span>[DEFAULT_CAPACITY];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造器，指定桶数组容量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThirdHashMap</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">Node</span>[capacity];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a><strong>散列函数</strong></h4><p>散列函数，就是我们前面说的hashCode()和数组长度取余。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希函数，获取地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(K key, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="comment">//获取hash code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="comment">//和桶数组长度取余</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashCode % length;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a><strong>put方法</strong></h4><p>我用了一个putval方法来完成实际的逻辑，这是因为扩容也会用到这个方法。</p>
<p>大概的逻辑：</p>
<ul>
<li>获取元素插入位置</li>
<li>当前位置为空，直接插入</li>
<li>位置不为空，发生冲突，遍历链表</li>
<li>如果元素key和节点相同，覆盖，否则新建节点插入链表头部</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * put方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否需要进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt;= buckets.length * LOAD_FACTOR) resize();</span><br><span class="line">        putVal(key, value, buckets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将元素存入指定的node数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">putVal</span><span class="params">(K key, V value, Node&lt;K, V&gt;[] table)</span> &#123;</span><br><span class="line">        <span class="comment">//获取位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(key, table.length);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> table[index];</span><br><span class="line">        <span class="comment">//插入的位置为空</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(key, value);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入位置不为空，说明发生冲突，使用链地址法,遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果key相同，就覆盖掉</span></span><br><span class="line">            <span class="keyword">if</span> ((node.key.hashCode() == key.hashCode())</span><br><span class="line">                    &amp;&amp; (node.key == key || node.key.equals(key))) &#123;</span><br><span class="line">                node.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前key不在链表中，插入链表头部</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value, table[index]);</span><br><span class="line">        table[index] = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a><strong>扩容方法</strong></h4><p>扩容的大概过程：</p>
<ul>
<li>创建两倍容量的新数组</li>
<li>将当前桶数组的元素重新散列到新的数组</li>
<li>新数组置为map的桶数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 扩容</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//创建一个两倍容量的桶数组</span></span><br><span class="line">       Node&lt;K, V&gt;[] newBuckets = <span class="keyword">new</span> <span class="title class_">Node</span>[buckets.length * <span class="number">2</span>];</span><br><span class="line">       <span class="comment">//将当前元素重新散列到新的桶数组</span></span><br><span class="line">       rehash(newBuckets);</span><br><span class="line">       buckets = newBuckets;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 重新散列当前元素</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newBuckets</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">(Node&lt;K, V&gt;[] newBuckets)</span> &#123;</span><br><span class="line">       <span class="comment">//map大小重新计算</span></span><br><span class="line">       size = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//将旧的桶数组的元素全部刷到新的桶数组里</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">           <span class="comment">//为空，跳过</span></span><br><span class="line">           <span class="keyword">if</span> (buckets[i] == <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           Node&lt;K, V&gt; node = buckets[i];</span><br><span class="line">           <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">//将元素放入新数组</span></span><br><span class="line">               putVal(node.key, node.value, newBuckets);</span><br><span class="line">               node = node.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a><strong>get方法</strong></h4><p>get方法就比较简单，通过散列函数获取地址，这里我省去了有没有成链表的判断，直接查找链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="comment">//获取key对应的地址</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> getIndex(key, buckets.length);</span><br><span class="line">        <span class="keyword">if</span> (buckets[index] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Node&lt;K, V&gt; node = buckets[index];</span><br><span class="line">        <span class="comment">//查找链表</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((node.key.hashCode() == key.hashCode())</span><br><span class="line">                    &amp;&amp; (node.key == key || node.key.equals(key))) &#123;</span><br><span class="line">                <span class="keyword">return</span> node.value;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap-的常见遍历方式"><a href="#HashMap-的常见遍历方式" class="headerlink" title="HashMap 的常见遍历方式?"></a><strong>HashMap 的常见遍历方式?</strong></h3><p>随着 JDK 1.8 Streams API 的发布，使得 HashMap 拥有了更多的遍历的方式，但应该选择那种遍历方式？反而成了一个问题。</p>
<p>本文<strong>先从 HashMap 的遍历方法讲起，然后再从性能、原理以及安全性等方面，来分析 HashMap 各种遍历方式的优势与不足</strong>，本文主要内容如下图所示：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/KkbFHVifyKcpI-YdYNIr7s4rNF6pGag4IGeJL_O4FEg.jpegtoken=W.q8Qvd5kfog6r-PSmptI242Ro-m1smLTkhYfMzRQZLZfpdC8vjEyX_GLLRcjn91U" alt="img"></p>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>HashMap <strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p>
<ul>
<li>迭代器（Iterator）方式遍历；</li>
<li>For Each 方式遍历；</li>
<li>Lambda 表达式遍历（JDK 1.8+）;</li>
<li>Streams API 遍历（JDK 1.8+）。</li>
</ul>
<p>但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p>
<ul>
<li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li>
<li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li>
<li>使用 For Each EntrySet 的方式进行遍历；</li>
<li>使用 For Each KeySet 的方式进行遍历；</li>
<li>使用 Lambda 表达式的方式进行遍历；</li>
<li>使用 Streams API 单线程的方式进行遍历；</li>
<li>使用 Streams API 多线程的方式进行遍历。</li>
</ul>
<p>接下来我们来看每种遍历方式的具体实现代码。  </p>
<h5 id="1-迭代器-EntrySet"><a href="#1-迭代器-EntrySet" class="headerlink" title="1.迭代器 EntrySet"></a><strong>1.迭代器 EntrySet</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">     Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">       Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line"></span><br><span class="line">       System.out.println(entry.getKey());</span><br><span class="line"></span><br><span class="line">       System.out.println(entry.getValue());</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序的执行结果为：</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   Java</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  JDK</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">   Spring Framework</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   MyBatis framework</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">   Java中文社群</span><br></pre></td></tr></table></figure>

<h5 id="2-迭代器-KeySet"><a href="#2-迭代器-KeySet" class="headerlink" title="2.迭代器 KeySet"></a>2.迭代器 KeySet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line"></span><br><span class="line">     Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">     Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">       System.out.println(key);</span><br><span class="line"></span><br><span class="line">       System.out.println(map.get(key));</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序的执行结果为：</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   Java</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  JDK</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">   Spring Framework</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   MyBatis framework</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">   Java中文社群</span><br></pre></td></tr></table></figure>

<h5 id="3-ForEach-EntrySet"><a href="#3-ForEach-EntrySet" class="headerlink" title="3.ForEach EntrySet"></a>3.ForEach EntrySet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line"></span><br><span class="line">     Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(entry.getKey());</span><br><span class="line"></span><br><span class="line">       System.out.println(entry.getValue());</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序的执行结果为：</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   Java</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  JDK</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">   Spring Framework</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   MyBatis framework</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">   Java中文社群</span><br></pre></td></tr></table></figure>

<h5 id="4-ForEach-KeySet"><a href="#4-ForEach-KeySet" class="headerlink" title="4.ForEach KeySet"></a>4.ForEach KeySet</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line"></span><br><span class="line">     Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line"></span><br><span class="line">   map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(key);</span><br><span class="line"></span><br><span class="line">       System.out.println(map.get(key));</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序的执行结果为：</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   Java</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  JDK</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">   Spring Framework</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   MyBatis framework</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">   Java中文社群</span><br></pre></td></tr></table></figure>

<h5 id="5-Lambda"><a href="#5-Lambda" class="headerlink" title="5.Lambda"></a>5.Lambda</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line"></span><br><span class="line">     Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">   map.forEach((key, value) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(key);</span><br><span class="line"></span><br><span class="line">       System.out.println(value);</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序的执行结果为：</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   Java</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  JDK</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">   Spring Framework</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   MyBatis framework</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">   Java中文社群</span><br></pre></td></tr></table></figure>

<h5 id="6-Streams-API-单线程"><a href="#6-Streams-API-单线程" class="headerlink" title="6.Streams API 单线程"></a>6.Streams API 单线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line"></span><br><span class="line">     Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">    map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(entry.getKey());</span><br><span class="line"></span><br><span class="line">       System.out.println(entry.getValue());</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序的执行结果为：</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   Java</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  JDK</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">   Spring Framework</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   MyBatis framework</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">   Java中文社群</span><br></pre></td></tr></table></figure>

<h5 id="7-Streams-API-多线程"><a href="#7-Streams-API-多线程" class="headerlink" title="7.Streams API 多线程"></a>7.Streams API 多线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line"></span><br><span class="line">     Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">1</span>, <span class="string">&quot;Java&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">2</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">3</span>, <span class="string">&quot;Spring Framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">4</span>, <span class="string">&quot;MyBatis framework&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map.put(<span class="number">5</span>, <span class="string">&quot;Java中文社群&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">    map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(entry.getKey());</span><br><span class="line"></span><br><span class="line">       System.out.println(entry.getValue());</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序的执行结果为：</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   MyBatis framework</span><br><span class="line"></span><br><span class="line">   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">   Java中文社群</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   Java</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  JDK</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">   Spring Framework</span><br></pre></td></tr></table></figure>

<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>接下来我们使用 Oracle 官方提供的性能测试工具 JMH（Java Microbenchmark Harness，JAVA 微基准测试套件）来测试一下这 7 种循环的性能。</p>
<p>首先，我们先要引入 JMH 框架，在 pom.xml 文件中添加如下配置：</p>
<p>然后编写测试代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode(Mode.AverageTime)</span> <span class="comment">// 测试完成时间</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 预热 2 轮，每次 1s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)</span> <span class="comment">// 测试 5 轮，每次 1s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Fork(1)</span> <span class="comment">// fork 1 个线程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@State(Scope.Thread)</span> <span class="comment">// 每个测试线程一个实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapCycleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>() &#123;&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 添加数据</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">       put(i, <span class="string">&quot;val:&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 启动基准测试</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Options</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class="line"></span><br><span class="line">         .include(HashMapCycle.class.getSimpleName()) <span class="comment">// 要导入的测试类</span></span><br><span class="line"></span><br><span class="line">         .output(<span class="string">&quot;/Users/admin/Desktop/jmh-map.log&quot;</span>) <span class="comment">// 输出测试结果的文件</span></span><br><span class="line"></span><br><span class="line">         .build();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Runner</span>(opt).run(); <span class="comment">// 执行测试</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Benchmark</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">     Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">       Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Benchmark</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachEntrySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Benchmark</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">     Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> iterator.next();</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> map.get(k);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Benchmark</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEachKeySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> key;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> map.get(k);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Benchmark</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 遍历</span></span><br><span class="line"></span><br><span class="line">    map.forEach((key, value) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> key;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> value;</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Benchmark</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">streamApi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 单线程遍历</span></span><br><span class="line"></span><br><span class="line">    map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parallelStreamApi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 多线程遍历</span></span><br><span class="line"></span><br><span class="line">    map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有被添加了 @Benchmark 注解的方法都会被测试，因为 parallelStream 为多线程版本性能一定是最好的，所以就不参与测试了，其他 6 个方法的测试结果如下：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/sbStZ-0A3ZTYfi64pK3w1hIycIm1pw6NTzMVR1IK_E8.jpegtoken=W.q8Qvd5kfog6r-PSmptI242Ro-m1smLTkhYfMzRQZLZfpdC8vjEyX_GLLRcjn91U" alt="img"></p>
<p>其中 Units 为 ns/op 意思是执行完成时间（单位为纳秒），而 Score 列为平均执行时间， ± 符号表示误差。从以上结果可以看出，两个 entrySet 的性能相近，并且执行速度最快，接下来是 stream ，然后是两个 keySet，性能最差的是 KeySet 。</p>
<p>注：以上结果基于测试环境：JDK 1.8 / Mac mini (2018) / Idea 2020.1</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><strong>从以上结果可以看出</strong> <strong>entrySet</strong> <strong>的性能比</strong> <strong>keySet</strong> <strong>的性能高出了一倍之多，因此我们应该尽量使用</strong> <strong>entrySet</strong> <strong>来实现 Map 集合的遍历</strong>。</p>
<h4 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h4><p>要理解以上的测试结果，我们需要把所有遍历代码通过 javac 编译成字节码来看具体的原因。</p>
<p>编译后，我们使用 Idea 打开字节码，内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>() &#123;</span><br><span class="line"></span><br><span class="line">     &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var1</span> <span class="operator">=</span> <span class="number">0</span>; var1 &lt; <span class="number">2</span>; ++var1) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">this</span>.put(var1, <span class="string">&quot;val:&quot;</span> + var1);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">HashMapTest</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] var0)</span> &#123;</span><br><span class="line"></span><br><span class="line">     entrySet();</span><br><span class="line"></span><br><span class="line">     keySet();</span><br><span class="line"></span><br><span class="line">     forEachEntrySet();</span><br><span class="line"></span><br><span class="line">     forEachKeySet();</span><br><span class="line"></span><br><span class="line">     lambda();</span><br><span class="line"></span><br><span class="line">     streamApi();</span><br><span class="line"></span><br><span class="line">     parallelStreamApi();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line"></span><br><span class="line">       System.out.println(var1.getKey());</span><br><span class="line"></span><br><span class="line">       System.out.println((String)var1.getValue());</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line"></span><br><span class="line">       System.out.println(var1);</span><br><span class="line"></span><br><span class="line">       System.out.println((String)map.get(var1));</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachEntrySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line"></span><br><span class="line">       System.out.println(var1.getKey());</span><br><span class="line"></span><br><span class="line">       System.out.println((String)var1.getValue());</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachKeySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line"></span><br><span class="line">       System.out.println(var1);</span><br><span class="line"></span><br><span class="line">       System.out.println((String)map.get(var1));</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    map.forEach((var0, var1) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(var0);</span><br><span class="line"></span><br><span class="line">       System.out.println(var1);</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">streamApi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    map.entrySet().stream().forEach((var0) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(var0.getKey());</span><br><span class="line"></span><br><span class="line">       System.out.println((String)var0.getValue());</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parallelStreamApi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    map.entrySet().parallelStream().forEach((var0) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">       System.out.println(var0.getKey());</span><br><span class="line"></span><br><span class="line">       System.out.println((String)var0.getValue());</span><br><span class="line"></span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，除了 Lambda 和 Streams API 之外，通过迭代器循环和 for 循环的遍历的 EntrySet 最终生成的代码是一样的，他们都是在循环中创建了一个遍历对象 Entry ，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">entrySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line"></span><br><span class="line">     System.out.println(var1.getKey());</span><br><span class="line"></span><br><span class="line">     System.out.println((String)var1.getValue());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachEntrySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">Entry</span> <span class="variable">var1</span> <span class="operator">=</span> (Entry)var0.next();</span><br><span class="line"></span><br><span class="line">     System.out.println(var1.getKey());</span><br><span class="line"></span><br><span class="line">     System.out.println((String)var1.getValue());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">而 KeySet 的代码也是类似的，如下所示：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">keySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line"></span><br><span class="line">     System.out.println(var1);</span><br><span class="line"></span><br><span class="line">     System.out.println((String)map.get(var1));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forEachKeySet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">Iterator</span> <span class="variable">var0</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(var0.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">Integer</span> <span class="variable">var1</span> <span class="operator">=</span> (Integer)var0.next();</span><br><span class="line"></span><br><span class="line">     System.out.println(var1);</span><br><span class="line"></span><br><span class="line">     System.out.println((String)map.get(var1));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们在使用迭代器或是 for 循环 EntrySet 时，他们的性能都是相同的，因为他们最终生成的字节码基本都是一样的；同理 KeySet 的两种遍历方式也是类似的。</p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>EntrySet 之所以比 KeySet 的性能高是因为，KeySet 在循环时使用了 map.get(key)，而 map.get(key) 相当于又遍历了一遍 Map 集合去查询 key 所对应的值。为什么要用“又”这个词？那是因为<strong>在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用</strong> <strong>map.get(key)</strong> <strong>查询时，相当于遍历了两遍</strong>。</p>
<p>而 EntrySet 只遍历了一遍 Map 集合，之后通过代码“Entry&lt;Integer, String&gt; entry = iterator.next()”把对象的 key 和 value 值都放入到了 Entry 对象中，因此再获取 key 和 value 值时就无需再遍历 Map 集合，只需要从 Entry 对象中取值就可以了。</p>
<p>所以，<strong>EntrySet 的性能比 KeySet 的性能高出了一倍，因为 KeySet 相当于循环了两遍 Map 集合，而 EntrySet 只循环了一遍</strong>。</p>
<h4 id="安全性测试"><a href="#安全性测试" class="headerlink" title="安全性测试"></a>安全性测试</h4><p>从上面的性能测试结果和原理分析，我想大家应该选用那种遍历方式，已经心中有数的，而接下来我们就从「安全」的角度入手，来分析那种遍历方式更安全。</p>
<p>我们把以上遍历划分为四类进行测试：迭代器方式、For 循环方式、Lambda 方式和 Stream 方式，测试代码如下。</p>
<h5 id="1-迭代器方式"><a href="#1-迭代器方式" class="headerlink" title="1.迭代器方式"></a>1.迭代器方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">   Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 删除</span></span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line"></span><br><span class="line">    iterator.remove();</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上程序的执行结果：</span><br><span class="line"></span><br><span class="line">  show:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  del:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">  show:<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>测试结果：<strong>迭代器中循环删除数据安全</strong>。</p>
<h5 id="2-For-循环方式"><a href="#2-For-循环方式" class="headerlink" title="2.For 循环方式"></a>2.For 循环方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 删除</span></span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line"></span><br><span class="line">    map.remove(entry.getKey());</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/_3OM3BUdlXmR-epwk01TEDPOzrAAhRMgGseQnYvQqGo.jpegtoken=W.q8Qvd5kfog6r-PSmptI242Ro-m1smLTkhYfMzRQZLZfpdC8vjEyX_GLLRcjn91U" alt="img"></p>
<p>测试结果：<strong>For 循环中删除数据非安全</strong>。</p>
<h5 id="3-Lambda-方式"><a href="#3-Lambda-方式" class="headerlink" title="3.Lambda 方式"></a>3.Lambda 方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (key == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;del:&quot;</span> + key);</span><br><span class="line"></span><br><span class="line">    map.remove(key);</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/IjUYFJX92qSgshIGqRudq8rzYJAfqWHV0053R0cCGk8.jpegtoken=W.q8Qvd5kfog6r-PSmptI242Ro-m1smLTkhYfMzRQZLZfpdC8vjEyX_GLLRcjn91U" alt="img"></p>
<p>测试结果：<strong>Lambda 循环中删除数据非安全</strong>。</p>
<p><strong>Lambda 删除的正确方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 map 中的 key 去判断删除</span></span><br><span class="line"></span><br><span class="line">map.keySet().removeIf(key -&gt; key == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">map.forEach((key, value) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">&quot;show:&quot;</span> + key);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">以上程序的执行结果：</span><br><span class="line"></span><br><span class="line">  show:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  show:<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，可以先使用 Lambda 的 removeIf 删除多余的数据，再进行循环是一种正确操作集合的方式。</p>
<h5 id="4-Stream-方式"><a href="#4-Stream-方式" class="headerlink" title="4.Stream 方式"></a>4.Stream 方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line"></span><br><span class="line">    map.remove(entry.getKey());</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上程序的执行结果：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/HbdC5zflYHd-4y1FMUJ0PaaLzY-xVWn6Z2j3OV6abXQ.jpegtoken=W.q8Qvd5kfog6r-PSmptI242Ro-m1smLTkhYfMzRQZLZfpdC8vjEyX_GLLRcjn91U" alt="img"></p>
<p>测试结果：<strong>Stream 循环中删除数据非安全</strong>。</p>
<p><strong>Stream 循环的正确方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">map.entrySet().stream().filter(m -&gt; <span class="number">1</span> != m.getKey()).forEach((entry) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (entry.getKey() == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;del:&quot;</span> + entry.getKey());</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;show:&quot;</span> + entry.getKey());</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">以上程序的执行结果：</span><br><span class="line"></span><br><span class="line">  show:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">  show:<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，可以使用 Stream 中的 filter 过滤掉无用的数据，再进行遍历也是一种安全的操作集合的方式。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><strong>我们不能在遍历中使用集合</strong> <strong>map.remove()</strong> <strong>来删除数据，这是非安全的操作方式，但我们可以使用迭代器的</strong> <strong>iterator.remove()</strong> <strong>的方法来删除数据，这是安全的删除集合的方式。</strong>同样的我们也可以使用 Lambda 中的 removeIf 来提前删除数据，或者是使用 Stream 中的 filter 过滤掉要删除的数据进行循环，这样都是安全的，当然我们也可以在 for 循环前删除数据在遍历也是线程安全的。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文我们讲了 HashMap 4 种遍历方式：迭代器、for、lambda、stream，以及具体的 7 种遍历方法，综合性能和安全性来看，<strong>我们应该尽量使用迭代器（Iterator）来遍历</strong> <strong>EntrySet</strong> <strong>的遍历方式来操作 Map 集合</strong>，这样就会既安全又高效了。</p>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p><strong>底层数据结构：</strong><code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</p>
<p><strong>实现线程安全的方式（重要）：</strong> </p>
<p><strong><code>Hashtable</code>(同一把锁)</strong> :使用 <strong><code>synchronized</code></strong> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p>
<p> <strong>Hashtable:</strong></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913140316598.png" alt="image-20220913140316598"></p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>TreeMap基于<strong>红黑树</strong>（Red-Black tree）实现。映射根据其<strong>键</strong>的自然顺序进行排序，或者根据创建映射时提供的 <strong>Comparator</strong> 进行排序，具体取决于使用的构造方法。TreeMap的基本操作containsKey、get、put、remove方法，它的时间复杂度是log(N)。</p>
<p>TreeMap包含几个重要的成员变量：root、size、comparator。其中root是红黑树的根节点。它是Entry类型，Entry是红黑树的节点，它包含了红黑树的6个基本组成：key、value、left、right、parent和color。Entry节点根据Key排序，包含的内容是value。Entry中key比较大小是根据比较器comparator来进行判断的。size是红黑树的节点个数。</p>
<p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序， 也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。 如果使用排序的映射，建议使用 TreeMap。</p>
<p> 在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913161359407.png" alt="image-20220913161359407"></p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>LinkedHashMap使用双向链表来维护key-value对的顺序（其实只需要考虑key的顺序），该链表负责维护Map的迭代顺序，迭代顺序与key-value对的插入顺序保持一致。</p>
<p>LinkedHashMap可以避免对HashMap、Hashtable里的key-value对进行排序（只要插入key-value对时保持顺序即可），同时又可避免使用TreeMap所增加的成本。</p>
<p><strong>LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能。</strong>但因为它以链表来维护内部顺序，所以在迭代访问Map里的全部元素时将有较好的性能。</p>
<p>LinkedHashMap继承于HashMap，它在HashMap的基础上，通过维护一条<strong>双向链表</strong>，解决了HashMap不能随时保持遍历顺序和插入顺序一致的问题。在实现上，LinkedHashMap很多方法直接继承自HashMap，仅为维护双向链表重写了部分方法。</p>
<p>每当有新的键值对节点插入时，新节点最终会接在tail引用指向的节点后面。而tail引用则会移动到新的节点上，这样一个双向链表就建立起来了。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913141014099.png" alt="image-20220913141014099"></p>
<h2 id="ConcurrentHashmap"><a href="#ConcurrentHashmap" class="headerlink" title="ConcurrentHashmap"></a>ConcurrentHashmap</h2><h3 id="ConcurrentHashmap的底层实现"><a href="#ConcurrentHashmap的底层实现" class="headerlink" title="ConcurrentHashmap的底层实现"></a>ConcurrentHashmap的底层实现</h3><p><strong>ConcurrentHashmap</strong>线程安全在<strong>jdk1.7</strong>版本是基于<strong>分段锁</strong>实现，在j<strong>dk1.8</strong>是基于<strong>CAS+synchronized</strong>实现。</p>
<h4 id="1-7-分段锁"><a href="#1-7-分段锁" class="headerlink" title="1.7 分段锁"></a><strong>1.7 分段锁</strong></h4><p>从结构上说，1.7版本的ConcurrentHashMap采用分段锁机制，里面包含一个Segment数组，Segment继承于ReentrantLock，Segment则包含HashEntry的数组，HashEntry本身就是一个链表的结构，具有保存key、value的能力能指向下一个节点的指针。</p>
<p>实际上就是相当于每个Segment都是一个HashMap，默认的Segment长度是 16 ，也就是支持 16个线程的并发写，Segment之间相互不会受到影响。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913153346720.png" alt="image-20220913153346720"></p>
<p><strong>put流程</strong></p>
<p>当执行put操作时，会经历两个步骤：</p>
<ul>
<li>判断是否需要扩容；</li>
<li>定位到添加元素的位置，将其放入 HashEntry 数组中。</li>
</ul>
<p>插入过程会进行第一次 key 的 hash 来定位 Segment 的位置，如果该 Segment 还没有初始化，即通过 CAS 操作进行赋值，然后进行第二次 hash 操作，找到相应的 HashEntry 的位置，这里会利用继承过来的锁的特性，在将数据插入指定的 HashEntry 位置时（尾插法），会通过继承 ReentrantLock 的 tryLock() 方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用 tryLock() 方法去获取锁，超过指定次数就挂起，等待唤醒。</p>
<p><strong>get流程</strong></p>
<p>Segment的get操作实现非常简单和高效，先经过一次再散列，然后使用这个散列值通过散列运算定位到 Segment，再通过散列算法定位到元素。get操作的高效之处在于整个get过程都不需要加锁，除非读到空的值才会加锁重读。原因就是将使用的共享变量定义成 volatile 类型。</p>
<h4 id="1-8-CAS-synchronized"><a href="#1-8-CAS-synchronized" class="headerlink" title="1.8 CAS+synchronized"></a><strong>1.8 CAS+synchronized</strong></h4><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 <strong>CAS</strong> 和 <strong>synchronized</strong> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，<strong>数组+链表/红黑二叉树</strong>。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>
<p>synchronized 只锁定当前链表或红黑二叉树的<strong>首节点</strong>，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913154854202.png" alt="image-20220913154854202"></p>
<p><strong>put流程</strong></p>
<p><strong>1. 首先计算hash，遍历node数组，如果node是空的话，就通过CAS+自旋的方式初始化node数组初始化：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tab = initTable();</span><br></pre></td></tr></table></figure>

<p>node    数组初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">//如果正在初始化或者扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="comment">//等待</span></span><br><span class="line">        Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, - <span class="number">1</span> )) &#123; <span class="comment">//CAS</span></span><br><span class="line">        操作</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span> )? sc : DEFAULT_CAPACITY;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">            table = tab = nt;</span><br><span class="line">            sc = n - (n &gt;&gt;&gt; <span class="number">2</span> );</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	sizeCtl = sc;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.如果当前数组位置是空则直接通过CAS自旋写入数据</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">   	 <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c,</span><br><span class="line">    v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.</strong> <strong>如果hash==MOVED，说明需要扩容，执行扩容</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                (sc = sizeCtl) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span> )) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.</strong> <strong>如果都不满足，就使用synchronized写入数据，写入数据同样判断链表、红黑树，链表写入和HashMap的方式一样，key hash一样就覆盖，反之就尾插法，链表长度超过 8 就转换成红黑树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f)&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913160154222.png" alt="image-20220913160154222"></p>
<p><strong>get查询</strong></p>
<p>get很简单，和HashMap基本相同，通过key计算位置，table该位置key相同就返回，如果是红黑树按照红黑树获取，否则就遍历链表获取。</p>
<h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><ul>
<li><p><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</p>
</li>
<li><p><strong>对 Null key 和 Null value 的支持：</strong> <strong><code>HashMap</code></strong> <strong>可以存储 null 的 key 和 value</strong>，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></p>
<ul>
<li><p> ① 创建时如果不指定容量初始值，<code>Hashtable</code> <strong>默认的初始大小为 11</strong>，之后每次扩充，容量变为原来的 <strong>2n+1</strong>。<code>HashMap</code> <strong>默认的初始化大小为 16</strong>。之后每次扩充，容量变为原来的 2 倍。</p>
</li>
<li><p> ② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 <strong>2 的幂次方大小</strong>（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</p>
</li>
</ul>
</li>
<li><p><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（<strong>默认为 8</strong>）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ul>
<h2 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h2><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：**<code>HashSet</code>** <strong>底层就是基于</strong> <strong><code>HashMap</code></strong> <strong>实现的</strong>。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。 </p>
<table>
<thead>
<tr>
<th align="center"><code>HashMap</code></th>
<th align="center"><code>HashSet</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 <code>Map</code> 接口</td>
<td align="center">实现 <code>Set</code> 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td>
</tr>
<tr>
<td align="center"><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td>
<td align="center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h1 id="集合工具"><a href="#集合工具" class="headerlink" title="集合工具"></a>集合工具</h1><h2 id="Comparable-和-Comparator"><a href="#Comparable-和-Comparator" class="headerlink" title="Comparable 和 Comparator"></a>Comparable 和 Comparator</h2><p><strong>comparable</strong> 接口实际上是出自java.lang包 它有一个 **compareTo(Object obj)**方法用来排序</p>
<p><strong>comparator</strong>接口实际上是出自 java.util 包它有一个**compare(Object obj1, Object obj2)**方法用来排序</p>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>. </p>
<p>Comparator 定制排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">       arrayList.add(-<span class="number">1</span>);</span><br><span class="line">       arrayList.add(<span class="number">3</span>);</span><br><span class="line">       arrayList.add(<span class="number">3</span>);</span><br><span class="line">       arrayList.add(-<span class="number">5</span>);</span><br><span class="line">       arrayList.add(<span class="number">7</span>);</span><br><span class="line">       arrayList.add(<span class="number">4</span>);</span><br><span class="line">       arrayList.add(-<span class="number">9</span>);</span><br><span class="line">       arrayList.add(-<span class="number">7</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;原始数组:&quot;</span>);</span><br><span class="line">       System.out.println(arrayList);</span><br><span class="line">       <span class="comment">// void reverse(List list)：反转</span></span><br><span class="line">       Collections.reverse(arrayList);</span><br><span class="line">       System.out.println(<span class="string">&quot;Collections.reverse(arrayList):&quot;</span>);</span><br><span class="line">       System.out.println(arrayList);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// void sort(List list),按自然排序的升序排序</span></span><br><span class="line">       Collections.sort(arrayList);</span><br><span class="line">       System.out.println(<span class="string">&quot;Collections.sort(arrayList):&quot;</span>);</span><br><span class="line">       System.out.println(arrayList);</span><br><span class="line">       <span class="comment">// 定制排序的用法</span></span><br><span class="line">       Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       System.out.println(<span class="string">&quot;定制排序后：&quot;</span>);</span><br><span class="line">       System.out.println(arrayList);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始数组:</span><br><span class="line">[-<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, -<span class="number">9</span>, -<span class="number">7</span>]</span><br><span class="line">Collections.reverse(arrayList):</span><br><span class="line">[-<span class="number">7</span>, -<span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>]</span><br><span class="line">Collections.sort(arrayList):</span><br><span class="line">[-<span class="number">9</span>, -<span class="number">7</span>, -<span class="number">5</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line">定制排序后：</span><br><span class="line">[<span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">5</span>, -<span class="number">7</span>, -<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>重写 compareTo 方法实现按年龄来排序</p>
<p>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列<br>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他<br>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * T重写compareTo方法实现按年龄来排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &gt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.age &lt; o.getAge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Output：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>-小红</span><br><span class="line"><span class="number">10</span>-王五</span><br><span class="line"><span class="number">20</span>-李四</span><br><span class="line"><span class="number">30</span>-张三</span><br></pre></td></tr></table></figure>

<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>Collections 工具类常用方法:</p>
<ul>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ul>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List list, <span class="type">int</span> i , <span class="type">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List list, <span class="type">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br></pre></td></tr></table></figure>

<h3 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span><br></pre></td></tr></table></figure>

<h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>
<p>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt;  c) <span class="comment">//返回指定 collection 支持的同步（线程安全的）collection。</span></span><br><span class="line">synchronizedList(List&lt;T&gt; list)<span class="comment">//返回指定列表支持的同步（线程安全的）List。</span></span><br><span class="line">synchronizedMap(Map&lt;K,V&gt; m) <span class="comment">//返回由指定映射支持的同步（线程安全的）Map。</span></span><br><span class="line">synchronizedSet(Set&lt;T&gt; s) <span class="comment">//返回指定 set 支持的同步（线程安全的）set。</span></span><br></pre></td></tr></table></figure>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913234928191.png" alt="image-20220913234928191"></p>
<h3 id="Stream概述"><a href="#Stream概述" class="headerlink" title="Stream概述"></a>Stream概述</h3><p>Java 8 是一个非常成功的版本，这个版本新增的<code>Stream</code>，配合同版本出现的 <code>Lambda</code> ，给我们操作[集合]（Collection）提供了极大的便利。</p>
<p>那么什么是<code>Stream</code>？</p>
<p><code>Stream</code>将要处理的元素集合看作一种流，在流的过程中，借助<code>Stream API</code>对流中的元素进行操作，比如：筛选、排序、聚合等。</p>
<p><code>Stream</code>可以由数组或集合创建，对流的操作分为两种：</p>
<ol>
<li><p>中间操作，每次返回一个新的流，可以有多个。</p>
</li>
<li><p>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。</p>
</li>
</ol>
<p>另外，<code>Stream</code>有几个特性：</p>
<ol>
<li><p>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</p>
</li>
<li><p>stream不会改变数据源，通常情况下会产生一个新的集合或一个值。</p>
</li>
<li><p>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</p>
</li>
</ol>
<h3 id="Stream的创建"><a href="#Stream的创建" class="headerlink" title="Stream的创建"></a>Stream的创建</h3><p><code>Stream</code>可以通过集合数组创建。</p>
<p>1、通过 <code>java.util.Collection.stream()</code> 方法用集合创建流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">// 创建一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br></pre></td></tr></table></figure>

<p>2、使用<code>java.util.Arrays.stream(T[] array)</code>方法用数组创建流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(array);</span><br></pre></td></tr></table></figure>

<p>3、使用<code>Stream</code>的静态方法：<code>of()、iterate()、generate()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">3</span>).limit(<span class="number">4</span>);</span><br><span class="line">stream2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">3</span>);</span><br><span class="line">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">6</span> <span class="number">9</span></span><br><span class="line"><span class="number">0.6796156909271994</span></span><br><span class="line"><span class="number">0.1914314208854283</span></span><br><span class="line"><span class="number">0.8116932592396652</span></span><br></pre></td></tr></table></figure>

<p><strong><code>stream</code>和<code>parallelStream</code>的简单区分：</strong> <code>stream</code>是顺序流，由主线程按顺序对流执行操作，而<code>parallelStream</code>是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913234027609.png" alt="image-20220913234027609"></p>
<p>如果流中的数据量足够大，并行流可以加快处速度。</p>
<p>除了直接创建并行流，还可以通过<code>parallel()</code>把顺序流转换成并行流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; findFirst = list.stream().parallel().filter(x-&gt;x&gt;<span class="number">6</span>).findFirst();</span><br></pre></td></tr></table></figure>

<h3 id="Stream的使用"><a href="#Stream的使用" class="headerlink" title="Stream的使用"></a>Stream的使用</h3><p>在使用stream之前，先理解一个概念：<code>Optional</code> 。</p>
<p><code>Optional</code>类是一个可以为<code>null</code>的容器对象。如果值存在则<code>isPresent()</code>方法会返回<code>true</code>，调用<code>get()</code>方法会返回该对象。<br>更详细说明请见：<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java8-optional-class.html">菜鸟教程Java 8 Optional类</a></p>
<p><strong>接下来，大批代码向你袭来！我将用20个案例将Stream的使用整得明明白白，只要跟着敲一遍代码，就能很好地掌握。</strong></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220913235841490.png" alt="image-20220913235841490"></p>
<h4 id="案例使用的员工类"><a href="#案例使用的员工类" class="headerlink" title="案例使用的员工类"></a><strong>案例使用的员工类</strong></h4><p>这是后面案例中使用的员工类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;  <span class="comment">// 姓名</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> salary; <span class="comment">// 薪资</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">	<span class="keyword">private</span> String sex; <span class="comment">//性别</span></span><br><span class="line">	<span class="keyword">private</span> String area;  <span class="comment">// 地区</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> salary, <span class="type">int</span> age,String sex,String area)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.salary = salary;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">		<span class="built_in">this</span>.sex = sex;</span><br><span class="line">		<span class="built_in">this</span>.area = area;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略了get和set，请自行添加</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="遍历-匹配（foreach-find-match）"><a href="#遍历-匹配（foreach-find-match）" class="headerlink" title="遍历/匹配（foreach/find/match）"></a><strong>遍历/匹配（foreach/find/match）</strong></h4><p><code>Stream</code>也是支持类似集合的遍历和匹配元素的，只是<code>Stream</code>中的元素是以<code>Optional</code>类型存在的。<code>Stream</code>的遍历、匹配非常简单。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/2020110914450139.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import已省略，请自行添加，后面代码亦是</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历输出符合条件的元素</span></span><br><span class="line">        list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 匹配第一个</span></span><br><span class="line">        Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).findFirst();</span><br><span class="line">        <span class="comment">// 匹配任意（适用于并行流）</span></span><br><span class="line">        Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; <span class="number">6</span>).findAny();</span><br><span class="line">        <span class="comment">// 是否包含符合特定条件的元素</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> list.stream().anyMatch(x -&gt; x &gt; <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配第一个值：&quot;</span> + findFirst.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配任意一个值：&quot;</span> + findAny.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在大于6的值：&quot;</span> + anyMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="筛选（filter）"><a href="#筛选（filter）" class="headerlink" title="筛选（filter）"></a><strong>筛选（filter）</strong></h4><p>筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/20201109144706541.jpg" alt="在这里插入图片描述"></p>
<p><strong>案例一：筛选出<code>Integer</code>集合中大于7的元素，并打印出来</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Integer&gt; list = Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">		Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">		stream.filter(x -&gt; x &gt; <span class="number">7</span>).forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预期结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 9</span><br></pre></td></tr></table></figure>

<p><strong>案例二： 筛选员工中工资高于8000的人，并形成新的集合。</strong> 形成新集合依赖<code>collect</code>（收集），后文有详细介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">		List&lt;String&gt; fiterList = personList.stream().filter(x -&gt; x.getSalary() &gt; <span class="number">8000</span>).map(Person::getName)</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		System.out.print(<span class="string">&quot;薪资高于8000美元的员工：&quot;</span> + fiterList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">薪资高于<span class="number">8000</span>美元的员工：[Tom, Anni, Owen]</span><br></pre></td></tr></table></figure>

<h4 id="聚合（max-min-count"><a href="#聚合（max-min-count" class="headerlink" title="聚合（max/min/count)"></a><strong>聚合（max/min/count)</strong></h4><p><code>max</code>、<code>min</code>、<code>count</code>这些字眼你一定不陌生，没错，在mysql中我们常用它们进行数据统计。Java stream中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/20201109145217354.png" alt="在这里插入图片描述"></p>
<p><strong>案例一：获取<code>String</code>集合中最长的元素。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;adnm&quot;</span>, <span class="string">&quot;admmt&quot;</span>, <span class="string">&quot;pot&quot;</span>, <span class="string">&quot;xbangd&quot;</span>, <span class="string">&quot;weoujgsd&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Optional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));</span><br><span class="line">		System.out.println(<span class="string">&quot;最长的字符串：&quot;</span> + max.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最长的字符串：weoujgsd</span><br></pre></td></tr></table></figure>

<p><strong>案例二：获取<code>Integer</code>集合中的最大值。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 自然排序</span></span><br><span class="line">		Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class="line">		<span class="comment">// 自定义排序（从大到小排序）</span></span><br><span class="line">		Optional&lt;Integer&gt; max2 = list.stream().max((o1, o2) -&gt; o2 - o1);</span><br><span class="line">		System.out.println(<span class="string">&quot;自然排序的最大值：&quot;</span> + max.get());</span><br><span class="line">		System.out.println(<span class="string">&quot;自定义排序的最大值：&quot;</span> + max2.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自然排序的最大值：<span class="number">11</span></span><br><span class="line">自定义排序的最大值：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>案例三：获取员工薪资最高的人。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">		Optional&lt;Person&gt; max = personList.stream().max(Comparator.comparingInt(Person::getSalary));</span><br><span class="line">		System.out.println(<span class="string">&quot;员工薪资最大值：&quot;</span> + max.get().getSalary());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">员工薪资最大值：<span class="number">9500</span></span><br></pre></td></tr></table></figure>

<p><strong>案例四：计算<code>Integer</code>集合中大于6的元素的个数。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).count();</span><br><span class="line">		System.out.println(<span class="string">&quot;list中大于6的元素个数：&quot;</span> + count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list中大于<span class="number">6</span>的元素个数：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="映射-map-flatMap"><a href="#映射-map-flatMap" class="headerlink" title="映射(map/flatMap)"></a><strong>映射(map/flatMap)</strong></h4><p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为<code>map</code>和<code>flatMap</code>：</p>
<ul>
<li><code>map</code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li>
<li><code>flatMap</code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/20201109145252340.jpg" alt="在这里插入图片描述"></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/2020110914550762.jpg" alt="在这里插入图片描述"></p>
<p><strong>案例一：英文字符串数组的元素全部改为大写。整数数组每个元素+3。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String[] strArr = &#123; <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;bcdd&quot;</span>, <span class="string">&quot;defde&quot;</span>, <span class="string">&quot;fTr&quot;</span> &#125;;</span><br><span class="line">		List&lt;String&gt; strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>);</span><br><span class="line">		List&lt;Integer&gt; intListNew = intList.stream().map(x -&gt; x + <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;每个元素大写：&quot;</span> + strList);</span><br><span class="line">		System.out.println(<span class="string">&quot;每个元素+3：&quot;</span> + intListNew);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个元素大写：[ABCD, BCDD, DEFDE, FTR]</span><br><span class="line">每个元素+<span class="number">3</span>：[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>]</span><br></pre></td></tr></table></figure>

<p><strong>案例二：将员工的薪资全部增加1000。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 不改变原来员工集合的方式</span></span><br><span class="line">		List&lt;Person&gt; personListNew = personList.stream().map(person -&gt; &#123;</span><br><span class="line">			<span class="type">Person</span> <span class="variable">personNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(person.getName(), <span class="number">0</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">			personNew.setSalary(person.getSalary() + <span class="number">10000</span>);</span><br><span class="line">			<span class="keyword">return</span> personNew;</span><br><span class="line">		&#125;).collect(Collectors.toList());</span><br><span class="line">		System.out.println(<span class="string">&quot;一次改动前：&quot;</span> + personList.get(<span class="number">0</span>).getName() + <span class="string">&quot;--&gt;&quot;</span> + personList.get(<span class="number">0</span>).getSalary());</span><br><span class="line">		System.out.println(<span class="string">&quot;一次改动后：&quot;</span> + personListNew.get(<span class="number">0</span>).getName() + <span class="string">&quot;--&gt;&quot;</span> + personListNew.get(<span class="number">0</span>).getSalary());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 改变原来员工集合的方式</span></span><br><span class="line">		List&lt;Person&gt; personListNew2 = personList.stream().map(person -&gt; &#123;</span><br><span class="line">			person.setSalary(person.getSalary() + <span class="number">10000</span>);</span><br><span class="line">			<span class="keyword">return</span> person;</span><br><span class="line">		&#125;).collect(Collectors.toList());</span><br><span class="line">		System.out.println(<span class="string">&quot;二次改动前：&quot;</span> + personList.get(<span class="number">0</span>).getName() + <span class="string">&quot;--&gt;&quot;</span> + personListNew.get(<span class="number">0</span>).getSalary());</span><br><span class="line">		System.out.println(<span class="string">&quot;二次改动后：&quot;</span> + personListNew2.get(<span class="number">0</span>).getName() + <span class="string">&quot;--&gt;&quot;</span> + personListNew.get(<span class="number">0</span>).getSalary());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一次改动前：Tom–&gt;<span class="number">8900</span></span><br><span class="line">一次改动后：Tom–&gt;<span class="number">18900</span></span><br><span class="line">二次改动前：Tom–&gt;<span class="number">18900</span></span><br><span class="line">二次改动后：Tom–&gt;<span class="number">18900</span></span><br></pre></td></tr></table></figure>

<p><strong>案例三：将两个字符数组合并成一个新的字符数组。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;m,k,l,a&quot;</span>, <span class="string">&quot;1,3,5,7&quot;</span>);</span><br><span class="line">		List&lt;String&gt; listNew = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">			<span class="comment">// 将每个元素转换成一个stream</span></span><br><span class="line">			String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">			Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">			<span class="keyword">return</span> s2;</span><br><span class="line">		&#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;处理前的集合：&quot;</span> + list);</span><br><span class="line">		System.out.println(<span class="string">&quot;处理后的集合：&quot;</span> + listNew);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">处理前的集合：[m-k-l-a, <span class="number">1</span>-<span class="number">3</span>-<span class="number">5</span>]</span><br><span class="line">处理后的集合：[m, k, l, a, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>此外，map系列还有mapToInt、mapToLong、mapToDouble三个函数，它们以一个映射函数为入参，将流中每一个元素处理后生成一个新流。以mapToInt为例，看两个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">	<span class="comment">// 输出字符串集合中每个字符串的长度</span></span><br><span class="line">    List&lt;String&gt; stringList = Arrays.asList(<span class="string">&quot;mu&quot;</span>, <span class="string">&quot;CSDN&quot;</span>, <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">            <span class="string">&quot;world&quot;</span>, <span class="string">&quot;quickly&quot;</span>);</span><br><span class="line">    stringList.stream().mapToInt(String::length).forEach(System.out::println);</span><br><span class="line">    <span class="comment">// 将int集合的每个元素增加1000</span></span><br><span class="line">    List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line">    integerList.stream().mapToInt(x -&gt; x + <span class="number">1000</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapToInt三个函数生成的新流，可以进行很多后续操作，比如求最大最小值、求和、求平均值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Double&gt; doubleList = Arrays.asList(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>);</span><br><span class="line">    <span class="type">double</span> <span class="variable">average</span> <span class="operator">=</span> doubleList.stream().mapToDouble(Number::doubleValue).average().getAsDouble();</span><br><span class="line">    <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> doubleList.stream().mapToDouble(Number::doubleValue).sum();</span><br><span class="line">    <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> doubleList.stream().mapToDouble(Number::doubleValue).max().getAsDouble();</span><br><span class="line">    System.out.println(<span class="string">&quot;平均值：&quot;</span> + average + <span class="string">&quot;，总和：&quot;</span> + sum + <span class="string">&quot;，最大值：&quot;</span> + max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归约-reduce"><a href="#归约-reduce" class="headerlink" title="归约([reduce]"></a><strong>归约([reduce]</strong></h4><p>归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220916150426319.png" alt="image-20220916150426319"></p>
<p><strong>案例一：求<code>Integer</code>集合的元素之和、乘积和最大值。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">4</span>);</span><br><span class="line">		<span class="comment">// 求和方式1</span></span><br><span class="line">		Optional&lt;Integer&gt; sum = list.stream().reduce((x, y) -&gt; x + y);</span><br><span class="line">		<span class="comment">// 求和方式2</span></span><br><span class="line">		Optional&lt;Integer&gt; sum2 = list.stream().reduce(Integer::sum);</span><br><span class="line">		<span class="comment">// 求和方式3</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">sum3</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 求乘积</span></span><br><span class="line">		Optional&lt;Integer&gt; product = list.stream().reduce((x, y) -&gt; x * y);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 求最大值方式1</span></span><br><span class="line">		Optional&lt;Integer&gt; max = list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);</span><br><span class="line">		<span class="comment">// 求最大值写法2</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">max2</span> <span class="operator">=</span> list.stream().reduce(<span class="number">1</span>, Integer::max);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;list求和：&quot;</span> + sum.get() + <span class="string">&quot;,&quot;</span> + sum2.get() + <span class="string">&quot;,&quot;</span> + sum3);</span><br><span class="line">		System.out.println(<span class="string">&quot;list求积：&quot;</span> + product.get());</span><br><span class="line">		System.out.println(<span class="string">&quot;list求最大值：&quot;</span> + max.get() + <span class="string">&quot;,&quot;</span> + max2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list求和：<span class="number">29</span>,<span class="number">29</span>,<span class="number">29</span></span><br><span class="line">list求积：<span class="number">2112</span></span><br><span class="line">list求最大值：<span class="number">11</span>,<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p><strong>案例二：求所有员工的工资之和和最高工资。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 求工资之和方式1：</span></span><br><span class="line">		Optional&lt;Integer&gt; sumSalary = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">		<span class="comment">// 求工资之和方式2：</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">sumSalary2</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getSalary(),</span><br><span class="line">				(sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line">		<span class="comment">// 求工资之和方式3：</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">sumSalary3</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getSalary(), Integer::sum);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 求最高工资方式1：</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">maxSalary</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class="line">				Integer::max);</span><br><span class="line">		<span class="comment">// 求最高工资方式2：</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">maxSalary2</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class="line">				(max1, max2) -&gt; max1 &gt; max2 ? max1 : max2);</span><br><span class="line">		<span class="comment">// 求最高工资方式3：</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">maxSalary3</span> <span class="operator">=</span> personList.stream().map(Person::getSalary).reduce(Integer::max).get();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;工资之和：&quot;</span> + sumSalary.get() + <span class="string">&quot;,&quot;</span> + sumSalary2 + <span class="string">&quot;,&quot;</span> + sumSalary3);</span><br><span class="line">		System.out.println(<span class="string">&quot;最高工资：&quot;</span> + maxSalary + <span class="string">&quot;,&quot;</span> + maxSalary2 + <span class="string">&quot;,&quot;</span> + maxSalary3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">工资之和：<span class="number">49300</span>,<span class="number">49300</span>,<span class="number">49300</span></span><br><span class="line">最高工资：<span class="number">9500</span>,<span class="number">9500</span></span><br></pre></td></tr></table></figure>

<h4 id="收集-collect"><a href="#收集-collect" class="headerlink" title="收集(collect)"></a><strong>收集(collect)</strong></h4><p><code>collect</code>，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。</p>
<p><code>collect</code>主要依赖<code>java.util.stream.Collectors</code>类内置的静态方法。</p>
<h5 id="归集-toList-toSet-toMap"><a href="#归集-toList-toSet-toMap" class="headerlink" title="归集(toList/toSet/toMap)"></a>归集(toList/toSet/toMap)</h5><p>因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。<code>toList</code>、<code>toSet</code>和<code>toMap</code>比较常用，另外还有<code>toCollection</code>、<code>toConcurrentMap</code>等复杂一些的用法。</p>
<p>下面用一个案例演示<code>toList</code>、<code>toSet</code>和<code>toMap</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line">		List&lt;Integer&gt; listNew = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">		Set&lt;Integer&gt; set = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		</span><br><span class="line">		Map&lt;?, Person&gt; map = personList.stream().filter(p -&gt; p.getSalary() &gt; <span class="number">8000</span>)</span><br><span class="line">				.collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br><span class="line">		System.out.println(<span class="string">&quot;toList:&quot;</span> + listNew);</span><br><span class="line">		System.out.println(<span class="string">&quot;toSet:&quot;</span> + set);</span><br><span class="line">		System.out.println(<span class="string">&quot;toMap:&quot;</span> + map);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toList：[<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">20</span>]</span><br><span class="line">toSet：[<span class="number">4</span>, <span class="number">20</span>, <span class="number">6</span>]</span><br><span class="line">toMap：&#123;Tom=mutest.Person@5fd0d5ae, Anni=mutest.Person@2d98a335&#125;</span><br></pre></td></tr></table></figure>

<h5 id="统计-count-averaging"><a href="#统计-count-averaging" class="headerlink" title="统计(count/averaging)"></a>统计(count/averaging)</h5><p><code>Collectors</code>提供了一系列用于数据统计的静态方法：</p>
<ul>
<li>计数：count</li>
<li>平均值：averagingInt、averagingLong、averagingDouble</li>
<li>最值：maxBy、minBy</li>
<li>求和：summingInt、summingLong、summingDouble</li>
<li>统计以上所有：summarizingInt、summarizingLong、summarizingDouble</li>
</ul>
<p><strong>案例：统计员工人数、平均工资、工资总额、最高工资。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 求总数</span></span><br><span class="line">		<span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> personList.stream().collect(Collectors.counting());</span><br><span class="line">		<span class="comment">// 求平均工资</span></span><br><span class="line">		<span class="type">Double</span> <span class="variable">average</span> <span class="operator">=</span> personList.stream().collect(Collectors.averagingDouble(Person::getSalary));</span><br><span class="line">		<span class="comment">// 求最高工资</span></span><br><span class="line">		Optional&lt;Integer&gt; max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));</span><br><span class="line">		<span class="comment">// 求工资之和</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class="line">		<span class="comment">// 一次性统计所有信息</span></span><br><span class="line">		<span class="type">DoubleSummaryStatistics</span> <span class="variable">collect</span> <span class="operator">=</span> personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;员工总数：&quot;</span> + count);</span><br><span class="line">		System.out.println(<span class="string">&quot;员工平均工资：&quot;</span> + average);</span><br><span class="line">		System.out.println(<span class="string">&quot;员工工资总和：&quot;</span> + sum);</span><br><span class="line">		System.out.println(<span class="string">&quot;员工工资所有统计：&quot;</span> + collect);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">员工总数：<span class="number">3</span></span><br><span class="line">员工平均工资：<span class="number">7900.0</span></span><br><span class="line">员工工资总和：<span class="number">23700</span></span><br><span class="line">员工工资所有统计：DoubleSummaryStatistics&#123;count=<span class="number">3</span>, sum=<span class="number">23700.000000</span>,min=<span class="number">7000.000000</span>, average=<span class="number">7900.000000</span>, max=<span class="number">8900.000000</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="分组-partitioningBy-groupingBy"><a href="#分组-partitioningBy-groupingBy" class="headerlink" title="分组(partitioningBy/groupingBy)"></a>分组(partitioningBy/groupingBy)</h5><ul>
<li><p>区：将<code>stream</code>按条件分为两个<code>Map</code>，比如员工按薪资是否高于8000分为两部分。</p>
</li>
<li><p>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。</p>
</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220917120840030.png" alt="image-20220917120840030"></p>
<p><strong>案例：将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将员工按薪资是否高于8000分组</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Person&gt;&gt; part = personList.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; <span class="number">8000</span>));</span><br><span class="line">        <span class="comment">// 将员工按性别分组</span></span><br><span class="line">        Map&lt;String, List&lt;Person&gt;&gt; group = personList.stream().collect(Collectors.groupingBy(Person::getSex));</span><br><span class="line">        <span class="comment">// 将员工先按性别分组，再按地区分组</span></span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));</span><br><span class="line">        System.out.println(<span class="string">&quot;员工按薪资是否大于8000分组情况：&quot;</span> + part);</span><br><span class="line">        System.out.println(<span class="string">&quot;员工按性别分组情况：&quot;</span> + group);</span><br><span class="line">        System.out.println(<span class="string">&quot;员工按性别、地区：&quot;</span> + group2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">员工按薪资是否大于<span class="number">8000</span>分组情况：&#123;<span class="literal">false</span>=[mutest.Person@2d98a335, mutest.Person@16b98e56, mutest.Person@7ef20235], <span class="literal">true</span>=[mutest.Person@27d6c5e0, mutest.Person@4f3f5b24, mutest.Person@15aeb7ab]&#125;</span><br><span class="line">员工按性别分组情况：&#123;female=[mutest.Person@16b98e56, mutest.Person@4f3f5b24, mutest.Person@7ef20235], male=[mutest.Person@27d6c5e0, mutest.Person@2d98a335, mutest.Person@15aeb7ab]&#125;</span><br><span class="line">员工按性别、地区：&#123;female=&#123;New York=[mutest.Person@4f3f5b24, mutest.Person@7ef20235], Washington=[mutest.Person@16b98e56]&#125;, male=&#123;New York=[mutest.Person@27d6c5e0, mutest.Person@15aeb7ab], Washington=[mutest.Person@2d98a335]&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="接合-joining"><a href="#接合-joining" class="headerlink" title="接合(joining)"></a>接合(joining)</h5><p><code>joining</code>可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> personList.stream().map(p -&gt; p.getName()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;所有员工的姓名：&quot;</span> + names);</span><br><span class="line">		List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> list.stream().collect(Collectors.joining(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;拼接后的字符串：&quot;</span> + string);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有员工的姓名：Tom,Jack,Lily</span><br><span class="line">拼接后的字符串：A-B-C</span><br></pre></td></tr></table></figure>

<h5 id="归约-reducing"><a href="#归约-reducing" class="headerlink" title="归约(reducing)"></a>归约(reducing)</h5><p><code>Collectors</code>类提供的<code>reducing</code>方法，相比于<code>stream</code>本身的<code>reduce</code>方法，增加了对自定义归约的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> personList.stream().collect(Collectors.reducing(<span class="number">0</span>, Person::getSalary, (i, j) -&gt; (i + j - <span class="number">5000</span>)));</span><br><span class="line">		System.out.println(<span class="string">&quot;员工扣税薪资总和：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// stream的reduce</span></span><br><span class="line">		Optional&lt;Integer&gt; sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">		System.out.println(<span class="string">&quot;员工薪资总和：&quot;</span> + sum2.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">员工扣税薪资总和：<span class="number">8700</span></span><br><span class="line">员工薪资总和：<span class="number">23700</span></span><br></pre></td></tr></table></figure>

<h4 id="排序-sorted"><a href="#排序-sorted" class="headerlink" title="排序(sorted)"></a><strong>排序(sorted)</strong></h4><p>sorted，中间操作。有两种排序：</p>
<ul>
<li><p>sorted()：自然排序，流中元素需实现Comparable接口</p>
</li>
<li><p>sorted(Comparator com)：Comparator排序器自定义排序</p>
</li>
</ul>
<p><strong>案例：将员工按工资由高到低（工资一样则按年龄由大到小）排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Sherry&quot;</span>, <span class="number">9000</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">22</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">9000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">8800</span>, <span class="number">26</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">		personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alisa&quot;</span>, <span class="number">9000</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 按工资升序排序（自然排序）</span></span><br><span class="line">		List&lt;String&gt; newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		<span class="comment">// 按工资倒序排序</span></span><br><span class="line">		List&lt;String&gt; newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())</span><br><span class="line">				.map(Person::getName).collect(Collectors.toList());</span><br><span class="line">		<span class="comment">// 先按工资再按年龄升序排序</span></span><br><span class="line">		List&lt;String&gt; newList3 = personList.stream()</span><br><span class="line">				.sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		<span class="comment">// 先按工资再按年龄自定义排序（降序）</span></span><br><span class="line">		List&lt;String&gt; newList4 = personList.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (p1.getSalary() == p2.getSalary()) &#123;</span><br><span class="line">				<span class="keyword">return</span> p2.getAge() - p1.getAge();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> p2.getSalary() - p1.getSalary();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).map(Person::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;按工资升序排序：&quot;</span> + newList);</span><br><span class="line">		System.out.println(<span class="string">&quot;按工资降序排序：&quot;</span> + newList2);</span><br><span class="line">		System.out.println(<span class="string">&quot;先按工资再按年龄升序排序：&quot;</span> + newList3);</span><br><span class="line">		System.out.println(<span class="string">&quot;先按工资再按年龄自定义降序排序：&quot;</span> + newList4);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]</span><br><span class="line">先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]</span><br></pre></td></tr></table></figure>

<h2 id="提取-组合"><a href="#提取-组合" class="headerlink" title="提取/组合"></a>提取/组合</h2><p>流也可以进行合并、去重、限制、跳过等操作。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220917162850402.png" alt="image-20220917162850402"></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220917162902235.png" alt="image-20220917162902235"></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/image-20220917162914500.png" alt="image-20220917162914500"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String[] arr1 = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line">		String[] arr2 = &#123; <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">		Stream&lt;String&gt; stream1 = Stream.of(arr1);</span><br><span class="line">		Stream&lt;String&gt; stream2 = Stream.of(arr2);</span><br><span class="line">		<span class="comment">// concat:合并两个流 distinct：去重</span></span><br><span class="line">		List&lt;String&gt; newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());</span><br><span class="line">		<span class="comment">// limit：限制从流中获得前n个数据</span></span><br><span class="line">		List&lt;Integer&gt; collect = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).limit(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line">		<span class="comment">// skip：跳过前n个数据</span></span><br><span class="line">		List&lt;Integer&gt; collect2 = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).skip(<span class="number">1</span>).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;流合并：&quot;</span> + newList);</span><br><span class="line">		System.out.println(<span class="string">&quot;limit：&quot;</span> + collect);</span><br><span class="line">		System.out.println(<span class="string">&quot;skip：&quot;</span> + collect2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">流合并：[a, b, c, d, e, f, g]</span><br><span class="line">limit：[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br><span class="line">skip：[<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure>

<h1 id="集合使用注意事项总结"><a href="#集合使用注意事项总结" class="headerlink" title="集合使用注意事项总结"></a>集合使用注意事项总结</h1><h2 id="集合判空"><a href="#集合判空" class="headerlink" title="集合判空"></a><strong>集合判空</strong></h2><p>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式。</p>
<p>这是因为 <code>isEmpty()</code> 方法的可读性更好，并且时间复杂度为 O(1)。</p>
<p>绝大部分我们使用的集合的 <code>size()</code> 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 <code>java.util.concurrent</code> 包下的某些集合（<code>ConcurrentLinkedQueue</code> 、<code>ConcurrentHashMap</code>…）。</p>
<p>下面是 <code>ConcurrentHashMap</code> 的 <code>size()</code> 方法和 <code>isEmpty()</code> 方法的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="type">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="type">int</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="集合转-Map"><a href="#集合转-Map" class="headerlink" title="集合转 Map"></a>集合转 Map</h2><p>阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">     <span class="comment">// getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line">List&lt;Person&gt; bookList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;18163138123&quot;</span>));</span><br><span class="line">bookList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;martin&quot;</span>,<span class="literal">null</span>));</span><br><span class="line"><span class="comment">// 空指针异常</span></span><br><span class="line">bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));</span><br></pre></td></tr></table></figure>

<p>下面我们来解释一下原因。</p>
<p>首先，我们来看 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法 ，可以看到其内部调用了 <code>Map</code> 接口的 <code>merge()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M <span class="keyword">extends</span> <span class="title class_">Map</span>&lt;K, U&gt;&gt;</span><br><span class="line">Collector&lt;T, ?, M&gt; toMap(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; keyMapper,</span><br><span class="line">                            Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; valueMapper,</span><br><span class="line">                            BinaryOperator&lt;U&gt; mergeFunction,</span><br><span class="line">                            Supplier&lt;M&gt; mapSupplier) &#123;</span><br><span class="line">    BiConsumer&lt;M, T&gt; accumulator</span><br><span class="line">            = (map, element) -&gt; map.merge(keyMapper.apply(element),</span><br><span class="line">                                          valueMapper.apply(element), mergeFunction);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Map</code> 接口的 <code>merge()</code> 方法如下，这个方法是接口中的默认实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> V <span class="title function_">merge</span><span class="params">(K key, V value,</span></span><br><span class="line"><span class="params">        BiFunction&lt;? <span class="built_in">super</span> V, ? <span class="built_in">super</span> V, ? extends V&gt; remappingFunction)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    Objects.requireNonNull(value);</span><br><span class="line">    <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> get(key);</span><br><span class="line">    <span class="type">V</span> <span class="variable">newValue</span> <span class="operator">=</span> (oldValue == <span class="literal">null</span>) ? value :</span><br><span class="line">               remappingFunction.apply(oldValue, value);</span><br><span class="line">    <span class="keyword">if</span>(newValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>merge()</code> 方法会先调用 <code>Objects.requireNonNull()</code> 方法判断 value 是否为空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T requireNonNull(T obj) &#123;</span><br><span class="line">    if (obj == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h2><p>阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>不要在 foreach 循环里进行元素的</strong> <strong><code>remove/add</code></strong> <strong>操作。remove 元素请使用</strong> <strong><code>Iterator</code></strong> <strong>方式，如果并发操作，需要对</strong> <strong><code>Iterator</code></strong> <strong>对象加锁。</strong></p>
</blockquote>
<p>通过反编译你会发现 foreach 语法糖底层其实还是依赖 <code>Iterator</code> 。不过， <code>remove/add</code> 操作直接调用的是集合自己的方法，而不是 <code>Iterator</code> 的 <code>remove/add</code>方法</p>
<p>这就导致 <code>Iterator</code> 莫名其妙地发现自己有元素被 <code>remove/add</code> ，然后，它就会抛出一个 <code>ConcurrentModificationException</code> 来提示用户发生了并发修改异常。这就是单线程状态下产生的 <strong>fail-fast 机制</strong>。</p>
<blockquote>
<p><strong>fail-fast 机制</strong> <strong>：多个线程对 fail-fast 集合进行修改的时候，可能会抛出</strong><code>ConcurrentModificationException</code><strong>。 即使是单线程下也有可能会出现这种情况，上面已经提到过</strong>。</p>
</blockquote>
<p>Java8 开始，可以使用 <code>Collection#removeIf()</code>方法删除满足特定条件的元素,如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.removeIf(filter -&gt; filter % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">/* 删除list中的所有偶数 */</span></span><br><span class="line">System.out.println(list); <span class="comment">/* [1, 3, 5, 7, 9] */</span></span><br></pre></td></tr></table></figure>

<p>除了上面介绍的直接使用 <code>Iterator</code> 进行遍历操作之外，你还可以：</p>
<ul>
<li>使用普通的 for 循环</li>
<li>使用 fail-safe 的集合类。<code>java.util</code>包下面的所有的集合类都是 fail-fast 的，而<code>java.util.concurrent</code>包下面的所有的类都是 fail-safe 的。</li>
<li>……</li>
</ul>
<h2 id="集合去重"><a href="#集合去重" class="headerlink" title="集合去重"></a>集合去重</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作。</strong></p>
</blockquote>
<p>这里我们以 <code>HashSet</code> 和 <code>ArrayList</code> 为例说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">removeDuplicateBySet</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// List 去重代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">removeDuplicateByList</span><span class="params">(List&lt;T&gt; data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(data.size());</span><br><span class="line">    <span class="keyword">for</span> (T current : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.contains(current)) &#123;</span><br><span class="line">            result.add(current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者的核心差别在于 <code>contains()</code> 方法的实现。</p>
<p><code>HashSet</code> 的 <code>contains()</code> 方法底部依赖的 <code>HashMap</code> 的 <code>containsKey()</code> 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。</p>
<p><code>ArrayList</code> 的 <code>contains()</code> 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的 <code>List</code> 有 N 个元素，那时间复杂度就接近是 O (n^2)。</p>
<h2 id="集合转数组"><a href="#集合转数组" class="headerlink" title="集合转数组"></a>集合转数组</h2><p>《阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</strong></p>
</blockquote>
<p><code>toArray(T[] array)</code> 方法的参数是一个泛型数组，如果 <code>toArray</code> 方法中没有传递任何参数的话返回的是 <code>Object</code>类 型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String [] s= <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">    <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>, <span class="string">&quot;fox&quot;</span>, <span class="string">&quot;brown&quot;</span>, <span class="string">&quot;quick&quot;</span>, <span class="string">&quot;A&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line"><span class="comment">//没有指定类型的话会报错</span></span><br><span class="line">s=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>由于 JVM 优化，<code>new String[0]</code>作为<code>Collection.toArray()</code>方法的参数现在使用更好，<code>new String[0]</code>就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。</p>
<h2 id="数组转集合"><a href="#数组转集合" class="headerlink" title="数组转集合"></a>数组转集合</h2><p>阿里巴巴 Java 开发手册》的描述如下：</p>
<blockquote>
<p><strong>使用工具类 <code>Arrays.asList()</code> 把数组转换成集合时，不能使用其修改集合相关的方法， 它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。</strong></p>
</blockquote>
<p>我在之前的一个项目中就遇到一个类似的坑。</p>
<p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 <code>List</code> 集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>JDK 源码对于这个方法的说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，</span></span><br><span class="line"><span class="comment">  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来总结一下使用注意事项。</p>
<p><strong>1、<code>Arrays.asList()</code>是泛型方法，传递的数组必须是对象数组，而不是基本类型。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">int</span>[] array = (<span class="type">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 <code>List</code> 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>我们使用包装类型数组就可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>2、使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">myList.add(<span class="number">4</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.remove(<span class="number">1</span>);<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br><span class="line">myList.clear();<span class="comment">//运行时报错：UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(myList.getClass());<span class="comment">//class java.util.Arrays$ArrayList</span></span><br></pre></td></tr></table></figure>

<p>下图是 <code>java.util.Arrays$ArrayList</code> 的简易源码，我们可以看到这个类重写的方法有哪些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">      <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.io.Serializable</span><br><span class="line">  &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; c)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们再看一下<code>java.util.AbstractList</code>的 <code>add/remove/clear</code> 方法就知道为什么会抛出 <code>UnsupportedOperationException</code> 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    add(size(), e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    removeRange(<span class="number">0</span>, size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">    ListIterator&lt;E&gt; it = listIterator(fromIndex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, n=toIndex-fromIndex; i&lt;n; i++) &#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>那我们如何正确的将数组转换为 <code>ArrayList</code> ?</strong></p>
<p>1、手动实现工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK1.5+</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="keyword">final</span> T[] array)</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;(array.length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> T s : array) &#123;</span><br><span class="line">    l.add(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">System.out.println(arrayToList(myArray).getClass());<span class="comment">//class java.util.ArrayList</span></span><br></pre></td></tr></table></figure>

<p>2、最简便的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>3、使用 Java8 的 <code>Stream</code>(推荐)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>4、使用 Guava</p>
<p>对于不可变集合，你可以使用<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java"><code>ImmutableList</code></a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java"> </a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java"> (opens new window)</a>类及其<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101"><code>of()</code></a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101"> </a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101"> (opens new window)</a>与<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225"><code>copyOf()</code></a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225"> </a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225"> (opens new window)</a>工厂方法：（参数不能为空）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.copyOf(aStringArray);      <span class="comment">// from array</span></span><br></pre></td></tr></table></figure>

<p>对于可变集合，你可以使用<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java"><code>Lists</code></a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java"> </a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java"> (opens new window)</a>类及其<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87"><code>newArrayList()</code></a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87"> </a><a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87"> (opens new window)</a>工厂方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection);    <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(aStringArray);               <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">&quot;or&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;elements&quot;</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure>

<p>5、使用 Apache Commons Collections</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">CollectionUtils.addAll(list, str);</span><br></pre></td></tr></table></figure>

<p>6、 使用 Java9 的 <code>List.of()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://weishao-996.github.io">Wei Shao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://weishao-996.github.io/2022/09/12/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/">https://weishao-996.github.io/2022/09/12/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://weishao-996.github.io" target="_blank">WeiBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%AE%B9%E5%99%A8/">Java容器</a></div><div class="post_share"><div class="social-share" data-image="/img/bg/WechatIMG48.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/14/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="面试-计算机网络"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试-计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL/" title="面试-Mysql"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试-Mysql</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/bg/WechatIMG48.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wei Shao</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/weishao-996"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/weishao-996" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2427340869@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">写什么代码，一拳打爆地球！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">集合概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">1.1.</span> <span class="toc-text">常见的集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-Set-Queue-Map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">List, Set, Queue, Map 四者的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88"><span class="toc-number">1.3.</span> <span class="toc-text">如何选用集合?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">底层数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.5.</span> <span class="toc-text">线程安全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List"><span class="toc-number">2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%92%8CLinkedList"><span class="toc-number">2.1.</span> <span class="toc-text">ArrayList和LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">ArrayList序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ArrayList%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%BA%8F%E5%88%97%E5%8C%96%E5%85%83%E7%B4%A0%E6%95%B0%E7%BB%84%E5%91%A2%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">为什么ArrayList不直接序列化元素数组呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3ArrayList%E6%80%8E%E4%B9%88%E5%BA%8F%E5%88%97%E5%8C%96%E5%91%A2%EF%BC%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">那ArrayList怎么序列化呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5-fail-fast-%E5%92%8C%E5%AE%89%E5%85%A8%E5%A4%B1%E8%B4%A5-fail-safe"><span class="toc-number">2.4.</span> <span class="toc-text">快速失败(fail-fast)和安全失败(fail-safe)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fail-fast%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">fail-fast的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8Dfail-fast"><span class="toc-number">2.4.2.</span> <span class="toc-text">避免fail-fast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fail-safe%E4%B8%8Efail-fast%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.3.</span> <span class="toc-text">fail-safe与fail-fast的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84List"><span class="toc-number">2.5.</span> <span class="toc-text">线程安全的List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">CopyOnWriteArrayList原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Queue"><span class="toc-number">3.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue-%E4%B8%8E-Deque"><span class="toc-number">3.1.</span> <span class="toc-text">Queue 与 Deque</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityQueue"><span class="toc-number">3.2.</span> <span class="toc-text">PriorityQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayDeque-%E4%B8%8E-LinkedList"><span class="toc-number">3.3.</span> <span class="toc-text">ArrayDeque 与 LinkedList</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Set"><span class="toc-number">4.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">Set概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashSet%EF%BC%88Hash-%E8%A1%A8%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">HashSet（Hash 表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeSet%EF%BC%88%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">4.1.2.</span> <span class="toc-text">TreeSet（二叉树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkHashSet%EF%BC%88HashSet-LinkedHashMap%EF%BC%89"><span class="toc-number">4.1.3.</span> <span class="toc-text">LinkHashSet（HashSet+LinkedHashMap）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">HashSet的底层结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet-%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="toc-number">4.3.</span> <span class="toc-text">HashSet 如何检查重复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">4.4.</span> <span class="toc-text">HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Map"><span class="toc-number">5.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">Map接口的实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">5.2.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E4%B8%AD%E7%9A%84-key-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">HashMap 中的 key 的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.2.</span> <span class="toc-text">HashMap 的底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8-%E4%B9%8B%E5%89%8D"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">JDK1.8 之前</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK1-8-%E4%B9%8B%E5%90%8E"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">JDK1.8 之后</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84-N-%E6%AC%A1%E6%96%B9"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">HashMap 的长度为什么是 2 的 N 次方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">5.2.2.4.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%91%A2%EF%BC%9F"><span class="toc-number">5.2.2.4.1.</span> <span class="toc-text">你对红黑树了解多少？为什么不用二叉树&#x2F;平衡树呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81%E5%B9%B3%E8%A1%A1%E7%9A%84%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-number">5.2.2.4.2.</span> <span class="toc-text">红黑树怎么保持平衡的知道吗？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%98%88%E5%80%BC%E4%B8%BA-8-%E5%91%A2%EF%BC%9F"><span class="toc-number">5.2.2.4.3.</span> <span class="toc-text">为什么HashMap链表转红黑树的阈值为 8 呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">5.2.3.</span> <span class="toc-text">HashMap 的扩容机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%A6%82%E8%BF%B0"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">扩容概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">扩容过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%91%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90%E6%98%AF0-75%EF%BC%9F"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">扩容在什么时候呢？为什么扩容因子是0.75？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%88%9D%E5%A7%8B%E5%8C%96HashMap%EF%BC%8C%E4%BC%A0%E4%B8%80%E4%B8%AA-17-%E7%9A%84%E5%80%BC-new-HashMap-lt-gt-new-HashMap-lt-gt-%EF%BC%8C%E5%AE%83%E4%BC%9A%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">5.2.3.4.</span> <span class="toc-text">如果初始化HashMap，传一个 17 的值 new HashMap&lt;&gt;new HashMap&lt;&gt; ，它会怎么处理？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">5.2.4.</span> <span class="toc-text">HashMap 的线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E5%8A%9E%E6%B3%95%E8%83%BD%E8%A7%A3%E5%86%B3HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98%E5%91%A2"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">有什么办法能解决HashMap线程不安全的问题呢</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84put%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.5.</span> <span class="toc-text">HashMap 的put流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.6.</span> <span class="toc-text">HashMap 的查找元素过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E5%93%88%E5%B8%8C-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.7.</span> <span class="toc-text">HashMap 的哈希&#x2F;扰动函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%88%E5%B8%8C-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0%E8%83%BD%E9%99%8Dhash%E7%A2%B0%E6%92%9E"><span class="toc-number">5.2.7.1.</span> <span class="toc-text">为什么哈希&#x2F;扰动函数能降hash碰撞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%A0%E8%BF%98%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-number">5.2.7.2.</span> <span class="toc-text">你还知道哪些哈希函数的构造方法呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-number">5.2.7.3.</span> <span class="toc-text">解决哈希冲突有哪些方法呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-JDK1-8%E4%BC%98%E5%8C%96"><span class="toc-number">5.2.8.</span> <span class="toc-text">HashMap JDK1.8优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.9.</span> <span class="toc-text">HashMap 手写实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%8A%82%E7%82%B9%E7%B1%BB"><span class="toc-number">5.2.9.1.</span> <span class="toc-text">内部节点类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.9.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.9.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.9.4.</span> <span class="toc-text">散列函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.9.5.</span> <span class="toc-text">put方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.9.6.</span> <span class="toc-text">扩容方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.9.7.</span> <span class="toc-text">get方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-%E7%9A%84%E5%B8%B8%E8%A7%81%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.10.</span> <span class="toc-text">HashMap 的常见遍历方式?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.10.1.</span> <span class="toc-text">遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3%E5%99%A8-EntrySet"><span class="toc-number">5.2.10.1.1.</span> <span class="toc-text">1.迭代器 EntrySet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BF%AD%E4%BB%A3%E5%99%A8-KeySet"><span class="toc-number">5.2.10.1.2.</span> <span class="toc-text">2.迭代器 KeySet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ForEach-EntrySet"><span class="toc-number">5.2.10.1.3.</span> <span class="toc-text">3.ForEach EntrySet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-ForEach-KeySet"><span class="toc-number">5.2.10.1.4.</span> <span class="toc-text">4.ForEach KeySet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-Lambda"><span class="toc-number">5.2.10.1.5.</span> <span class="toc-text">5.Lambda</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-Streams-API-%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.10.1.6.</span> <span class="toc-text">6.Streams API 单线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-Streams-API-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.10.1.7.</span> <span class="toc-text">7.Streams API 多线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.10.2.</span> <span class="toc-text">性能测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">5.2.10.3.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.2.10.4.</span> <span class="toc-text">字节码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">5.2.10.5.</span> <span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.10.6.</span> <span class="toc-text">安全性测试</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.10.6.1.</span> <span class="toc-text">1.迭代器方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-For-%E5%BE%AA%E7%8E%AF%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.10.6.2.</span> <span class="toc-text">2.For 循环方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Lambda-%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.10.6.3.</span> <span class="toc-text">3.Lambda 方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Stream-%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.10.6.4.</span> <span class="toc-text">4.Stream 方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.2.10.6.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.2.10.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashtable"><span class="toc-number">5.3.</span> <span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap"><span class="toc-number">5.4.</span> <span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">5.5.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashmap"><span class="toc-number">5.6.</span> <span class="toc-text">ConcurrentHashmap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashmap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.1.</span> <span class="toc-text">ConcurrentHashmap的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-%E5%88%86%E6%AE%B5%E9%94%81"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">1.7 分段锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-CAS-synchronized"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">1.8 CAS+synchronized</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.</span> <span class="toc-text">HashMap 和 Hashtable 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-HashSet-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.8.</span> <span class="toc-text">HashMap 和 HashSet 区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7"><span class="toc-number">6.</span> <span class="toc-text">集合工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparable-%E5%92%8C-Comparator"><span class="toc-number">6.1.</span> <span class="toc-text">Comparable 和 Comparator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">Collections 工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.1.</span> <span class="toc-text">排序操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.2.</span> <span class="toc-text">查找,替换操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">6.2.3.</span> <span class="toc-text">同步控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream"><span class="toc-number">6.3.</span> <span class="toc-text">Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E6%A6%82%E8%BF%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">Stream概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">6.3.2.</span> <span class="toc-text">Stream的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.3.</span> <span class="toc-text">Stream的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8%E7%9A%84%E5%91%98%E5%B7%A5%E7%B1%BB"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">案例使用的员工类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-%E5%8C%B9%E9%85%8D%EF%BC%88foreach-find-match%EF%BC%89"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">遍历&#x2F;匹配（foreach&#x2F;find&#x2F;match）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%9B%E9%80%89%EF%BC%88filter%EF%BC%89"><span class="toc-number">6.3.3.3.</span> <span class="toc-text">筛选（filter）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E5%90%88%EF%BC%88max-min-count"><span class="toc-number">6.3.3.4.</span> <span class="toc-text">聚合（max&#x2F;min&#x2F;count)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84-map-flatMap"><span class="toc-number">6.3.3.5.</span> <span class="toc-text">映射(map&#x2F;flatMap)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6-reduce"><span class="toc-number">6.3.3.6.</span> <span class="toc-text">归约([reduce]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E9%9B%86-collect"><span class="toc-number">6.3.3.7.</span> <span class="toc-text">收集(collect)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%92%E9%9B%86-toList-toSet-toMap"><span class="toc-number">6.3.3.7.1.</span> <span class="toc-text">归集(toList&#x2F;toSet&#x2F;toMap)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1-count-averaging"><span class="toc-number">6.3.3.7.2.</span> <span class="toc-text">统计(count&#x2F;averaging)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%BB%84-partitioningBy-groupingBy"><span class="toc-number">6.3.3.7.3.</span> <span class="toc-text">分组(partitioningBy&#x2F;groupingBy)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%90%88-joining"><span class="toc-number">6.3.3.7.4.</span> <span class="toc-text">接合(joining)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%92%E7%BA%A6-reducing"><span class="toc-number">6.3.3.7.5.</span> <span class="toc-text">归约(reducing)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F-sorted"><span class="toc-number">6.3.3.8.</span> <span class="toc-text">排序(sorted)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8F%96-%E7%BB%84%E5%90%88"><span class="toc-number">6.4.</span> <span class="toc-text">提取&#x2F;组合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">集合使用注意事项总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%88%A4%E7%A9%BA"><span class="toc-number">7.1.</span> <span class="toc-text">集合判空</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BD%AC-Map"><span class="toc-number">7.2.</span> <span class="toc-text">集合转 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86"><span class="toc-number">7.3.</span> <span class="toc-text">集合遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%8E%BB%E9%87%8D"><span class="toc-number">7.4.</span> <span class="toc-text">集合去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">7.5.</span> <span class="toc-text">集合转数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%BD%AC%E9%9B%86%E5%90%88"><span class="toc-number">7.6.</span> <span class="toc-text">数组转集合</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/30/%E8%8A%8B%E9%81%93%E6%BA%90%E7%A0%81-ruoyi-vue-pro/" title="芋道源码-ruoyi-vue-pro">芋道源码-ruoyi-vue-pro</a><time datetime="2023-01-29T16:54:35.000Z" title="发表于 2023-01-30 00:54:35">2023-01-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/13/%E5%B0%9A%E7%A1%85%E8%B0%B7-Spring-Security/" title="尚硅谷-Spring-Security">尚硅谷-Spring-Security</a><time datetime="2023-01-13T09:39:30.000Z" title="发表于 2023-01-13 17:39:30">2023-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/11/21/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-RabbitMQ/" title="黑马程序员-RabbitMQ">黑马程序员-RabbitMQ</a><time datetime="2022-11-21T02:52:22.000Z" title="发表于 2022-11-21 10:52:22">2022-11-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/11/17/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-Docker/" title="黑马程序员-Docker">黑马程序员-Docker</a><time datetime="2022-11-17T12:28:03.000Z" title="发表于 2022-11-17 20:28:03">2022-11-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/11/05/MyBatis-Plus-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88%E6%96%B0%EF%BC%89/" title="MyBatis-Plus-代码生成器（新）">MyBatis-Plus-代码生成器（新）</a><time datetime="2022-11-05T13:03:52.000Z" title="发表于 2022-11-05 21:03:52">2022-11-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/bg/iTab-7p3we9.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Wei Shao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>