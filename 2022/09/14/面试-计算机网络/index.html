<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>面试-计算机网络 | WeiBlog</title><meta name="author" content="Wei Shao"><meta name="copyright" content="Wei Shao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基础说下计算机网络体系结构计算机网络体系结构，一般有三种：OSI 七层模型、TCP&#x2F;IP 四层模型、五层结构。  简单说，OSI是一个理论上的网络通信模型，TCP&#x2F;IP是实际上的网络通信模型，五层结构就是为了介绍网络原理而折中的网络通信模型。 OSI 七层模型OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用">
<meta property="og:type" content="article">
<meta property="og:title" content="面试-计算机网络">
<meta property="og:url" content="https://weishao-996.github.io/2022/09/14/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="WeiBlog">
<meta property="og:description" content="基础说下计算机网络体系结构计算机网络体系结构，一般有三种：OSI 七层模型、TCP&#x2F;IP 四层模型、五层结构。  简单说，OSI是一个理论上的网络通信模型，TCP&#x2F;IP是实际上的网络通信模型，五层结构就是为了介绍网络原理而折中的网络通信模型。 OSI 七层模型OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://weishao-996.github.io/img/bg/WechatIMG48.png">
<meta property="article:published_time" content="2022-09-14T02:54:41.000Z">
<meta property="article:modified_time" content="2022-10-08T05:08:30.000Z">
<meta property="article:author" content="Wei Shao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://weishao-996.github.io/img/bg/WechatIMG48.png"><link rel="shortcut icon" href="/img/bg/%E6%89%8B%E7%BB%98%E7%81%AB%E7%AE%AD.png"><link rel="canonical" href="https://weishao-996.github.io/2022/09/14/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试-计算机网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-08 13:08:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/bg/WechatIMG48.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bg/WechatIMG88.png')"><nav id="nav"><span id="blog-info"><a href="/" title="WeiBlog"><span class="site-name">WeiBlog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试-计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-14T02:54:41.000Z" title="发表于 2022-09-14 10:54:41">2022-09-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-08T05:08:30.000Z" title="更新于 2022-10-08 13:08:30">2022-10-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试-计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="说下计算机网络体系结构"><a href="#说下计算机网络体系结构" class="headerlink" title="说下计算机网络体系结构"></a>说下计算机网络体系结构</h2><p>计算机网络体系结构，一般有三种：OSI 七层模型、TCP/IP 四层模型、五层结构。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914105946014.png" alt="image-20220914105946014"></p>
<p>简单说，OSI是一个理论上的网络通信模型，TCP/IP是实际上的网络通信模型，五层结构就是为了介绍网络原理而折中的网络通信模型。</p>
<h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。</p>
<ul>
<li>应用层：通过应用进程之间的交互来完成特定网络应用，应用层协议定义的是应用进程间通信和交互的规则，常见的协议有：HTTP FTP SMTP SNMP DNS.</li>
<li>表示层：数据的表示、安全、压缩。确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</li>
<li>会话层：建立、管理、终止会话，是用户应用程序和网络之间的接又。</li>
<li>运输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。</li>
<li>网络层：将网络地址翻译成对应的物理地址，实现不同网络之间的路径选择, 协议有ICMP IGMP IP 等.</li>
<li>数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。</li>
<li>物理层：建立、维护、断开物理连接。</li>
</ul>
<h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><ul>
<li>应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。</li>
<li>传输层: 对应 OSI 的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。</li>
<li>网际层：对应于 OSI 参考模型的网络层，主要解决主机到主机的通信问题。</li>
<li>网络接口层：与 OSI 参考模型的数据链路层、物理层对应。</li>
</ul>
<h3 id="五层体系结构"><a href="#五层体系结构" class="headerlink" title="五层体系结构"></a>五层体系结构</h3><ul>
<li>应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。</li>
<li>传输层：对应 OSI 参考模型的的传输层</li>
<li>网络层：对应 OSI 参考模型的的网络层</li>
<li>数据链路层：对应 OSI 参考模型的的数据链路层</li>
<li>物理层：对应 OSI 参考模型的的物理层。</li>
</ul>
<h2 id="说一下每一层对应的网络协议有哪些？"><a href="#说一下每一层对应的网络协议有哪些？" class="headerlink" title="说一下每一层对应的网络协议有哪些？"></a>说一下每一层对应的网络协议有哪些？</h2><p>一张表格总结常见网络协议：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914110343078.png" alt="image-20220914110343078"></p>
<h2 id="那么数据在各层之间是怎么传输的呢？"><a href="#那么数据在各层之间是怎么传输的呢？" class="headerlink" title="那么数据在各层之间是怎么传输的呢？"></a>那么数据在各层之间是怎么传输的呢？</h2><p>对于发送方而言，从上层到下层层层包装，对于接收方而言，从下层到上层，层层解开包装。</p>
<ul>
<li>发送方的应用进程向接收方的应用进程传送数据</li>
<li>AP先将数据交给本主机的应用层，应用层加上本层的控制信息H5就变成了下一层的数据单元</li>
<li>传输层收到这个数据单元后，加上本层的控制信息H4，再交给网络层，成为网络层的数据单元</li>
<li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）</li>
<li>最后的物理层，进行比特流的传输</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914110821509.png" alt="image-20220914110821509"></p>
<p>这个过程类似写信，写一封信，每到一层，就加一个信封，写一些地址的信息。到了目的地之后，又一层层解封，传向下一个目的地。</p>
<h1 id="网络综合"><a href="#网络综合" class="headerlink" title="网络综合"></a>网络综合</h1><h2 id="从浏览器地址栏输入-url-到显示主页的过程？"><a href="#从浏览器地址栏输入-url-到显示主页的过程？" class="headerlink" title="从浏览器地址栏输入 url 到显示主页的过程？"></a>从浏览器地址栏输入 url 到显示主页的过程？</h2><p>这道题，大概的过程比较简单，但是有很多点可以细挖：DNS解析、TCP三次握手、HTTP报文格式、TCP四次挥手等等。</p>
<ol>
<li>DNS 解析：将域名解析成对应的 IP 地址。</li>
<li>TCP连接：与服务器通过三次握手，建立 TCP 连接</li>
<li>向服务器发送 HTTP 请求</li>
<li>服务器处理请求，返回HTTp响应</li>
<li>浏览器解析并渲染页面</li>
<li>断开连接：TCP 四次挥手，连接结束<br>我们以输入<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 为例：</li>
</ol>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914111009624.png" alt="image-20220914111009624"></p>
<p>各个过程都使用了哪些协议？</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914111154827.png" alt="image-20220914111154827"></p>
<h2 id="说说-DNS-的解析过程？"><a href="#说说-DNS-的解析过程？" class="headerlink" title="说说 DNS 的解析过程？"></a>说说 DNS 的解析过程？</h2><p>DNS，英文全称是 domain name system ，域名解析系统，它的作用也很明确，就是域名和 IP<br>相互映射。<br>DNS 的解析过程如下图：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914111304899.png" alt="image-20220914111304899">假设你要查询 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a> 的 IP 地址:</p>
<ul>
<li>首先会查找浏览器的缓存,看看是否能找到<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 对应的IP地址，找到就直接返回；否则进行下一步。</li>
<li>将请求发往给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步；</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914112040289.png" alt="image-20220914112040289"></p>
<ul>
<li>本地DNS服务器向根域名服务器发送请求，<strong>根域名服务器</strong>返回负责com 的顶级域名服务器的IP地址的列表。</li>
<li>本地DNS服务器再向其中一个负责<strong>com 的顶级域名服务器</strong>发送一个请求，返回负责baidu.com 的权限域名服务器的IP地址列表。</li>
<li>本地DNS服务器再向其中一个<strong>权限域名服务器</strong>发送一个请求，返回<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 所对应的IP地址。</li>
</ul>
<h2 id="说说-WebSocket-与-Socket-的区别？"><a href="#说说-WebSocket-与-Socket-的区别？" class="headerlink" title="说说 WebSocket 与 Socket 的区别？"></a>说说 WebSocket 与 Socket 的区别？</h2><ul>
<li>Socket 其实就是等于 <strong>IP 地址 + 端又 + 协议</strong>。</li>
</ul>
<blockquote>
<p>具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便<br>开发者更好地进行网络编程。</p>
</blockquote>
<ul>
<li>WebSocket 是一个<strong>持久化</strong>的协议，它是伴随 H5 而出的协议，用来解决 http 不支持持久化连接的问题。</li>
<li>Socket 一个是网编编程的标准接口，而 WebSocket 则是应用层通信协议。</li>
</ul>
<h2 id="说一下你了解的端口及对应的服务？"><a href="#说一下你了解的端口及对应的服务？" class="headerlink" title="说一下你了解的端口及对应的服务？"></a>说一下你了解的端口及对应的服务？</h2><p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914112622852.png" alt="image-20220914112622852"></p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="说说-HTTP-常用的状态码及其含义？"><a href="#说说-HTTP-常用的状态码及其含义？" class="headerlink" title="说说 HTTP 常用的状态码及其含义？"></a>说说 HTTP 常用的状态码及其含义？</h2><ul>
<li><strong>1XX：信息性状态码</strong></li>
<li><strong>2XX：成功状态码</strong></li>
<li><strong>3XX：重定向状态码</strong></li>
<li><strong>4XX：客户端错误状态码</strong></li>
<li><strong>5XX：服务端错误状态码</strong></li>
</ul>
<p>几个常用的，面试之外，也应该记住：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914113033757.png" alt="image-20220914113033757"></p>
<h3 id="说一下-301-和-302-的区别？"><a href="#说一下-301-和-302-的区别？" class="headerlink" title="说一下 301 和 302 的区别？"></a>说一下 301 和 302 的区别？</h3><ul>
<li>301 ：永久性移动，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址。</li>
<li>302 ：临时性性移动，服务器从另外的地址响应资源，但是客户端还应该使用这个地址。</li>
</ul>
<h2 id="HTTP-有哪些请求方式？"><a href="#HTTP-有哪些请求方式？" class="headerlink" title="HTTP 有哪些请求方式？"></a>HTTP 有哪些请求方式？</h2><p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914114104380.png" alt="image-20220914114104380"></p>
<p>其中，<strong>POST、DELETE、PUT、GET</strong>的含义分别对应我们最熟悉的<strong>增、删、改、查</strong>。</p>
<h2 id="说一下-GET-和-POST-的区别？"><a href="#说一下-GET-和-POST-的区别？" class="headerlink" title="说一下 GET 和 POST 的区别？"></a>说一下 GET 和 POST 的区别？</h2><p>可以从以下几个方面来说明GET和POST的区别：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914114203771.png" alt="image-20220914114203771"></p>
<ol>
<li>从 HTTP 报文层面来看，GET 请求将信息放在 URL，POST 将请求信息放在请求体中。这一点使得 GET 请求携带的数据量有限，因为 URL 本身是有长度限制的，而 POST 请求的数据存放在报文体中，因此对大小没有限制。而且从形式上看，GET 请求把数据放URL 上不太安全，而 POST 请求把数据放在请求体里想比较而言安全些。</li>
<li>从数据库层面来看，GET 符合幂等性和安全性，而 POST 请求不符合。这个其实和GET/POST 请求的作用有关。按照 HTTP 的约定，GET 请求用于查看信息，不会改变服务器上的信息；而 POST 请求用来改变服务器上的信息。正因为 GET 请求只查看信息，不改变信息，对数据库的一次或多次操作获得的结果是一致的，认为它符合幂等性。安全性是指对数据库操作没有改变数据库中的数据。</li>
<li>从其他层面来看，GET 请求能够被缓存，GET 请求能够保存在浏览器的浏览记录里，GET 请求的 URL 能够保存为浏览器书签。这些都是 POST 请求所不具备的。缓存是 GET请求被广泛应用的根本，他能够被缓存也是因为它的幂等性和安全性，除了返回结果没有其他多余的动作，因此绝大部分的 GET 请求都被 CDN 缓存起来了，大大减少了 Web 服务器的负担。</li>
</ol>
<h2 id="GET-的长度限制是多少？"><a href="#GET-的长度限制是多少？" class="headerlink" title="GET 的长度限制是多少？"></a>GET 的长度限制是多少？</h2><p>HTTP中的GET方法是通过URL传递数据的，但是URL本身其实并没有对数据的长度进行限制，真正限制GET长度的是浏览器。<br>例如IE浏览器对URL的最大限制是 2000 多个字符，大概2kb左右，像Chrome、Firefox等浏览器支持的URL字符数更多，其中FireFox中URL的最大长度限制是 65536 个字符，Chrome则是8182 个字符。<br>这个长度限制也不是针对数据部分，而是针对整个URL。</p>
<h2 id="HTTP-请求的过程与原理？"><a href="#HTTP-请求的过程与原理？" class="headerlink" title="HTTP 请求的过程与原理？"></a>HTTP 请求的过程与原理？</h2><p>HTTP协议定义了浏览器怎么向服务器请求文档，以及服务器怎么把文档传给浏览器。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914115326440.png" alt="image-20220914115326440"></p>
<ul>
<li>每个服务器都有一个进程，它不断监听TCP的端口 80 ，以便发现是否有浏览器向它发出连接建立请求</li>
<li>监听到连接请求，就会建立TCP连接</li>
<li>浏览器向服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应</li>
<li>最后，释放TCP连接</li>
</ul>
<p>在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则，这些格式和规则就是超文本传输协议HTTP。<br>PS:这道题和上面浏览器输入网址发生了什么那道题大差不差。</p>
<h2 id="说一下HTTP的报文结构？"><a href="#说一下HTTP的报文结构？" class="headerlink" title="说一下HTTP的报文结构？"></a>说一下HTTP的报文结构？</h2><p>HTTP报文有两种，HTTP请求报文和HTTP响应报文：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914115634809.png" alt="image-20220914115634809"></p>
<p><strong>HTTP请求报文</strong><br>HTTP 请求报文的格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/<span class="number">1.1</span></span><br><span class="line">User-Agent: Mozilla/<span class="number">5.0</span> (Macintosh; Intel Mac OS X <span class="number">10_10_5</span>)</span><br><span class="line">Accept: *<span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。<br>请求行包含三个字段：</p>
<ul>
<li>方法字段：包括POST、GET等请方法。</li>
<li>URL 字段</li>
<li>HTTP 版本字段。</li>
</ul>
<p><strong>HTTP 响应报文</strong><br>HTTP 响应报文的格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTTP 响应报文的第一行叫做 <strong>状态行</strong> ，后面的行是 <strong>首部行</strong> ，最后是 <strong>实体主体</strong> 。</p>
<ul>
<li><p><strong>状态行</strong> 包含了三个字段：协议版本字段、状态码和相应的状态信息。</p>
</li>
<li><p><strong>实体部分</strong> 是报文的主要部分，它包含了所请求的对象。</p>
</li>
<li><p><strong>首部行</strong> 首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。</p>
<ul>
<li><p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p>
</li>
<li><p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p>
</li>
<li><p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p>
</li>
<li><p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。</p>
</li>
</ul>
</li>
</ul>
<h2 id="URI-和-URL-有什么区别"><a href="#URI-和-URL-有什么区别" class="headerlink" title="URI 和 URL 有什么区别?"></a>URI 和 URL 有什么区别?</h2><p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914130151408.png" alt="image-20220914130151408"></p>
<ul>
<li>URI，统一资源标识符(Uniform Resource Identifier， URI)，标识的是We b上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都是由一个URI进行标识的。</li>
<li>URL，统一资源定位符（Uniform Resource Location)，它是URI的一种子集，主要作用是提供资源的路径。</li>
</ul>
<p>它们的主要区别在于，URL除了提供了资源的标识，还提供了资源访问的方式。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人——人类住址协议://地球/中国/北京市/海淀区/xx职业技术学院/14号宿舍楼/525号寝/张三.男。</p>
<h2 id="说下-HTTP-1-0，1-1，2-0-的区别？"><a href="#说下-HTTP-1-0，1-1，2-0-的区别？" class="headerlink" title="说下 HTTP/1.0，1.1，2.0 的区别？"></a>说下 HTTP/1.0，1.1，2.0 的区别？</h2><p>关键需要记住 <strong>HTTP/1.0</strong> 默认是<strong>短连接</strong>，可以强制开启，<strong>HTTP/1.1</strong> 默认<strong>长连接</strong>，<strong>HTTP/2.0</strong> 采用<strong>多路复用</strong> 。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><ul>
<li>默认使用短连接，每次请求都需要建立一个 TCP 连接。它可以设置Connection:keep-alive 这个字段，强制开启长连接。</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><ul>
<li>引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用。</li>
<li>分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。</li>
<li>管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。</li>
</ul>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><ul>
<li>二进制协议，1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制。</li>
<li>完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。</li>
<li>报头压缩，HTTP 协议不带有状态，每次请求都必须附上所有信息。Http/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送。</li>
<li>服务端推送，允许服务器未经请求，主动向客户端发送资源。</li>
</ul>
<h2 id="HTTP-3了解吗？"><a href="#HTTP-3了解吗？" class="headerlink" title="HTTP/3了解吗？"></a>HTTP/3了解吗？</h2><p>HTTP/3主要有两大变化， <strong>传输层基于UDP</strong> 、使用 <strong>QUIC保证UDP可靠性</strong> 。<br>HTTP/2存在的一些问题，比如重传等等，都是由于TCP本身的特性导致的，所以HTTP/3在QUIC的基础上进行发展而来，QUIC（Quick UDP Connections）直译为<strong>快速UDP网络连接</strong>，底层使用UDP进行数据传输。<br>HTTP/3主要有这些特点：</p>
<ul>
<li>使用UDP作为传输层进行通信</li>
<li>在UDP的基础上QUIC协议保证了HTTP/3的安全性，在传输的过程中就完成了TLS加密握手</li>
<li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。</li>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。</li>
</ul>
<p>我们拿一张图看一下HTTP协议的变迁：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914134739072.png" alt="image-20220914134739072"></p>
<h2 id="HTTP-如何实现长连接？在什么时候会超时？"><a href="#HTTP-如何实现长连接？在什么时候会超时？" class="headerlink" title="HTTP 如何实现长连接？在什么时候会超时？"></a>HTTP 如何实现长连接？在什么时候会超时？</h2><h3 id="什么是-HTTP-的长连接？"><a href="#什么是-HTTP-的长连接？" class="headerlink" title="什么是 HTTP 的长连接？"></a>什么是 HTTP 的长连接？</h3><ol>
<li><p>HTTP 分为长连接和短连接，本质上说的是 TCP 的长短连接。TCP 连接是一个双向的通<br> 道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说<br> 法。</p>
</li>
<li><p>TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消<br> 耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的 JS/CSS。</p>
</li>
</ol>
<h3 id="如何设置长连接？"><a href="#如何设置长连接？" class="headerlink" title="如何设置长连接？"></a>如何设置长连接？</h3><p>  通过在头部（请求和响应头）设置 <strong>Connection</strong> 字段指定为<strong>keep-alive</strong>，HTTP/1.0 协议支<br>  持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。</p>
<h3 id="在什么时候会超时呢？"><a href="#在什么时候会超时呢？" class="headerlink" title="在什么时候会超时呢？"></a>在什么时候会超时呢？</h3><ul>
<li>HTTP 一般会有 httpd 守护进程，里面可以设置 <strong>keep-alive timeout</strong>，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</li>
<li>TCP 的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 tcp_keepalive_time，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 <strong>tcp_keepalive_intvl</strong> 再发一次，直到发送了 <strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp_keepalive_intvl = 15</span><br><span class="line">tcp_keepalive_probes = 5</span><br><span class="line">tcp_keepalive_time = 1800</span><br></pre></td></tr></table></figure>

<h2 id="说说HTTP-与-HTTPS-有哪些区别？"><a href="#说说HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="说说HTTP 与 HTTPS 有哪些区别？"></a>说说HTTP 与 HTTPS 有哪些区别？</h2><ol>
<li>HTTP 是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS 则解决 HTTP不安全的缺陷，在TCP 和 HTTP 网络层之间加入了 <strong>SSL/TLS</strong> 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 的端又号是 <strong>80</strong> ，HTTPS 的端又号是 <strong>443</strong> 。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请<strong>数字证书</strong>，来保证服务器的身份是可信的。</li>
</ol>
<h2 id="为什么要用HTTPS？解决了哪些问题？"><a href="#为什么要用HTTPS？解决了哪些问题？" class="headerlink" title="为什么要用HTTPS？解决了哪些问题？"></a>为什么要用HTTPS？解决了哪些问题？</h2><p>因为HTTP 是明文传输，存在安全上的风险：</p>
<ul>
<li><strong>窃听风险</strong> ，比如通信链路上可以获取通信内容，用户账号被盗。</li>
<li><strong>篡改风险</strong> ，比如强制植入垃圾广告，视觉污染。</li>
<li><strong>冒充风险</strong> ，比如冒充淘宝网站，用户金钱损失。</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914140946859.png" alt="image-20220914140946859"></p>
<p>所以引入了HTTPS，HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了这些风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示。</li>
<li><strong>身份证书</strong>：能证明淘宝是真淘宝。</li>
</ul>
<p>所以SSL/TLS 协议是能保证通信是安全的。</p>
<h2 id="HTTPS工作流程是怎样的？"><a href="#HTTPS工作流程是怎样的？" class="headerlink" title="HTTPS工作流程是怎样的？"></a>HTTPS工作流程是怎样的？</h2><p>这道题有几个要点： <strong>公私钥、数字证书、加密、对称加密、非对称加密</strong> 。<br>HTTPS 主要工作流程：</p>
<ol>
<li><p>客户端发起 HTTPS 请求，连接到服务端的 443 端口。</p>
</li>
<li><p>服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。</p>
</li>
<li><p>服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。</p>
</li>
<li><p>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。</p>
</li>
<li><p>客户端将公钥加密后的密钥发送到服务器。</p>
</li>
<li><p>服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。</p>
</li>
<li><p>服务器将加密后的密文返回到客户端。</p>
</li>
<li><p>客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</p>
</li>
</ol>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914141753002.png" alt="image-20220914141753002"></p>
<p>这里还画了一张更详尽的图：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914141816333.png" alt="image-20220914141816333"></p>
<h2 id="客户端怎么去校验证书的合法性？"><a href="#客户端怎么去校验证书的合法性？" class="headerlink" title="客户端怎么去校验证书的合法性？"></a>客户端怎么去校验证书的合法性？</h2><p>首先，服务端的证书从哪来的呢？</p>
<p>为了让服务端的公钥被大家信任，服务端的证书都是由 <strong>CA （Certificate Authority，证书认证机构）</strong>签名的，CA就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914141955788.png" alt="image-20220914141955788"></p>
<p>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate</li>
<li>Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
<p>假如在HTTPS的通信过程中，中间人篡改了证书原文，由于他没有CA机构的私钥，所以CA公钥解密的内容就不一致。</p>
<h2 id="如何理解-HTTP-协议是无状态的？"><a href="#如何理解-HTTP-协议是无状态的？" class="headerlink" title="如何理解 HTTP 协议是无状态的？"></a>如何理解 HTTP 协议是无状态的？</h2><p>这个无状态的的状态值的是什么？是客户端的状态，所以字面意思，就是HTTP协议中服务端不会保存客户端的任何信息。<br>比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。</p>
<p><strong>那有什么办法记录状态呢？</strong></p>
<p>主要有两个办法，Session和Cookie。</p>
<h2 id="说说Session-和-Cookie-有什么联系和区别"><a href="#说说Session-和-Cookie-有什么联系和区别" class="headerlink" title="说说Session 和 Cookie 有什么联系和区别?"></a>说说Session 和 Cookie 有什么联系和区别?</h2><p>先来看看什么是 Session 和 Cookie ：</p>
<ul>
<li><strong>Cookie</strong> <strong>是保存在客户端的一小块文本串的数据</strong>。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。<strong>服务端可以根据这个Cookie判断用户的身份和状态</strong>。</li>
<li><strong>Session</strong> <strong>指的就是服务器和客户端一次会话的过程</strong>。它是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找用户的状态。</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914145805140.png" alt="image-20220914145805140"></p>
<h3 id="Session-和-Cookie-到底有什么不同呢？"><a href="#Session-和-Cookie-到底有什么不同呢？" class="headerlink" title="Session 和 Cookie 到底有什么不同呢？"></a>Session 和 Cookie 到底有什么不同呢？</h3><ul>
<li>存储位置不一样，Cookie 保存在客户端，Session 保存在服务器端。</li>
<li>存储数据类型不一样，Cookie 只能保存ASCII，Session可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session一般有效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个Cookie保存的数据不能超过4K，Session可存储数据远高于 Cookie。</li>
</ul>
<h3 id="Session-和-Cookie有什么关联呢？"><a href="#Session-和-Cookie有什么关联呢？" class="headerlink" title="Session 和 Cookie有什么关联呢？"></a>Session 和 Cookie有什么关联呢？</h3><p>可以使用Cookie记录Session的标识。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914150505696.png" alt="image-20220914150505696"></p>
<p>用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。<br>当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<h3 id="分布式环境下Session怎么处理呢？"><a href="#分布式环境下Session怎么处理呢？" class="headerlink" title="分布式环境下Session怎么处理呢？"></a>分布式环境下Session怎么处理呢？</h3><p>分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的Session。</p>
<p>这时候怎么办呢？</p>
<p>可以使用Redis等分布式缓存来存储Session，在多台服务器之间共享。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914151332272.png" alt="image-20220914151332272"></p>
<h3 id="客户端无法使用Cookie怎么办？"><a href="#客户端无法使用Cookie怎么办？" class="headerlink" title="客户端无法使用Cookie怎么办？"></a>客户端无法使用Cookie怎么办？</h3><p>有可能客户端无法使用Cookie，比如浏览器禁用Cookie，或者客户端是安卓、IOS等等。</p>
<p>这时候怎么办？SessionID怎么存？怎么传给服务端呢？</p>
<p>首先是SessionID的存储，可以使用客户端的本地存储，比如浏览器的sessionStorage。</p>
<p>接下来怎么传呢？</p>
<ul>
<li>拼接到URL里：直接把SessionID作为URL的请求参数</li>
<li>放到请求头里：把SessionID放到请求的Header里，比较常用。</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="详细说一下-TCP-的三次握手机制"><a href="#详细说一下-TCP-的三次握手机制" class="headerlink" title="详细说一下 TCP 的三次握手机制"></a>详细说一下 TCP 的三次握手机制</h2><p>TCP提供面向连接的服务，在传送数据前必须建立连接，TCP连接是通过三次握手建立的。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914154622322.png" alt="image-20220914154622322"></p>
<p>三次握手的过程：</p>
<ul>
<li>最开始，客户端和服务端都处于CLOSE状态，服务端监听客户端的请求，进入<strong>LISTEN</strong>状态</li>
<li>客户端发送连接请求，第一次握手 (SYN=1, seq=x)，发送完毕后，客户端就进入<strong>SYN_SENT(同步已发送)</strong> 状态</li>
<li>服务端确认连接，第二次握手 (SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服<br>务器端就进入 <strong>SYN_RCV （同步已接受）</strong>状态。</li>
<li>客户端收到服务端的确认之后，再次向服务端确认，这就是第三次握手 (ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 <strong>ESTABLISHED （连接已建立）</strong>状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态。</li>
</ul>
<h2 id="TCP-握手为什么是三次，为什么不能是两次？不能是四次？"><a href="#TCP-握手为什么是三次，为什么不能是两次？不能是四次？" class="headerlink" title="TCP 握手为什么是三次，为什么不能是两次？不能是四次？"></a>TCP 握手为什么是三次，为什么不能是两次？不能是四次？</h2><p><strong>为什么不能是两次？</strong></p>
<ul>
<li><strong>为了防止服务器端开启一些无用的连接增加服务器开销</strong></li>
<li><strong>防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</strong></li>
</ul>
<p>由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了 <code>SYN=1</code> 的第一次握手。<br>如果服务器端就直接创建了这个连接并返回包含 <code>SYN</code>、<code>ACK </code>和 <code>Seq</code> 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。</p>
<p>如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，服务器端是不知道客户端有没有接收到服务器端返回的信息的。</p>
<p>服务端就认为这个连接是可用的，端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。这样一来，就会有很多无效的连接端口白白地开着，导致资源的浪费。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917175738756.png" alt="image-20220917175738756"></p>
<p>还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917175824100.png" alt="image-20220917175824100"></p>
<p>所以我们需要“第三次握手”来确认这个过程:</p>
<p>通过第三次握手的数据告诉服务端，客户端有没有收到服务器”<strong>第二次握手</strong>”时传过去的数据，以及这个连接的序号是不是有效的。若发送的这个数据是<strong>“收到且没有问题</strong>”的信息，接收后服务器就正常建立TCP连接，否则建立TCP连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。</p>
<p><strong>为什么不是四次?</strong></p>
<p>简单说，就是三次挥手已经足够创建可靠的连接，没有必要再多一次握手导致花费更多的时间建立连接。</p>
<h2 id="三次握手中每一次没收到报文会发生什么情况"><a href="#三次握手中每一次没收到报文会发生什么情况" class="headerlink" title="三次握手中每一次没收到报文会发生什么情况?"></a>三次握手中每一次没收到报文会发生什么情况?</h2><h3 id="第一次握手服务端未收到SYN报文"><a href="#第一次握手服务端未收到SYN报文" class="headerlink" title="第一次握手服务端未收到SYN报文"></a>第一次握手服务端未收到SYN报文</h3><p>服务端不会进行任何的动作，而客户端由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会重新发送<code>SYN</code>报文，如果仍然没有回应，会重复这个过程，直到发送次数超过<strong>最大重传次数限制</strong>，就会返回连接建立失败。</p>
<h3 id="第二次握手客户端未收到服务端响应的ACK报文"><a href="#第二次握手客户端未收到服务端响应的ACK报文" class="headerlink" title="第二次握手客户端未收到服务端响应的ACK报文"></a>第二次握手客户端未收到服务端响应的ACK报文</h3><p>客户端会继续重传，直到次数限制;而服务端此时会阻塞在<code>accept()</code>处，等待客户端发送ACK报文</p>
<h3 id="第三次握手服务端为收到客户端发送过来的ACK报文"><a href="#第三次握手服务端为收到客户端发送过来的ACK报文" class="headerlink" title="第三次握手服务端为收到客户端发送过来的ACK报文"></a>第三次握手服务端为收到客户端发送过来的ACK报文</h3><p>服务端同样会采用类似客户端的超时重传机制，如果重试次数超过限制，则<code>accept()</code>调用返回-1，服务端建立连接失败;而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的<code>accept()</code>系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送<code>RST</code>报文给客户端，消除客户端单方面建立连接的状态。</p>
<h2 id="第二次握手传回了ACK，为什么还要传回SYN"><a href="#第二次握手传回了ACK，为什么还要传回SYN" class="headerlink" title="第二次握手传回了ACK，为什么还要传回SYN?"></a>第二次握手传回了ACK，为什么还要传回SYN?</h2><ul>
<li>ACK是为了告诉客户端传来的数据已经接收无误。</li>
<li>而传回SYN是为了告诉客户端，服务端响应的确实是客户端发送的报文。</li>
</ul>
<h2 id="第3次握手可以携带数据吗"><a href="#第3次握手可以携带数据吗" class="headerlink" title="第3次握手可以携带数据吗?"></a>第3次握手可以携带数据吗?</h2><p>第3次握手是可以携带数据的。</p>
<p>此时客户端已经处于<code>ESTABLISHED</code>状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。<br>第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在<code>SYN</code>报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成CPU和内存的消耗。</p>
<h2 id="说说半连接队列和SYN-Flood攻击的关系"><a href="#说说半连接队列和SYN-Flood攻击的关系" class="headerlink" title="说说半连接队列和SYN Flood攻击的关系?"></a>说说半连接队列和SYN Flood攻击的关系?</h2><h3 id="什么是半连接队列"><a href="#什么是半连接队列" class="headerlink" title="什么是半连接队列?"></a>什么是半连接队列?</h3><p><code>TCP</code>进入三次握手前，服务端会从<code>CLOSED</code>状态变为<code>LISTEN</code>状态,同时在内部创建了两个队列;<strong>半连接队列(SYN队列）</strong>和**全连接队列(ACCEPT 队列)**。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917181313525.png" alt="image-20220917181313525"></p>
<p>顾名思义，半连接队列存放的是<strong>三次握手未完成</strong>的连接，全连接队列存放的是<strong>完成三次握手</strong>的连接。</p>
<ul>
<li><code>TCP</code>三次握手时，客户端发送<code>SYN</code>到服务端，服务端收到之后，便回复<code>ACK</code>和<code>SYN</code> ,状态由<code>LISTEN</code>变为<code>SYN_RCVD</code>，此时这个连接就被推入了<code>SYN队列</code>，即<strong>半连接队列</strong>。</li>
<li>当客户端回复<code>ACK</code>,服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前,它被推入<code>ACCEPT队列</code>，即<strong>全连接队列</strong>。</li>
</ul>
<p>​    </p>
<h3 id="什么是SYN-Flood"><a href="#什么是SYN-Flood" class="headerlink" title="什么是SYN Flood ?"></a>什么是SYN Flood ?</h3><p><code>SYN Flood</code>是一种典型的<code>DDos攻击</code>，它在短时间内，伪造**==不存在的IP地址==**,向服务器发送大量<code>SYN报文</code>。当服务器回复<code>SYN+ACK</code>报文后，不会收到<code>ACK回应报文</code>，那么<code>SYN队列</code>里的连接旧不会出对队,久而久之就会占满服务端的<code>SYN 接收队列(半连接队列)</code>，使得服务器不能为正常用户服务。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917185644793.png" alt="image-20220917185644793"></p>
<h3 id="那有什么应对方案呢"><a href="#那有什么应对方案呢" class="headerlink" title="那有什么应对方案呢?"></a>那有什么应对方案呢?</h3><p><strong>主要有<code>syn cookie</code>和 <code>SYN Proxy</code> 防火墙等。</strong></p>
<p><code>syn cookie</code> :在收到<code>SYN包</code>后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个<code>cookie</code>值作为自己的<code>SYNACK包</code>的序列号，回复<code>SYN+ACK</code>后，服务器并不立即分配资源进行处理，等收到发送方的<code>ACK包</code>后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。<code>SYN Proxy</code>防火墙︰服务器防火墙会对收到的每一个<code>SYN报文</code>进行代理和回应，并保持半连接。等发送方将ACK包返回后，再重新构造SYN包发到服务器，建立真正的TCP连接。</p>
<h2 id="说说TCP四次挥手的过程"><a href="#说说TCP四次挥手的过程" class="headerlink" title="说说TCP四次挥手的过程?"></a>说说TCP四次挥手的过程?</h2><p>PS:问完三次握手，常常也会顺道问问四次挥手，所以也是必须掌握知识点。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917190254848.png" alt="image-20220917190254848"></p>
<p>TCP四次挥手过程:</p>
<ul>
<li>数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起</li>
<li>客户端发送释放连接报文，第一次挥手<code>(FIN=1，seq=u)</code>，发送完毕后，客户端进入<code>FIN_WAIT_1</code> 状态。</li>
<li>服务端发送确认报文，第二次挥手<code>(ACK=1,ack=u+1,seq =v)</code>，发送完毕后，服务器端进入<code>CLOSE_WAIT</code>状态，客户端接收到这个确认包之后，进入<code>FIN_WAIT_2</code>状态。</li>
<li>服务端发送释放连接报文，第三次挥手<code>(FIN=1，ACK1,seq=w,ack=u+1)</code>，发送完毕后，服务器端进入<code>LAST_ACK</code>状态，等待来自客户端的最后一个<code>ACK</code>。</li>
<li>客户端发送确认报文，第四次挥手<code>(ACK=1，seq=u+1 ,ack=w+1)</code>，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入<code>TIME_WAIT</code>状态，等待了某个固定时间(两个最大段生命周期，<code>2MSL</code>，<code>2 Maximum Segment Lifetime</code>）之后﹐没有收到服务器端的<code>ACK</code>,认为服务器端已经正常关闭连接，于是自己也关闭连接，进入<code>CLOSED</code>状态。服务器端接收到这个确认包之后，关闭连接，进入<code>CLOSED</code>状态。</li>
</ul>
<h2 id="TCP挥手为什么需要四次呢"><a href="#TCP挥手为什么需要四次呢" class="headerlink" title="TCP挥手为什么需要四次呢?"></a>TCP挥手为什么需要四次呢?</h2><p>再来回顾下四次挥手双方发<code>FIN包</code>的过程，就能理解为什么需要四次了。</p>
<ul>
<li>关闭连接时，客户端向服务端发送<code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li>
<li>服务端收到客户端的<code>FIN报文</code>时，先回一个<code>ACK应答报文</code>，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN报文</code>给客户端来表示同意现在关闭连接。</li>
</ul>
<p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的<code>ACK</code>和<code>FIN</code>一般都会分开发送，从而比三次握手导致多了一次。</p>
<h2 id="TCP四次挥手过程中，为什么需要等待2MSL-才进入CLOSED关闭状态"><a href="#TCP四次挥手过程中，为什么需要等待2MSL-才进入CLOSED关闭状态" class="headerlink" title="TCP四次挥手过程中，为什么需要等待2MSL,才进入CLOSED关闭状态?"></a>TCP四次挥手过程中，为什么需要等待2MSL,才进入CLOSED关闭状态?</h2><h3 id="为什么需要等待"><a href="#为什么需要等待" class="headerlink" title="为什么需要等待?"></a>为什么需要等待?</h3><p><strong>1.为了保证客户端发送的最后一个ACK报文段能够到达服务端</strong>。这个<code>ACK报文段</code>有可能丢失，因而使处在<code>LAST-ACK状态</code>的服务端就收不到对已发送的<code>FIN + ACK 报文段</code>的确认。服务端会超时重传这个<code>FIN+ACK报文段</code>，而客户端就能在<code>2MSL</code>时间内（超时＋1MSL传输）收到这个重传的<code>FIN+ACK报文段</code>。接着客户端重传一次确认，重新启动<code>2MSL</code>计时器。最后，客户端和服务器都正常进入到<code>CLOSED</code>状态。</p>
<p><strong>2.防止已失效的连接请求报文段出现在本连接中</strong>。客户端在发送完最后一个<code>ACK报文段</code>后，再经过时间<code>2MSL</code>，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>
<h3 id="为什么等待的时间是2MSL"><a href="#为什么等待的时间是2MSL" class="headerlink" title="为什么等待的时间是2MSL?"></a>为什么等待的时间是2MSL?</h3><p><code>MSL</code>是 <code>Maximum Segment Lifetime</code>，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p>
<p><code>TIME_WAIT</code>等待2倍的<code>MSL</code>，比较合理的解释是︰网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后口会向对方发送响应，所以一来一回需要等待2倍的时间。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917200851731.png" alt="image-20220917200851731"></p>
<p>比如如果被动关闭方没有收到断开连接的最后的<code>ACK报文</code>，就会触发超时重发<code>Fin报文</code>，另一方接收到<code>FIN</code>后，会重发<code>ACK</code>给被动关闭方，一来一去正好2个<code>MSL</code>。</p>
<h2 id="保活计时器有什么用"><a href="#保活计时器有什么用" class="headerlink" title="保活计时器有什么用?"></a>保活计时器有什么用?</h2><p>除时间等待计时器外，<code>TCP</code>还有一个保活计时器<code>(keepalive timer)</code>。</p>
<p>设想这样的场景:客户已主动与服务器建立了<code>TCP</code> 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则<code>每隔75秒钟</code>发送一次。若连续发送<code>10个探测报文段</code>后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<h2 id="CLOSE-WAIT和TIME-WAIT的状态和意义"><a href="#CLOSE-WAIT和TIME-WAIT的状态和意义" class="headerlink" title="CLOSE-WAIT和TIME-WAIT的状态和意义?"></a>CLOSE-WAIT和TIME-WAIT的状态和意义?</h2><h3 id="CLOSE-WAIT状态有什么意义"><a href="#CLOSE-WAIT状态有什么意义" class="headerlink" title="CLOSE-WAIT状态有什么意义?"></a>CLOSE-WAIT状态有什么意义?</h3><p>服务端收到客户端关闭连接的请求并确认之后，就会进入<code>CLOSE-WAIT</code>状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而<code>CLOSE-WAIT</code>状态就是为了保证服务端在关闭连接之前将待发送的数据处理完。</p>
<h3 id="TIME-WAIT有什么意义"><a href="#TIME-WAIT有什么意义" class="headerlink" title="TIME-WAIT有什么意义?"></a>TIME-WAIT有什么意义?</h3><p><code>TIME-WAIT</code>状态发生在第四次挥手，当客户端向服务端发送<code>ACK确认报文</code>后进入<code>TIME-WAIT</code>状态。</p>
<p>它存在的意义主要是两个：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917201451466.png" alt="image-20220917201451466"></p>
<ul>
<li><strong>防止旧连接的数据包</strong></li>
</ul>
<p>如果客户端收到服务端的<code>FIN报文</code>之后立即关闭连接，但是此时服务端对应的端口并没有关闭，如果客户端在相同端口建立新的连接，可能会导致新连接收到旧连接残留的数据包，导致不可预料的异常发生。</p>
<ul>
<li><strong>保证连接正确关闭</strong></li>
</ul>
<p>假设客户端最后一次发送的<code>ACK包</code>在传输的时候丢失了，由于<code>TCP</code>协议的超时重传机制，服务端将重发<code>FIN</code>报文，如果客户端没有维持<code>TIME-WAIT</code>状态而直接关闭的话，当收到服务端重新发送的FIN包时，客户端就会使用<code>RST包</code>来响应服务端，导致服务端以为有错误发生，然而实际关闭连接过程是正常的。</p>
<h2 id="TIME-WAIT状态过多会导致什么问题-怎么解决"><a href="#TIME-WAIT状态过多会导致什么问题-怎么解决" class="headerlink" title="TIME_WAIT状态过多会导致什么问题?怎么解决?"></a>TIME_WAIT状态过多会导致什么问题?怎么解决?</h2><h3 id="TIME-WAIT状态过多会导致什么问题"><a href="#TIME-WAIT状态过多会导致什么问题" class="headerlink" title="TIME_WAIT状态过多会导致什么问题?"></a>TIME_WAIT状态过多会导致什么问题?</h3><p>如果服务器有处于<code>TIME-WAIT</code>状态的<code>TCP</code>，则说明是由服务器方主动发起的断开请求。<br>过多的<code>TIME-WAIT</code>状态主要的危害有两种:</p>
<ul>
<li>第一是内存资源占用;</li>
<li>第二是对端口资源的占用，一个TCP连接至少消耗一个本地端口;</li>
</ul>
<h3 id="怎么解决TIME-WAIT状态过多"><a href="#怎么解决TIME-WAIT状态过多" class="headerlink" title="怎么解决TIME_WAIT状态过多?"></a>怎么解决TIME_WAIT状态过多?</h3><ul>
<li>服务器可以设置<code>SO_REUSEADDR</code>套接字来通知内核，如果端口被占用，但是<code>TCP</code>连接位于<code>TIME_WAIT</code>状态时可以重用端口。</li>
<li>还可以使用长连接的方式来减少<code>TCP</code>的连接和断开，在长连接的业务里往往不需要考虑<code>TIME_WAIT</code>状态。</li>
</ul>
<h2 id="说说TCP报文首部的格式"><a href="#说说TCP报文首部的格式" class="headerlink" title="说说TCP报文首部的格式?"></a>说说TCP报文首部的格式?</h2><p>看一下TCP报文首部的格式:</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917204411106.png" alt="image-20220917204411106"></p>
<ul>
<li><strong>16位端口号</strong>︰源端口号，主机该报文段是来自哪里;目标端口号，要传给哪个上层协议或应用程序</li>
<li><strong>32位序号</strong>∶一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。</li>
<li><strong>32位确认号</strong>︰用作对另一方发送的tcp报文段的响应。其值是收到的TCP报文段的序号值加1。</li>
<li><strong>4位首部长度</strong>︰表示 tcp头部有多少个32bit字(4字节)。因为4位最大能标识15，所以TCP头部最长是60字节。</li>
<li><strong>6位标志位</strong>︰URG(紧急指针是否有效)，ACk(表示确认号是否有效)，PST(缓冲区尚未填满)，RST(表示要求对方重新建立连接)，SYN(建立连接消息标志接)，FIN(表示告知对方本端要关闭连接了)</li>
<li><strong>16位窗口大小</strong>︰是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</li>
<li><strong>16位校验和</strong>︰由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。</li>
<li><strong>16位紧急指针</strong>:一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。</li>
</ul>
<h2 id="TCP是如何保证可靠性的"><a href="#TCP是如何保证可靠性的" class="headerlink" title="TCP是如何保证可靠性的?"></a>TCP是如何保证可靠性的?</h2><p>TCP主要提供了<strong>检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制</strong>等方法实现了可靠性传输。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917204856339.png" alt="image-20220917204856339"></p>
<p>1．<strong>连接管理</strong>:<code>TCP</code>使用三次握手和四次挥手保证可靠地建立连接和释放连接，这里就不用多说了。<br>2．<strong>校验和</strong>:<code>TCP</code>将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果接收端的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917205011615.png" alt="image-20220917205011615"></p>
<p>3．<strong>序列号/确认应答</strong>:<code>TCP</code>给发送的每一个包进行编号，接收方会对收到的包进行应答，发送方就会知道接收方是否收到对应的包，如果发现没有收到，就会重发，这样就能保证数据的完整性。就像老师上课，会问一句，这一章听懂了吗?没听懂再讲一遍。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917205130755.png" alt="image-20220917205130755"></p>
<p>4．<strong>流量控制</strong>:<code>TCP</code>连接的每一方都有固定大小的缓冲空间，<code>TCP</code>的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。<code>TCP</code>使用的流量控制协议是可变大小的<strong>滑动窗口协议</strong>。**(TCP利用滑动窗口实现流量控制)**</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917205311385.png" alt="image-20220917205311385"></p>
<p>5．<strong>最大消息长度</strong>∶在建立<code>TCP连接</code>的时候，双方约定一个最大的长度<code>(MSS)</code>作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917205422167.png" alt="image-20220917205422167"></p>
<p>6、<strong>超时重传</strong>:超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917205524690.png" alt="image-20220917205524690"></p>
<p>7．<strong>拥塞控制</strong>:如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此<code>TCP</code>引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220917205727095.png" alt="image-20220917205727095"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://weishao-996.github.io">Wei Shao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://weishao-996.github.io/2022/09/14/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">https://weishao-996.github.io/2022/09/14/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://weishao-996.github.io" target="_blank">WeiBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/bg/WechatIMG48.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/08/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-Redis/" title="黑马程序员-Redis"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">黑马程序员-Redis</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/12/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/" title="面试-Java容器"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试-Java容器</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/bg/WechatIMG48.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wei Shao</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/weishao-996"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/weishao-996" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2427340869@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">写什么代码，一拳把地球打爆！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">说下计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">OSI 七层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">TCP&#x2F;IP 四层模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">五层体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%AF%8F%E4%B8%80%E5%B1%82%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">说一下每一层对应的网络协议有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%90%84%E5%B1%82%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E8%BE%93%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">那么数据在各层之间是怎么传输的呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BB%BC%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">网络综合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5-url-%E5%88%B0%E6%98%BE%E7%A4%BA%E4%B8%BB%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">从浏览器地址栏输入 url 到显示主页的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-DNS-%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">说说 DNS 的解析过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-WebSocket-%E4%B8%8E-Socket-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">说说 WebSocket 与 Socket 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">说一下你了解的端口及对应的服务？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP"><span class="toc-number">3.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-HTTP-%E5%B8%B8%E7%94%A8%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">说说 HTTP 常用的状态码及其含义？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-301-%E5%92%8C-302-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">说一下 301 和 302 的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">HTTP 有哪些请求方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-GET-%E5%92%8C-POST-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">说一下 GET 和 POST 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">GET 的长度限制是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">HTTP 请求的过程与原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8BHTTP%E7%9A%84%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">说一下HTTP的报文结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URI-%E5%92%8C-URL-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.</span> <span class="toc-text">URI 和 URL 有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B-HTTP-1-0%EF%BC%8C1-1%EF%BC%8C2-0-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">说下 HTTP&#x2F;1.0，1.1，2.0 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-0"><span class="toc-number">3.8.1.</span> <span class="toc-text">HTTP&#x2F;1.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1"><span class="toc-number">3.8.2.</span> <span class="toc-text">HTTP&#x2F;1.1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-0"><span class="toc-number">3.8.3.</span> <span class="toc-text">HTTP&#x2F;2.0</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-3%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">HTTP&#x2F;3了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%9F%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%B6%85%E6%97%B6%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">HTTP 如何实现长连接？在什么时候会超时？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-HTTP-%E7%9A%84%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">3.10.1.</span> <span class="toc-text">什么是 HTTP 的长连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E9%95%BF%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">3.10.2.</span> <span class="toc-text">如何设置长连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%B6%85%E6%97%B6%E5%91%A2%EF%BC%9F"><span class="toc-number">3.10.3.</span> <span class="toc-text">在什么时候会超时呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4HTTP-%E4%B8%8E-HTTPS-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.11.</span> <span class="toc-text">说说HTTP 与 HTTPS 有哪些区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8HTTPS%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.12.</span> <span class="toc-text">为什么要用HTTPS？解决了哪些问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">HTTPS工作流程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%80%8E%E4%B9%88%E5%8E%BB%E6%A0%A1%E9%AA%8C%E8%AF%81%E4%B9%A6%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">客户端怎么去校验证书的合法性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-HTTP-%E5%8D%8F%E8%AE%AE%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%EF%BC%9F"><span class="toc-number">3.15.</span> <span class="toc-text">如何理解 HTTP 协议是无状态的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4Session-%E5%92%8C-Cookie-%E6%9C%89%E4%BB%80%E4%B9%88%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">3.16.</span> <span class="toc-text">说说Session 和 Cookie 有什么联系和区别?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Session-%E5%92%8C-Cookie-%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">3.16.1.</span> <span class="toc-text">Session 和 Cookie 到底有什么不同呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Session-%E5%92%8C-Cookie%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E8%81%94%E5%91%A2%EF%BC%9F"><span class="toc-number">3.16.2.</span> <span class="toc-text">Session 和 Cookie有什么关联呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%8E%AF%E5%A2%83%E4%B8%8BSession%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F"><span class="toc-number">3.16.3.</span> <span class="toc-text">分布式环境下Session怎么处理呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8Cookie%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">3.16.4.</span> <span class="toc-text">客户端无法使用Cookie怎么办？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP"><span class="toc-number">4.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B-TCP-%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">详细说一下 TCP 的三次握手机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F%E4%B8%8D%E8%83%BD%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">TCP 握手为什么是三次，为什么不能是两次？不能是四次？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%AD%E6%AF%8F%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%94%B6%E5%88%B0%E6%8A%A5%E6%96%87%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5"><span class="toc-number">4.3.</span> <span class="toc-text">三次握手中每一次没收到报文会发生什么情况?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%AA%E6%94%B6%E5%88%B0SYN%E6%8A%A5%E6%96%87"><span class="toc-number">4.3.1.</span> <span class="toc-text">第一次握手服务端未收到SYN报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%AA%E6%94%B6%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%93%8D%E5%BA%94%E7%9A%84ACK%E6%8A%A5%E6%96%87"><span class="toc-number">4.3.2.</span> <span class="toc-text">第二次握手客户端未收到服务端响应的ACK报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%BA%E6%94%B6%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E8%BF%87%E6%9D%A5%E7%9A%84ACK%E6%8A%A5%E6%96%87"><span class="toc-number">4.3.3.</span> <span class="toc-text">第三次握手服务端为收到客户端发送过来的ACK报文</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9ESYN"><span class="toc-number">4.4.</span> <span class="toc-text">第二次握手传回了ACK，为什么还要传回SYN?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8F%AF%E4%BB%A5%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%90%97"><span class="toc-number">4.5.</span> <span class="toc-text">第3次握手可以携带数据吗?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8CSYN-Flood%E6%94%BB%E5%87%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.6.</span> <span class="toc-text">说说半连接队列和SYN Flood攻击的关系?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">4.6.1.</span> <span class="toc-text">什么是半连接队列?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSYN-Flood"><span class="toc-number">4.6.2.</span> <span class="toc-text">什么是SYN Flood ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88%E5%91%A2"><span class="toc-number">4.6.3.</span> <span class="toc-text">那有什么应对方案呢?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.7.</span> <span class="toc-text">说说TCP四次挥手的过程?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8C%A5%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E5%91%A2"><span class="toc-number">4.8.</span> <span class="toc-text">TCP挥手为什么需要四次呢?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%852MSL-%E6%89%8D%E8%BF%9B%E5%85%A5CLOSED%E5%85%B3%E9%97%AD%E7%8A%B6%E6%80%81"><span class="toc-number">4.9.</span> <span class="toc-text">TCP四次挥手过程中，为什么需要等待2MSL,才进入CLOSED关闭状态?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85"><span class="toc-number">4.9.1.</span> <span class="toc-text">为什么需要等待?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AD%89%E5%BE%85%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF2MSL"><span class="toc-number">4.9.2.</span> <span class="toc-text">为什么等待的时间是2MSL?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%B4%BB%E8%AE%A1%E6%97%B6%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">4.10.</span> <span class="toc-text">保活计时器有什么用?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CLOSE-WAIT%E5%92%8CTIME-WAIT%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E6%84%8F%E4%B9%89"><span class="toc-number">4.11.</span> <span class="toc-text">CLOSE-WAIT和TIME-WAIT的状态和意义?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CLOSE-WAIT%E7%8A%B6%E6%80%81%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89"><span class="toc-number">4.11.1.</span> <span class="toc-text">CLOSE-WAIT状态有什么意义?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT%E6%9C%89%E4%BB%80%E4%B9%88%E6%84%8F%E4%B9%89"><span class="toc-number">4.11.2.</span> <span class="toc-text">TIME-WAIT有什么意义?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIME-WAIT%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">4.12.</span> <span class="toc-text">TIME_WAIT状态过多会导致什么问题?怎么解决?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">4.12.1.</span> <span class="toc-text">TIME_WAIT状态过多会导致什么问题?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3TIME-WAIT%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A"><span class="toc-number">4.12.2.</span> <span class="toc-text">怎么解决TIME_WAIT状态过多?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4TCP%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.13.</span> <span class="toc-text">说说TCP报文首部的格式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84"><span class="toc-number">4.14.</span> <span class="toc-text">TCP是如何保证可靠性的?</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/26/CentOS7%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85PostgreSQL12/" title="CentOS7离线安装PostgreSQL12">CentOS7离线安装PostgreSQL12</a><time datetime="2023-06-26T03:20:12.000Z" title="发表于 2023-06-26 11:20:12">2023-06-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/26/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-jQuery/" title="/img/黑马程序员-jQuery">/img/黑马程序员-jQuery</a><time datetime="2023-06-25T16:00:37.000Z" title="发表于 2023-06-26 00:00:37">2023-06-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/06/16/%E5%90%89%E4%BB%96%E8%B0%B1-%E6%81%B6%E9%AD%94%E4%B9%8B%E5%AD%90/" title="吉他谱-恶魔之子">吉他谱-恶魔之子</a><time datetime="2023-06-16T06:24:13.000Z" title="发表于 2023-06-16 14:24:13">2023-06-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/22/%E4%B8%89%E6%9B%B4%E8%8D%89%E5%A0%82-SpringMVC/" title="三更草堂-SpringMVC">三更草堂-SpringMVC</a><time datetime="2023-05-22T07:24:57.000Z" title="发表于 2023-05-22 15:24:57">2023-05-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/14/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="黑马程序员-设计模式">黑马程序员-设计模式</a><time datetime="2023-05-14T09:34:58.000Z" title="发表于 2023-05-14 17:34:58">2023-05-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/bg/WechatIMG88.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Wei Shao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>