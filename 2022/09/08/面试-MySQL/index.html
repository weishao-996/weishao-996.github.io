

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/WeiShao-996.github.io/img/fluid.png">
  <link rel="icon" href="/WeiShao-996.github.io/img/bg/%E5%A4%B4%E5%83%8F.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wei Shao">
  <meta name="keywords" content="">
  
    <meta name="description" content="基础什么是内连接、外连接、交叉连接、笛卡尔积呢 内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。 外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。 交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么A和B">
<meta property="og:type" content="article">
<meta property="og:title" content="面试-Mysql">
<meta property="og:url" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL/index.html">
<meta property="og:site_name" content="WeiBlog">
<meta property="og:description" content="基础什么是内连接、外连接、交叉连接、笛卡尔积呢 内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。 外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。 交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么A和B">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908105510788.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908110113813.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908110707043.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908111247064.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908112356710.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908113932735.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908114246845.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908160140480.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908172148275.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908172213800.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908174526568.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/E2S3AbqgaMevqcRf65-GykDq98ATjfCSA4IUeqk_7ME.pngtoken=W.LuJhepAXj28rmGMNzUwb-qHCaAjyOTpGOs7ceh3hGLgsV77WbxbKZOsY-xRYhbs">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908215650562.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908180104830.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908180909891.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181309250.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181359838.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181455376.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181543540.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181632240.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908182238317.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908182729899.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908182834045.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213313383.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213421869.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213517492.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213744369.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213841944.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213916706.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214058360.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214137165.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214216674.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214310160.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214404416.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214432260.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908220733335.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908221555005.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220909144014581.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/v2-9554bb5793a4296b773f516bf6f7e846_1440w.jpg">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910140953658.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910141026496.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910145551358.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910145623148.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910165413911.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910172522706.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910164140079.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910150438065.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910151114591.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910202911377.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910203254480.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910203424203.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910203812088.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910205005074.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910205110920.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910205630795.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL/%E9%9D%A2%E8%AF%95-MySQL/image-20220910214409739.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910214828711.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910214941003.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910215510444.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220910222457105.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911123822324.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911152256595.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911152812313.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911153038317.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911154336548.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911175944047.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911180508766.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911180815226.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911180839960.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191234515.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191339478.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191424281.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191456083.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191614690.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191648058.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191829890.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911192407624.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911192724348.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911192812721.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911192833689.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193540427.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193723009.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193756104.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193850811.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193905500.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911194012918.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911194036373.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911194218075.png">
<meta property="og:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220911194425916.png">
<meta property="article:published_time" content="2022-09-08T02:38:24.000Z">
<meta property="article:modified_time" content="2022-09-28T12:06:39.440Z">
<meta property="article:author" content="Wei Shao">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://weishao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL//%E9%9D%A2%E8%AF%95-MySQL/image-20220908105510788.png">
  
  
  
  <title>面试-Mysql - WeiBlog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/WeiShao-996.github.io/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/WeiShao-996.github.io/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/WeiShao-996.github.io/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"weishao-996.github.io","root":"/WeiShao-996.github.io/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"Java"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/WeiShao-996.github.io/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/WeiShao-996.github.io/js/utils.js" ></script>
  <script  src="/WeiShao-996.github.io/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/WeiShao-996.github.io/">
      <strong>威少のBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/WeiShao-996.github.io/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/WeiShao-996.github.io/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/WeiShao-996.github.io/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/WeiShao-996.github.io/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/WeiShao-996.github.io/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/WeiShao-996.github.io/img/bg/iTab-6ozkzl.jfif') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试-Mysql"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-08 10:38" pubdate>
          2022年9月8日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试-Mysql</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h1><h2 id="什么是内连接、外连接、交叉连接、笛卡尔积呢"><a href="#什么是内连接、外连接、交叉连接、笛卡尔积呢" class="headerlink" title="什么是内连接、外连接、交叉连接、笛卡尔积呢"></a>什么是内连接、外连接、交叉连接、笛卡尔积呢</h2><ul>
<li><strong>内连接（inner join）</strong>：取得两张表中满足存在连接匹配关系的记录。</li>
<li><strong>外连接（outer join）</strong>：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。</li>
<li><strong>交叉连接（cross join）</strong>：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么A和B交叉连接的结果就有m*n行。</li>
<li><strong>笛卡尔积</strong>：是数学中的一个概念，例如集合A={a,b}，集合B={1,2,3}，那么A✖B={&lt;a,o&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;,}。</li>
</ul>
<h2 id="那MySQL-的内连接、左连接、右连接有有什么区别？"><a href="#那MySQL-的内连接、左连接、右连接有有什么区别？" class="headerlink" title="那MySQL 的内连接、左连接、右连接有有什么区别？"></a>那MySQL 的内连接、左连接、右连接有有什么区别？</h2><p>MySQL的连接主要分为内连接和外连接，外连接常用的有左连接、右连接。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908105510788.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908105510788"></p>
<ul>
<li><code>inner join</code> 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li>
<li><code>left join</code> 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li>
<li><code>right join</code> 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li>
</ul>
<h2 id="说一下数据库的三大范式？"><a href="#说一下数据库的三大范式？" class="headerlink" title="说一下数据库的三大范式？"></a>说一下数据库的三大范式？</h2><ul>
<li><strong>第一范式</strong>：数据表中的每一列（每个字段）都不可以再拆分。例如用户表，用户地址还可以拆分成国家、省份、市，这样才是符合第一范式的。</li>
<li><strong>第二范式</strong>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品ID和订单ID作为联合主键，才满足第二范式。</li>
<li><strong>第三范式</strong>：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。例如订单表，就不能存储用户信息（姓名、地址）。</li>
</ul>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908110113813.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908110113813"></p>
<p>三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。</p>
<h2 id="varchar与char的区别？"><a href="#varchar与char的区别？" class="headerlink" title="varchar与char的区别？"></a>varchar与char的区别？</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908110707043.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908110707043"></p>
<p><strong>char</strong> ：</p>
<ul>
<li><code>char</code>表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于<code>char</code>的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比<code>varchar</code>快很多，甚至能快<code>50%</code>，但正因为其长度固定，</li>
<li>所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于<code>char</code>来说，最多能存放的字符个数为 <code>255 </code>，和编码无关</li>
</ul>
<p><strong>varchar</strong> ：</p>
<ul>
<li><code>varchar</code>表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li><code>varchar</code>在存取方面与<code>char</code>相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于<code>varchar</code>来说，最多能存放的字符个数为 <code>65532</code></li>
</ul>
<p>日常的设计，对于长度相对固定的字符串，可以使用<code>char</code>，对于长度不确定的，使用<code>varchar</code>更合适一些。</p>
<h2 id="blob和text有什么区别？"><a href="#blob和text有什么区别？" class="headerlink" title="blob和text有什么区别？"></a>blob和text有什么区别？</h2><ul>
<li>blob用于存储二进制数据，而text用于存储大字符串。</li>
<li>blob没有字符集，text有一个字符集，并且根据字符集的校对规则对值进行排序和比较</li>
</ul>
<h2 id="DATETIME和TIMESTAMP的异同？"><a href="#DATETIME和TIMESTAMP的异同？" class="headerlink" title="DATETIME和TIMESTAMP的异同？"></a>DATETIME和TIMESTAMP的异同？</h2><p>相同点 ：</p>
<ul>
<li><ol>
<li>两个数据类型存储时间的表现格式一致。均为 YYYY-MM-DD HH:MM:SS</li>
</ol>
</li>
<li><ol start="2">
<li>两个数据类型都包含「日期」和「时间」部分。</li>
</ol>
</li>
<li><ol start="3">
<li>两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒）</li>
</ol>
</li>
</ul>
<p>区别 ：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908111247064.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908111247064"></p>
<ul>
<li><ol>
<li>日期范围：DATETIME 的日期范围是 1000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999 ；TIMESTAMP 的时间范围是1970-01-01 00:00:01.000000 UTC到 ``2038-01-09 03:14:07.999999 UTC</li>
</ol>
</li>
<li><ol start="2">
<li>存储空间：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节</li>
</ol>
</li>
<li><ol start="3">
<li>时区相关：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区</li>
</ol>
</li>
<li><ol start="4">
<li>默认值：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)</li>
</ol>
</li>
</ul>
<h2 id="MySQL中-in-和-exists-的区别？"><a href="#MySQL中-in-和-exists-的区别？" class="headerlink" title="MySQL中 in 和 exists 的区别？"></a>MySQL中 in 和 exists 的区别？</h2><p>MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。我们可能认为exists比in语句的效率要高，这种说法其实是不准确的，要区分情景：</p>
<ul>
<li><strong>1.</strong> 如果查询的两个表大小相当，那么用in和exists差别不大。</li>
<li><strong>2.</strong> 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li>
<li><strong>3.</strong> not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li>
</ul>
<h2 id="MySQL里记录货币用什么字段类型比较好？"><a href="#MySQL里记录货币用什么字段类型比较好？" class="headerlink" title="MySQL里记录货币用什么字段类型比较好？"></a>MySQL里记录货币用什么字段类型比较好？</h2><p>货币在数据库中MySQL常用<strong>Decimal</strong>和<strong>Numric</strong>类型表示，这两种类型被MySQL实现为同样的类型。他们被用于保存与货币有关的数据。</p>
<p>例如salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在salary列中的值的范围是从-9999999.99到9999999.99。</p>
<p><strong>DECIMAL</strong>和<strong>NUMERIC</strong>值作为<strong>字符串存储</strong>，而不是作为二进制浮点数，以便保存那些值的小数精度。</p>
<p>之所以不使用float或者double的原因：因为float和double是以二进制存储的，所以<strong>有一定的误差</strong>。</p>
<h2 id="MySQL怎么存储emoji"><a href="#MySQL怎么存储emoji" class="headerlink" title="MySQL怎么存储emoji $?"></a>MySQL怎么存储emoji $?</h2><p>MySQL可以直接使用字符串存储emoji。</p>
<p>但是需要注意的，utf8 编码是不行的，MySQL中的utf8是阉割版的 utf8，它最多只用 3 个字节存储字符，所以存储不了表情。那该怎么办？</p>
<p>需要使用utf8mb4编码。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">alter table blogs modify content text <span class="token constant">CHARACTER</span> <span class="token constant">SET</span> utf8mb4 <span class="token constant">COLLATE</span> utf8mb4_unicode_ci not <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<h2 id="drop、delete与truncate的区别？"><a href="#drop、delete与truncate的区别？" class="headerlink" title="drop、delete与truncate的区别？"></a>drop、delete与truncate的区别？</h2><p>三者都表示删除，但是三者有一些差别：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908112356710.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908112356710"></p>
<p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p>
<h2 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a>UNION与UNION ALL的区别？</h2><ul>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h2 id="count-1-、count-与-count-列名-的区别？"><a href="#count-1-、count-与-count-列名-的区别？" class="headerlink" title="count(1)、count(*) 与 count(列名) 的区别？"></a>count(1)、count(*) 与 count(列名) 的区别？</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908113932735.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908113932735"></p>
<p><strong>执行效果 ：</strong></p>
<ul>
<li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为NULL</li>
<li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0 ，而是表示null）的计数，即某个字段值为NULL时，不统计。</li>
</ul>
<p><strong>执行速度</strong> ：</p>
<ul>
<li>列名为主键，count(列名)会比count(1)快</li>
<li>列名不为主键，count(1)会比count(列名)快</li>
<li>如果表多个列并且没有主键，则 count（ 1 ） 的执行效率优于 count（*）</li>
<li>如果有主键，则 select count（主键）的执行效率是最优的</li>
<li>如果表只有一个字段，则 select count（*）最优。</li>
</ul>
<h2 id="一条SQL查询语句的执行顺序？"><a href="#一条SQL查询语句的执行顺序？" class="headerlink" title="一条SQL查询语句的执行顺序？"></a>一条SQL查询语句的执行顺序？</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908114246845.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908114246845"></p>
<p><strong>1.</strong> <strong>FROM</strong>：对FROM子句中的左表<left_table>和右表<right_table>执行笛卡儿积（Cartesianproduct），产生虚拟表VT1</p>
<p><strong>2.</strong> <strong>ON</strong>：对虚拟表VT1应用ON筛选，只有那些符合<join_condition>的行才被插入虚拟表VT2中</p>
<p><strong>3.</strong> <strong>JOIN</strong>：如果指定了OUTER JOIN（如LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤 1 ）～步骤3 ），直到处理完所有的表为止</p>
<p><strong>4.</strong> <strong>WHERE</strong>：对虚拟表VT3应用WHERE过滤条件，只有符合<where_condition>的记录才被插入虚拟表VT4中</p>
<p><strong>5.</strong> <strong>GROUP BY</strong>：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5</p>
<p><strong>6.</strong> <strong>CUBE|ROLLUP</strong>：对表VT5进行CUBE或ROLLUP操作，产生表VT6</p>
<p><strong>7.</strong> <strong>HAVING</strong>：对虚拟表VT6应用HAVING过滤器，只有符合<having_condition>的记录才被插入虚拟表VT7中。</p>
<p><strong>8.</strong> <strong>SELECT</strong>：第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中</p>
<p><strong>9. DISTINCT</strong>：去除重复数据，产生虚拟表VT9</p>
<p><strong>10.</strong> <strong>ORDER BY</strong>：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10。 11 ）</p>
<p><strong>11.</strong> <strong>LIMIT</strong>：取出指定行的记录，产生虚拟表VT11，并返回给查询用户</p>
<h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a><strong>基础架构</strong></h1><h2 id="MySQL-基本架构概览"><a href="#MySQL-基本架构概览" class="headerlink" title="MySQL 基本架构概览"></a>MySQL 基本架构概览</h2><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908160140480.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908160140480"></p>
<p>从上图可以看出， <strong>MySQL 主要由下面几部分构成</strong>：</p>
<ul>
<li><p><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</p>
</li>
<li><p><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</p>
</li>
<li><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p>
</li>
<li><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p>
</li>
<li><p><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p>
</li>
<li><p><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</p>
</li>
</ul>
<p>简单来说 MySQL 主要分为 <strong>Server 层</strong>和<strong>存储引擎</strong>层：</p>
<ul>
<li><p><strong>Server 层</strong>：主要包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。</p>
</li>
<li><p><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 <strong>InnoDB、MyISAM、Memory</strong> 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</p>
</li>
</ul>
<h2 id="Server-层基本组件介绍"><a href="#Server-层基本组件介绍" class="headerlink" title="Server 层基本组件介绍"></a>Server 层基本组件介绍</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器主要和<strong>身份认证和权限</strong>相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>
<h3 id="查询缓存-MySQL-8-0-版本后移除"><a href="#查询缓存-MySQL-8-0-版本后移除" class="headerlink" title="查询缓存(MySQL 8.0 版本后移除)"></a>查询缓存(MySQL 8.0 版本后移除)</h3><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器的作用就是它认为的最优的<strong>执行方案</strong>去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h2 id="一条-SQL-语句是如何执行"><a href="#一条-SQL-语句是如何执行" class="headerlink" title="一条 SQL 语句是如何执行"></a>一条 SQL 语句是如何执行</h2><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tb_student A <span class="token keyword">where</span> A<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token string">'18'</span> <span class="token operator">and</span> A<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">' 张三 '</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li><p>先检查该语句<strong>是否有权限</strong>，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先<strong>查询缓存</strong>，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li><p>通过分析器进行<strong>词法分析</strong>，<strong>提取 SQL 语句的关键元素</strong>，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=’1’。然后<strong>判断这个 SQL 语句是否有语法错误</strong>，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li><p>接下来就是<strong>优化器进行确定执行方案</strong>，上面的 SQL 语句，可以有两种执行方案：</p>
</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">a<span class="token punctuation">.</span>先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 <span class="token number">18</span>。
b<span class="token punctuation">.</span>先找出学生中年龄 <span class="token number">18</span> 岁的学生，然后再查询姓名为“张三”的学生。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>

<ul>
<li><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h3 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h3><p>以上就是一条查询 SQL 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？SQL 语句如下：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">update</span> tb_student A <span class="token keyword">set</span> A<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token string">'19'</span> <span class="token keyword">where</span> A<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">' 张三 '</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li><p>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</p>
</li>
<li><p>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</p>
</li>
<li><p>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</p>
</li>
<li><p>更新完成。</p>
</li>
</ul>
<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 <strong>redo log 是 InnoDB 引擎特有的</strong>，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，<strong>binlog 日志只能用来归档</strong>。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><p><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p>
</li>
<li><p><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</p>
</li>
</ul>
<p>如果采用 <strong>redo log 两阶段提交</strong>的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li><p>判断 redo log 是否完整，如果判断是完整的，就立即提交。</p>
</li>
<li><p>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</p>
</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>MySQL 主要分为 <strong>Server 层和引擎层</strong>，Server 层主要包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>，同时还有一个日志模块（<strong>binlog</strong>），这个日志模块所有执行引擎都可以共用，<strong>redolog 只有 InnoDB 有</strong>。</p>
</li>
<li><p>引擎层是插件式的，目前主要包括，<strong>MyISAM,InnoDB,Memory</strong> 等。</p>
</li>
<li><p>查询语句的执行流程如下：<strong>权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</strong></p>
</li>
<li><p>更新语句执行流程如下：<strong>分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</strong></p>
</li>
</ul>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a><strong>存储引擎</strong></h1><h2 id="MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="MySQL 支持哪些存储引擎？默认使用哪个？"></a>MySQL 支持哪些存储引擎？默认使用哪个？</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908172148275.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908172148275"></p>
<p>主要存储引擎以及功能如下：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908172213800.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908172213800"></p>
<p>MySQL5.5之前，默认存储引擎是MylSAM，5.5之后变成了InnoDB。</p>
<p>InnoDB支持的<strong>哈希索引</strong>是自适应的，InnoDB会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p>
<p>MySQL 5.6开始InnoDB支持全文索引。</p>
<h2 id="那存储引擎应该怎么选择？"><a href="#那存储引擎应该怎么选择？" class="headerlink" title="那存储引擎应该怎么选择？"></a>那存储引擎应该怎么选择？</h2><p>大致上可以这么选择：</p>
<ul>
<li>大多数情况下，使用默认的InnoDB就够了。如果要提供<strong>提交、回滚和恢复的事务安全（ACID 兼容）</strong>能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。</li>
<li>如果数据表主要用来<strong>插入和查询记录</strong>，则 <strong>MyISAM</strong> 引擎提供较高的处理效率。</li>
<li>如果只是<strong>临时存放数据</strong>，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 <strong>MEMORY</strong> 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li>
</ul>
<p>使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</p>
<h2 id="InnoDB和MylSAM主要有什么区别？"><a href="#InnoDB和MylSAM主要有什么区别？" class="headerlink" title="InnoDB和MylSAM主要有什么区别？"></a>InnoDB和MylSAM主要有什么区别？</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908174526568.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908174526568"></p>
<p><strong>1.是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p>
<p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解open in new window</a>。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p>
<p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/E2S3AbqgaMevqcRf65-GykDq98ATjfCSA4IUeqk_7ME.pngtoken=W.LuJhepAXj28rmGMNzUwb-qHCaAjyOTpGOs7ceh3hGLgsV77WbxbKZOsY-xRYhbs" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="error"></p>
<p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p>
<p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <strong>redo log</strong> 。</p>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p>
<p><strong>6.索引实现不一样。</strong></p>
<p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 <strong>B+Tree</strong> 作为索引结构，但是两者的实现方式不太一样。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h1><h2 id="MySQL日志文件有哪些？分别介绍下作用？"><a href="#MySQL日志文件有哪些？分别介绍下作用？" class="headerlink" title="MySQL日志文件有哪些？分别介绍下作用？"></a>MySQL日志文件有哪些？分别介绍下作用？</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908215650562.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908215650562"></p>
<p>MySQL日志文件有很多，包括 ：</p>
<ul>
<li><strong>错误日志（error log）</strong>：错误日志文件对MySQL的启动、运行、关闭过程进行了记录，能帮助定位MySQL问题。</li>
<li><strong>慢查询日志（slow query log）</strong>：慢查询日志是用来记录执行时间超过 <strong>long_query_time</strong> 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。</li>
<li><strong>一般查询日志（general log）</strong>：一般查询日志记录了所有对MySQL数据库请求的信息，无论请求是否正确执行。</li>
<li><strong>二进制日志（bin log）</strong>：关于二进制日志，它记录了数据库所有执行的DDL和DML语句（除了数据查询语句select、show等），以事件形式记录并保存在二进制文件中。</li>
</ul>
<p>还有两个<strong>InnoDB</strong>存储引擎特有的日志文件：</p>
<ul>
<li><strong>重做日志（redo log）</strong>：重做日志至关重要，因为它们记录了对于InnoDB存储引擎的事务日志。</li>
<li><strong>回滚日志（undo log）</strong>：回滚日志同样也是InnoDB引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB引擎不仅会记录redolog，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。</li>
</ul>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>redo log（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力。</p>
<p>比如 MySQL 实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性与完整性。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908180104830.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908180104830"></p>
<p><strong>MySQL</strong> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <strong>Buffer Pool</strong> 中。</p>
<p>后续的查询都是先从 <strong>Buffer Pool</strong> 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 <strong>Buffer Pool</strong> 里存在要更新的数据，就直接在 <strong>Buffer Pool</strong> 里更新。</p>
<p>然后会把“<strong>在某个数据页上做了什么修改</strong>”记录到<strong>重做日志缓存（redo log buffer）</strong>里，接着刷盘到 <strong>redo log</strong> 文件里。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908180909891.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908180909891"></p>
<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>
<p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
<h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p>InnoDB 存储引擎为 redo log 的刷盘策略提供了 <strong>innodb_flush_log_at_trx_commit</strong> 参数，它支持三种策略：</p>
<ul>
<li><p><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</p>
</li>
<li><p><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</p>
</li>
<li><p><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</p>
</li>
</ul>
<p><strong>innodb_flush_log_at_trx_commit</strong> 参数默认为 1 ，也就是说当事务提交时会<strong>调用 fsync 对 redo log 进行刷盘</strong></p>
<p>另外，InnoDB 存储引擎有一个<strong>后台线程</strong>，每隔1 秒，就会把 redo log buffer 中的内容写到<strong>文件系统缓存（page cache）</strong>，然后调用 <strong>fsync</strong> 刷盘。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181309250.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908181309250"></p>
<p>也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。</p>
<p>因为在事务执行过程 redo log 记录是会写入redo log buffer 中，这些 redo log 记录会被后台线程刷盘。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181359838.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908181359838"></p>
<p>除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。</p>
<p>下面是不同刷盘策略的流程图。</p>
<h5 id="innodb-flush-log-at-trx-commit-0"><a href="#innodb-flush-log-at-trx-commit-0" class="headerlink" title="innodb_flush_log_at_trx_commit=0"></a>innodb_flush_log_at_trx_commit=0</h5><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181455376.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908181455376"></p>
<p>为0时，如果MySQL挂了或宕机可能会有1秒数据的丢失。</p>
<h5 id="innodb-flush-log-at-trx-commit-1"><a href="#innodb-flush-log-at-trx-commit-1" class="headerlink" title="innodb_flush_log_at_trx_commit=1"></a>innodb_flush_log_at_trx_commit=1</h5><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181543540.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908181543540"></p>
<p>为1时， 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>
<h5 id="innodb-flush-log-at-trx-commit-2"><a href="#innodb-flush-log-at-trx-commit-2" class="headerlink" title="innodb_flush_log_at_trx_commit=2"></a>innodb_flush_log_at_trx_commit=2</h5><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908181632240.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908181632240"></p>
<p>如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</p>
<h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p>硬盘上存储的 redo log 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的redo日志文件大小都是一样的。</p>
<p>比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。</p>
<p>它采用的是<strong>环形数组</strong>形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908182238317.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908182238317"></p>
<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <strong>write pos、checkpoint</strong></p>
<ul>
<li><p><strong>write pos</strong> 是当前记录的位置，一边写一边后移</p>
</li>
<li><p><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</p>
</li>
</ul>
<p>每次刷盘 redo log 记录到<strong>日志文件组</strong>中，write pos 位置就会后移更新。</p>
<p>每次 MySQL 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。</p>
<p>write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908182729899.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908182729899"></p>
<p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908182834045.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908182834045"></p>
<h3 id="redo-log-小结"><a href="#redo-log-小结" class="headerlink" title="redo log 小结"></a>redo log 小结</h3><p>相信大家都知道 redo log 的作用和它的刷盘时机、存储形式。</p>
<p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有</strong> <strong>redo log</strong> <strong>什么事？</strong></p>
<p>它们不都是刷盘么？差别在哪里？</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span> Byte <span class="token operator">=</span> <span class="token number">8</span>bit
<span class="token number">1</span> KB <span class="token operator">=</span> <span class="token number">1024</span> Byte
<span class="token number">1</span> MB <span class="token operator">=</span> <span class="token number">1024</span> KB
<span class="token number">1</span> GB <span class="token operator">=</span> <span class="token number">1024</span> MB
<span class="token number">1</span> TB <span class="token operator">=</span> <span class="token number">1024</span> GB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>实际上，数据页大小是16KB，刷盘比较耗时，可能就修改了数据页里的几 Byte 数据，有必要把完整的数据页刷盘吗？</p>
<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>
<p>如果是写 redo log，一行记录可能就占几十 Byte，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p>
<p>所以用 redo log 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>redo log 它是物理日志，记录内容是“<strong>在某个数据页上做了什么修改</strong>”，属于 InnoDB 存储引擎。</p>
<p>而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。</p>
<p>那 binlog 到底是用来干嘛的？</p>
<p>可以说MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213313383.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908213313383"></p>
<p>binlog会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p>binlog 日志有三种格式，可以通过binlog_format参数指定。</p>
<ul>
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ul>
<p>指定<strong>statement</strong>，记录的内容是SQL语句原文，比如执行一条<strong>update T set update_time=now() where id=1</strong>，记录的内容如下。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213421869.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908213421869"></p>
<p>同步数据时，会执行记录的SQL语句，但是有个问题，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<p>为了解决这种问题，我们需要指定为row，记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213517492.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908213517492"></p>
<p>row格式记录的内容看不到详细信息，要通过mysqlbinlog工具解析出来。</p>
<p>update_time=now()变成了具体的时间update_time=1627112756247，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。</p>
<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为mixed，记录的内容是前两者的混合。</p>
<p>MySQL会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式</p>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<strong>binlog cache</strong>，事务提交的时候，再把binlog cache写到<strong>binlog</strong>文件中。</p>
<p>因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p>
<p>我们可以通过<strong>binlog_cache_size</strong>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。</p>
<p>binlog日志刷盘流程如下</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213744369.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908213744369"></p>
<ul>
<li><p><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></p>
</li>
<li><p><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></p>
</li>
</ul>
<p>write和fsync的时机，可以由参数sync_binlog控制，默认是0。</p>
<p>为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213841944.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908213841944"></p>
<p>虽然性能得到提升，但是机器宕机，page cache里面的 binlog 会丢失。</p>
<p>为了安全起见，可以设置为1，表示每次提交事务都会执行fsync，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</p>
<p>最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908213916706.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908213916706"></p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。</p>
<p>binlog（归档日志）保证了MySQL集群架构的数据一致性。</p>
<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214058360.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908214058360"></p>
<p>回到正题，redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？</p>
<p>我们以update语句为例，假设id=2的记录，字段c值是0，把字段c值更新成1，SQL语句为update T set c=1 where id=2。</p>
<p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214137165.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908214137165"></p>
<p>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为redo log日志恢复，这一行c值是1，最终数据不一致。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214216674.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908214216674"></p>
<p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。</p>
<p>原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是<strong>两阶段提交</strong>。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214310160.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908214310160"></p>
<p>使用<strong>两阶段提交</strong>后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214404416.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908214404416"></p>
<p>再看一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908214432260.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908214432260"></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p>
<h2 id="binlog和redo-log有什么区别？"><a href="#binlog和redo-log有什么区别？" class="headerlink" title="binlog和redo log有什么区别？"></a>binlog和redo log有什么区别？</h2><ul>
<li>bin log会记录所有与数据库有关的日志记录，包括InnoDB、MyISAM等存储引擎的日志，而redo log只记InnoDB存储引擎的日志。</li>
<li>记录的内容不同，bin log记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而redo log记录的是关于每个页（Page）的更改的物理情况。</li>
<li>写入的时间不同，bin log仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有redo ertry被写入redo log中。</li>
<li>写入的方式也不相同，redo log是循环写入和擦除，bin log是追加写入，不会覆盖已经写的文件。</li>
</ul>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<p>另外，MVCC 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</p>
<h2 id="一条更新语句怎么执行的了解吗？"><a href="#一条更新语句怎么执行的了解吗？" class="headerlink" title="一条更新语句怎么执行的了解吗？"></a>一条更新语句怎么执行的了解吗？</h2><p>更新语句的执行是Server层和引擎层配合完成，数据除了要写入表中，还要记录相应的日志。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908220733335.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908220733335"></p>
<ol>
<li><p>执行器先找引擎获取ID=2这一行。ID是主键，存储引擎检索数据，找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上 1 ，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接又写入这行新数据。</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</p>
</li>
<li><p>执行器生成这个操作的binlog，并把binlog写入磁盘。</p>
</li>
<li><p>执行器调用引擎的提交事务接又，引擎把刚刚写入的redo log改成提交（commit）状态，<br>更新完成。</p>
</li>
</ol>
<p>从上图可以看出，MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。</p>
<p>不仅如此，在对redo log写入时有两个阶段的提交，一是binlog写入之前prepare状态的写入，二是binlog写入之后commit状态的写入。</p>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><strong>SQL优化</strong></h1><h2 id="慢SQL如何定位呢？"><a href="#慢SQL如何定位呢？" class="headerlink" title="慢SQL如何定位呢？"></a>慢SQL如何定位呢？</h2><p>慢SQL的监控主要通过两个途径：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220908221555005.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220908221555005"></p>
<ul>
<li><strong>慢查询日志</strong>：开启MySQL的慢查询日志，再通过一些工具比如mysqldumpslow去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。</li>
<li><strong>服务监控</strong>：可以在业务的基建中加入对慢SQL的监控，常见的方案有字节码插桩、连接池扩展、ORM框架过程，对服务运行中的慢SQL进行监控和告警。</li>
</ul>
<h2 id="有哪些方式优化慢SQL？"><a href="#有哪些方式优化慢SQL？" class="headerlink" title="有哪些方式优化慢SQL？"></a>有哪些方式优化慢SQL？</h2><p>慢SQL的优化，主要从两个方面考虑，SQL语句本身的优化，以及数据库设计的优化。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220909144014581.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220909144014581"></p>
<h3 id="避免不必要的列"><a href="#避免不必要的列" class="headerlink" title="避免不必要的列"></a>避免不必要的列</h3><p>这个是老生常谈，但还是经常会出的情况，SQL查询的时候，应该只查询需要的列，而不要包含额外的列，像*<em>select **</em> 这种写法应该尽量避免。</p>
<h3 id="分页优化"><a href="#分页优化" class="headerlink" title="分页优化"></a><strong>分页优化</strong></h3><h4 id="过大的分页查询为什么会慢？"><a href="#过大的分页查询为什么会慢？" class="headerlink" title="过大的分页查询为什么会慢？"></a><strong>过大的分页查询为什么会慢？</strong></h4><p>下面我们先构造一个例子：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#先创建一张MySQL表</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>limit_optimize_tbl<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>account<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>order_id<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">2000002</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8

<span class="token keyword">create</span> <span class="token keyword">index</span> idx_account <span class="token keyword">on</span> limit_optimize_tbl<span class="token punctuation">(</span>account<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_order_id <span class="token keyword">on</span> limit_optimize_tbl<span class="token punctuation">(</span>order_id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">#创建一个插入数据的存储过程</span>
<span class="token keyword">DELIMITER</span> <span class="token comment">//</span>
<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> limit_optimize_test<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span><span class="token punctuation">;</span>
    <span class="token keyword">SET</span> i<span class="token operator">=</span><span class="token number">1000000</span><span class="token punctuation">;</span>
    <span class="token keyword">WHILE</span> i<span class="token operator">&lt;=</span><span class="token number">3000000</span> <span class="token keyword">DO</span>
        <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> limit_optimize_tbl<span class="token punctuation">(</span>account<span class="token punctuation">,</span>order_id<span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'test_123'</span><span class="token punctuation">,</span>concat<span class="token punctuation">(</span><span class="token string">'order'</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">SET</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
<span class="token comment">//</span>
<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span>

<span class="token comment">#调用存储过程，插入200万行数据</span>
<span class="token keyword">call</span> limit_optimize_test<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>下面的这行 SQL 是一个常见的分页查询的语句：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>这种写法是最简单的，但同时也是最容易出问题的。</p>
<p>曾经有人做过调查，用户在浏览前端页面时，假如这个页面是分页浏览的（例如淘宝），用户只会浏览前面几页，一般翻页超过 10 页很多人就开始表现的不耐烦了。</p>
<p>在翻页比较少的情况下，LIMIT 子句并不会表现出性能问题。</p>
<p>但是假如用户要直接跳到最后一页呢？</p>
<p>通常情况下，由于要保证所有的页面都可以正常跳转，因此可能不会使用如下这种语句：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>而是继续采用正序顺序做分页查询：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>采用这种 SQL 查询的话，此时从 MySQL 中取出这 10 行数据的代价是非常大的，需要先排序出前面 1000010 条记录，然后抛弃前面的 1000000 条。</p>
<p>查询数据和排序的代价非常高。</p>
<p>我们再来看一下上面这个 SQL 语句的执行计划：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span> \G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: limit_optimize_tbl
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">index</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: idx_order_id
      key_len: <span class="token number">302</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">10</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token boolean">NULL</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span><span class="token number">10</span> \G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: limit_optimize_tbl
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">ALL</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: <span class="token boolean">NULL</span>
      key_len: <span class="token boolean">NULL</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">1994816</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token keyword">Using</span> filesort
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>从执行计划中你可以看到，在大分页的时候，MySQL 并没有走索引扫描，而是使用了全表扫描的方式。</p>
<p>那这又是为什么呢？</p>
<p>MySQL 数据库采用了基于代价的查询优化器，而查询代价的估算是基于 CPU 代价和 IO 代价。</p>
<p>由于现在机械硬盘还没有被完全淘汰掉，因此在类似这种局部扫描的动作中，随机 IO 的代价，仍然被 MySQL 的查询优化器认为是非常高的。</p>
<p>对于局部扫描，MySQL 会根据数据量的情况和数据获取的条件，去做代价估算，决定是采用顺序扫描还是随机读取存储系统。</p>
<p><strong>如果 MySQL 在查询代价估算中，认为采取顺序扫描方式比局部随机扫描的效率更高的话，就会放弃索引，转向顺序扫描的方式</strong>。</p>
<p>这就是为什么在大分页中 MySQL 数据库走了全表扫描的原因。</p>
<p>下面我们还是使用刚刚的 SQL 语句，再来实验一下：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">#这两个SQL语句是查询优化器改变策略的一个临界点，在笔者电脑上测试通过</span>
mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">5660</span><span class="token punctuation">,</span><span class="token number">10</span> \G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: limit_optimize_tbl
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">index</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: idx_order_id
      key_len: <span class="token number">302</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">5670</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token boolean">NULL</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">5661</span><span class="token punctuation">,</span><span class="token number">10</span> \G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: limit_optimize_tbl
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">ALL</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: <span class="token boolean">NULL</span>
      key_len: <span class="token boolean">NULL</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">1994816</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token keyword">Using</span> filesort
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>从上面的实验你可以看到，在这个临界点上，MySQL 分别采用了<strong>索引扫描</strong>和<strong>全表扫描</strong>的查询优化方式。</p>
<p>你可以自行运行下这两个 SQL 语句，比较下执行时间。</p>
<p>由于 MySQL 的查询优化器的算法核心我们是无法人工干预的，因此我们的优化思路应该着眼于如何<strong>让分页维持在最佳的效率区间</strong>。</p>
<p>下面我们就来看下如何优化。</p>
<p>优化可以从两个角度进行分析：<strong>SQL 改写优化与业务角度优化</strong>。</p>
<h4 id="SQL-改写优化"><a href="#SQL-改写优化" class="headerlink" title="SQL 改写优化"></a><strong>SQL 改写优化</strong></h4><h5 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h5><p>由于索引是有序的，因此这种优化方式的思路是直接在索引上完成排序和分页的操作。</p>
<p>先来说说什么是<strong>覆盖索引</strong>。</p>
<p>如果一个 SQL 语句，通过索引即可直接获取查询结果，而<strong>不再需要回表查询</strong>，就称这个索引覆盖了这条 SQL 语句。</p>
<p>也就是平时所说的不需要回表操作。</p>
<p>在 MySQL 数据库中使用执行计划查看，如果 <strong>extra</strong> 这一列中显示 <strong>Using index</strong>，就表示这条 SQL 语句使用了<strong>覆盖索引</strong>。</p>
<p>下面我们看下刚刚的那条 SQL 语句：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span> \G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: limit_optimize_tbl
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">index</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: idx_order_id
      key_len: <span class="token number">302</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">10</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token boolean">NULL</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> order_id <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span> \G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: limit_optimize_tbl
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">index</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: idx_order_id
      key_len: <span class="token number">302</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">10</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token keyword">Using</span> <span class="token keyword">index</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">explain</span> <span class="token keyword">select</span> id <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span> \G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: limit_optimize_tbl
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">index</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: idx_order_id
      key_len: <span class="token number">302</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">10</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token keyword">Using</span> <span class="token keyword">index</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>从这个实验中可以看到，除了 select * 的那条 SQL 语句，其他两个都使用了覆盖索引。</p>
<p>你也可以对比一下使用了覆盖索引的大分页和和没有使用覆盖索引的性能差异。</p>
<p>在我的环境中执行实验中的 “LIMIT 1000000,10” 的分页查询，没有使用覆盖索引的 SQL 语句执行时间是 2.51s，使用了覆盖索引的 SQL 语句执行时间是 0.16s，优化效果还是非常明显的。</p>
<h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><p>由于在 <strong>SELECT</strong> 语句中我们很少会只查询某一两个列，因此上述覆盖索引的适用范围就比较有限。</p>
<p>可以通过<strong>将分页的 SQL 语句改写成子查询</strong>的方法获得性能的提升：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">where</span> id<span class="token operator">>=</span><span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token operator">|</span> id      <span class="token operator">|</span> account  <span class="token operator">|</span> order_id     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token operator">|</span> <span class="token number">1000001</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000000 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000002</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000001 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000003</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000002 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000004</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000003 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000005</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000004 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000006</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000005 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000007</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000006 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000008</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000007 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000009</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000008 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000010</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000009 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token number">10</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.16</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>执行时间和上一节的使用了覆盖索引的 SQL 语句基本一致。</p>
<p>不知道你有没有观察到，这种优化方法也有其局限性：</p>
<ol>
<li>首先，分页的数据必须是连续的</li>
<li>其次，WHERE 子句里面不能再添加别的条件</li>
</ol>
<h5 id="延迟关联"><a href="#延迟关联" class="headerlink" title="延迟关联"></a>延迟关联</h5><p>和上述子查询的做法类似，我们也可以使用 <strong>JOIN</strong> 的语法，<strong>先在索引上完成分页的操作，然后再回表获取需要的数据列</strong>。</p>
<p>示例如下：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> a<span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl a <span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">limit</span> <span class="token number">1000000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> b <span class="token keyword">on</span> a<span class="token punctuation">.</span>id<span class="token operator">=</span>b<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token operator">|</span> id      <span class="token operator">|</span> account  <span class="token operator">|</span> order_id     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token operator">|</span> <span class="token number">1000001</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000000 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000002</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000001 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000003</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000002 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000004</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000003 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000005</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000004 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000006</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000005 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000007</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000006 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000008</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000007 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000009</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000008 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000010</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000009 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token number">10</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.15</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>你可以和上一小节的子查询优化的方式做个对比，在采用了 JOIN 语法改写之后，上面的两个限制都解除了，并且 SQL 的执行效率没有损失。</p>
<h5 id="记录书签"><a href="#记录书签" class="headerlink" title="记录书签"></a>记录书签</h5><p>和上述使用覆盖索引的思路不同，<strong>记录书签的优化思路是使用书签记录上一页数据的位置，下次分页时直接从这个书签的位置开始扫描</strong>，从而避免 MySQL 扫描大量的数据行再丢弃的操作。</p>
<p>示例如下：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">where</span> id<span class="token operator">>=</span><span class="token number">1000001</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token operator">|</span> id      <span class="token operator">|</span> account  <span class="token operator">|</span> order_id     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token operator">|</span> <span class="token number">1000001</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000000 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000002</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000001 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000003</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000002 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000004</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000003 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000005</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000004 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000006</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000005 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000007</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000006 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000008</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000007 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000009</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000008 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000010</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000009 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token number">10</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>从上面的 SQL 语句你可以看到，由于使用了主键索引来做分页的操作，SQL 语句的性能是极佳的。</p>
<p>使用其他列做书签也是可以的：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">where</span> order_id<span class="token operator">>=</span><span class="token string">'order2000000'</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token operator">|</span> id      <span class="token operator">|</span> account  <span class="token operator">|</span> order_id     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token operator">|</span> <span class="token number">1000001</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000000 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000002</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000001 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000003</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000002 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000004</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000003 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000005</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000004 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000006</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000005 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000007</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000006 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000008</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000007 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000009</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000008 <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token number">1000010</span> <span class="token operator">|</span> test_123 <span class="token operator">|</span> order2000009 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------+--------------+</span>
<span class="token number">10</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>这里要给你提个醒，如果没有使用主键索引或唯一索引做这个书签，排序的字段有大量重复值的情况下，输出的结果不一定是准确的，不适合使用这种写法。</p>
<h5 id="反向查找"><a href="#反向查找" class="headerlink" title="反向查找"></a>反向查找</h5><p>反向查找即我们在本文的开头提到的例子：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> limit_optimize_tbl <span class="token keyword">order</span> <span class="token keyword">by</span> order_id <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>这种优化的思路来自于二分查找，也就是说，<strong>当偏移量超过记录数的一半时，就可以使用这种写法来获得性能的提升</strong>。</p>
<p>不过这种方法需要在分页前知道符合条件的总的记录条数，但是在 InnoDB 存储引擎中，COUNT (*) 的开销其实也不小。</p>
<p>因此建议你仅在一些特殊情况下选用，例如<strong>直接跳到尾页</strong>。</p>
<h4 id="业务角度优化"><a href="#业务角度优化" class="headerlink" title="业务角度优化"></a>业务角度优化</h4><h5 id="翻页限制"><a href="#翻页限制" class="headerlink" title="翻页限制"></a>翻页限制</h5><h6 id="不允许翻过多的页"><a href="#不允许翻过多的页" class="headerlink" title="不允许翻过多的页"></a><strong>不允许翻过多的页</strong></h6><p>一言以蔽之，就是不给你查了。<br>把 LIMIT 分页的偏移量做一个限制，超过某个阈值就停止。<br>我们以淘宝网为例，使用比较热门的 “连衣裙” 的关键词进行搜索，网站仅仅提供了 100 个数据页。<br>很多大型互联网公司由于数据量巨大，都有使用这种方法。<br>粗暴又有效。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/v2-9554bb5793a4296b773f516bf6f7e846_1440w.jpg" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="img"></p>
<h6 id="流式分页"><a href="#流式分页" class="headerlink" title="流式分页"></a><strong>流式分页</strong></h6><p>这种分页方式比较适用于移动端，即只能一页一页的向前或向后加载，不提供跳转的功能。<br>可以在上一级入口中提供业务列表给用户选择，从而减少分页。<br>这种分页方式在电商和新闻类 APP 上应用的非常广泛，你也可以试试。</p>
<h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>合理地设计和使用索引，是优化慢SQL的利器。</p>
<h4 id="利用覆盖索引"><a href="#利用覆盖索引" class="headerlink" title="利用覆盖索引"></a><strong>利用覆盖索引</strong></h4><p>InnoDB使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引</p>
<p>例如对于如下查询：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> name <span class="token keyword">from</span> test <span class="token keyword">where</span> city<span class="token operator">=</span><span class="token string">'上海'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>我们将被查询的字段建⽴到联合索引中，这样查询结果就可以直接从索引中获取</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> test <span class="token keyword">add</span> <span class="token keyword">index</span> idx_city_name <span class="token punctuation">(</span>city<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<h4 id="低版本避免使用or查询"><a href="#低版本避免使用or查询" class="headerlink" title="低版本避免使用or查询"></a><strong>低版本避免使用or查询</strong></h4><p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。</p>
<h4 id="避免使用-或者-lt-gt-操作符"><a href="#避免使用-或者-lt-gt-操作符" class="headerlink" title="避免使用 != 或者 &lt;&gt; 操作符"></a><strong>避免使用 != 或者 &lt;&gt; 操作符</strong></h4><p>SQL中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引</p>
<p>解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描</p>
<p>例如，把<strong>column&lt;&gt;’aaa’</strong>，改成<strong>column&gt;’aaa’ or column&lt;’aaa’</strong>，就可以使用索引了</p>
<h4 id="适当使用前缀索引"><a href="#适当使用前缀索引" class="headerlink" title="适当使用前缀索引"></a><strong>适当使用前缀索引</strong></h4><p>适当地使用前缀索引，可以降低索引的空间占用，提高索引的查询效率。</p>
<p>比如，邮箱的后缀都是固定的“@xxx.com”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">alter</span> <span class="token keyword">table</span> test <span class="token keyword">add</span> <span class="token keyword">index</span> index2<span class="token punctuation">(</span>email<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>PS:需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引</p>
<h4 id="避免列上函数运算"><a href="#避免列上函数运算" class="headerlink" title="避免列上函数运算"></a><strong>避免列上函数运算</strong></h4><p>要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> test <span class="token keyword">where</span> id <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">50</span> <span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> test <span class="token keyword">where</span> <span class="token keyword">month</span><span class="token punctuation">(</span>updateTime<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">7</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>

<h4 id="正确使用联合索引"><a href="#正确使用联合索引" class="headerlink" title="正确使用联合索引"></a><strong>正确使用联合索引</strong></h4><p>使用联合索引的时候，注意最左匹配原则。</p>
<h3 id="JOIN优化"><a href="#JOIN优化" class="headerlink" title="JOIN优化"></a>JOIN优化</h3><h4 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a><strong>优化子查询</strong></h4><p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大</p>
<h4 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a><strong>小表驱动大表</strong></h4><p>关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL内部会遍历驱动表，再去连接被驱动表。</p>
<p>比如left join，左表就是驱动表，A表小于B表，建立连接的次数就少，查询速度就被加快了。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> name <span class="token keyword">from</span> A <span class="token keyword">left</span> <span class="token keyword">join</span> B <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<h4 id="适当增加冗余字段"><a href="#适当增加冗余字段" class="headerlink" title="适当增加冗余字段"></a><strong>适当增加冗余字段</strong></h4><p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p>
<h4 id="避免使用JOIN关联太多的表"><a href="#避免使用JOIN关联太多的表" class="headerlink" title="避免使用JOIN关联太多的表"></a><strong>避免使用JOIN关联太多的表</strong></h4><p>《阿里巴巴Java开发手册》规定不要join超过三张表，第一join太多降低查询的速度，第二join的buffer会占用更多的内存。</p>
<p>如果不可避免要join多张表，可以考虑使用数据异构的方式异构到ES中查询。</p>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><h4 id="利用索引扫描做排序"><a href="#利用索引扫描做排序" class="headerlink" title="利用索引扫描做排序"></a><strong>利用索引扫描做排序</strong></h4><p>MySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的</p>
<p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢</p>
<p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行</p>
<p>例如：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">--建立索引（date,staff_id,customer_id）</span>
<span class="token keyword">select</span> staff_id<span class="token punctuation">,</span> customer_id <span class="token keyword">from</span> test <span class="token keyword">where</span> <span class="token keyword">date</span> <span class="token operator">=</span> <span class="token string">'2010-01-01'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> staff_id<span class="token punctuation">,</span>customer_id<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>

<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序</p>
<h3 id="UNION优化"><a href="#UNION优化" class="headerlink" title="UNION优化"></a>UNION优化</h3><h4 id="条件下推"><a href="#条件下推" class="headerlink" title="条件下推"></a><strong>条件下推</strong></h4><p>MySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引</p>
<p>最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化</p>
<p>此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高。</p>
<h2 id="怎么看执行计划（explain），如何理解其中各个字段的含义？"><a href="#怎么看执行计划（explain），如何理解其中各个字段的含义？" class="headerlink" title="怎么看执行计划（explain），如何理解其中各个字段的含义？"></a>怎么看执行计划（explain），如何理解其中各个字段的含义？</h2><p>explain是sql优化的利器，除了优化慢sql，平时的sql编写，也应该先explain，查看一下执行计划，看看是否还有优化的空间。</p>
<p>直接在 select 语句之前增加explain关键字，就会返回执行计划的信息。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910140953658.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910140953658"></p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910141026496.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910141026496"></p>
<p><strong>1. id</strong> 列：MySQL会为每个select语句分配一个唯一的id值<br><strong>2. select_type</strong> 列，查询的类型，根据关联、union、子查询等等分类，常见的查询类型有SIMPLE、PRIMARY。<br><strong>3. table</strong> 列：表示 explain 的一行正在访问哪个表。<br><strong>4. type</strong> 列：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。<br>性能从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt;index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<ul>
<li>system： 当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快</li>
<li>const：表示查询时命中 primary key 主键或者 unique 唯一索引，或者被连接的部分是一个常量(const)值。这类扫描效率极高，返回数据量少，速度非常快。</li>
<li>eq_ref：查询时命中主键primary key 或者 unique key索引， type 就是eq_ref。</li>
<li>ref_or_null：这种连接类型类似于 ref，区别在于 MySQL会额外搜索包含NULL值的行。</li>
<li>index_merge：使用了索引合并优化方法，查询使用了两个以上的索引。</li>
<li>unique_subquery：替换下面的 IN子查询，子查询返回不重复的集合。</li>
<li>index_subquery：区别于unique_subquery，用于非唯一索引，可以返回重复值。</li>
<li>range：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在where语句中使用<br>bettween…and、&lt;、&gt;、&lt;=、in 等条件查询 type 都是 range。</li>
<li>index：Index 与ALL 其实都是读全表，区别在于index是遍历索引树读取，而ALL是从硬盘中读取。</li>
<li>ALL:就不用多说了，全表扫描。</li>
</ul>
<p><strong>5. possible_keys</strong> 列：显示查询可能使用哪些索引来查找，使用索引优化sql的时候比较重要。<br><strong>6. key</strong> 列：这一列显示 mysql 实际采用哪个索引来优化对该表的访问，判断索引是否失效的时候常用。<br><strong>7. key_len</strong> 列：显示了 MySQL使用<br><strong>8. ref</strong> 列：ref 列展示的就是与索引列作等值匹配的值，常见的有：const（常量），func，NULL，字段名。<br><strong>9. rows</strong> 列：这也是一个重要的字段，MySQL查询优化器根据统计信息，估算SQL要查到结果集需要扫描读取的数据行数，这个值非常直观显示SQL的效率好坏，原则上rows越少越好。<br><strong>10. Extra</strong> 列：显示不适合在其它列的额外信息，虽然叫额外，但是也有一些重要的信息：</p>
<ul>
<li>Using index：表示MySQL将使用覆盖索引，以避免回表</li>
<li>Using where：表示会在存储引擎检索之后再进行过滤</li>
<li>Using temporary ：表示对查询结果排序时会使用一个临时表。</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h1><h2 id="何为索引？有什么作用？"><a href="#何为索引？有什么作用？" class="headerlink" title="何为索引？有什么作用？"></a>何为索引？有什么作用？</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p>
<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p><strong>优点</strong> ：</p>
<ul>
<li><p>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</p>
</li>
<li><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li><p>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</p>
</li>
<li><p>索引需要使用物理文件存储，也会耗费一定空间。</p>
</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h2 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">hash <span class="token operator">=</span> <span class="token function">hashfunc</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
index <span class="token operator">=</span> hash <span class="token operator">%</span> array_size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>

<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910145551358.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910145551358"></p>
<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后HashMap为了减少链表过长的时候搜索时间过长引入了红黑树。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910145623148.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910145623148"></p>
<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>
<p>既然哈希表这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p>
<p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p>
<p>试想一种情况:</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> tb1 <span class="token keyword">WHERE</span> id <span class="token operator">&lt;</span> <span class="token number">500</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>
<h3 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h3><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910165413911.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="B+"></p>
<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li><p>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p>
</li>
<li><p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p>
</li>
<li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p>
</li>
</ul>
<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>
<p><strong>MyISAM</strong> 引擎中，B+Tree 叶节点的 data 域存放的是<strong>数据记录的地址</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引</strong>”。</p>
<p><strong>InnoDB</strong> 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 <strong>data 域保存了完整的数据记录</strong>。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（或聚集索引）</strong>”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h3 id="那一棵B-树能存储多少条数据呢？"><a href="#那一棵B-树能存储多少条数据呢？" class="headerlink" title="那一棵B+树能存储多少条数据呢？"></a><strong>那一棵B+树能存储多少条数据呢？</strong></h3><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910172522706.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910172522706"></p>
<p>假设索引字段是 bigint 类型，长度为 8 字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。非叶子节点(一页)可以存储 16384/14=1170 个这样的 单元(键值+指针)，代表有 1170 个指针。</p>
<p>树深度为 2 的时候，有 1170^2 个叶子节点，可以存储的数据为 <strong>1170 * 1170 *16=</strong> <strong>21902400</strong> 。</p>
<p>在查找数据时一次页的查找代表一次 IO，也就是说，一张 2000 万左右的表，查询数据最多需要访问 3 次磁盘。</p>
<p>所以在 InnoDB 中 B+ 树深度一般为 <strong>1-3 层</strong>，它就能满足千万级的数据存储。</p>
<h3 id="为什么要用-B-树，而不用普通二叉树？"><a href="#为什么要用-B-树，而不用普通二叉树？" class="headerlink" title="为什么要用 B+ 树，而不用普通二叉树？"></a><strong>为什么要用 B+ 树，而不用普通二叉树？</strong></h3><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数。</p>
<p><strong>为什么不用普通二叉树？</strong></p>
<p>普通二叉树存在退化的情况，如果它退化成链表，相当于全表扫描。平衡二叉树相比于二叉</p>
<p>查找树来说，查找效率更稳定，总体的查找速度也更快。</p>
<p><strong>为什么不用平衡二叉树呢？</strong></p>
<p>读取数据的时候，是从磁盘读到内存。如果树这种数据结构作为索引，那每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是 B+ 树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快。</p>
<h3 id="为什么用-B-树而不用-B-树呢？"><a href="#为什么用-B-树而不用-B-树呢？" class="headerlink" title="为什么用 B+ 树而不用 B 树呢？"></a>为什么用 B+ 树而不用 B 树呢？</h3><p>B+相比较B树，有这些优势：</p>
<ul>
<li>它是 B Tree 的变种，B Tree 能解决的问题，它都能解决。<br>B Tree 解决的两大问题：<strong>每个节点存储更多关键字；路数更多</strong></li>
<li><strong>扫库、扫表能力更强</strong><br>如果我们要对表进行全表扫描，只需要遍历叶子节点就可以 了，不需要遍历整棵 B+Tree拿到所有的数据。</li>
<li>B+Tree 的磁盘读写能力相对于 B Tree 来说更强，<strong>IO次数更少</strong><br>根节点和枝节点不保存数据区， 所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多，IO次数更少。</li>
<li><strong>排序能力更强</strong><br>因为叶子节点上有下一个数据区的指针，数据形成了<strong>链表</strong>。</li>
<li><strong>效率更加稳定</strong><br>B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的。</li>
</ul>
<h3 id="Hash-索引和-B-树索引区别是什么？"><a href="#Hash-索引和-B-树索引区别是什么？" class="headerlink" title="Hash 索引和 B+ 树索引区别是什么？"></a>Hash 索引和 B+ 树索引区别是什么？</h3><ul>
<li>B+ 树可以进行范围查询，Hash 索引不能。</li>
<li>B+ 树支持联合索引的最左侧原则，Hash 索引不支持。</li>
<li>B+ 树支持 order by 排序，Hash 索引不支持。</li>
<li>Hash 索引在等值查询上比 B+ 树效率更高。</li>
<li>B+ 树使用 like 进行模糊查询的时候，like 后面（比如 % 开头）的话可以起到优化的作</li>
<li>用，Hash 索引根本无法进行模糊查询。</li>
</ul>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910164140079.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910164140079"></p>
<h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910150438065.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910150438065"></p>
<h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<p><strong>PS:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</strong></p>
<ul>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ul>
<p>二级索引:</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910151114591.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="二级索引"></p>
<h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>首先理解聚簇索引不是一种新的索引，而是而是一种 数据存储方式 。 聚簇表示数据行和相邻的键值紧凑地存储在一起。我们熟悉的两种存储引擎——MyISAM采用的是非聚簇索引，InnoDB采用的是聚簇索引。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910202911377.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910202911377"></p>
<p>可以这么说：</p>
<ul>
<li>索引的数据结构是树，聚簇索引的索引和数据存储在一棵树上，树的叶子节点就是数据，非聚簇索引索引和数据不在一棵树上。</li>
<li>一个表中只能拥有一个聚簇索引，而非聚簇索引一个表可以存在多个。</li>
<li>聚簇索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</li>
<li>聚簇索引：物理存储按照索引排序；非聚簇索引：物理存储不按照索引排序；</li>
</ul>
<h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>在InnoDB存储引擎里，利用辅助索引查询，先通过辅助索引找到主键索引的键值，再通过主键值查出主键索引里面没有符合要求的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。</p>
<p>例如:*<em>select * from user where name = ‘张三’;*</em></p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910203254480.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910203254480"></p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用辅助索引中就能够取得，不用去查主键索引，这时候使用的索引就叫做覆盖索引，避免了回表。</p>
<p>比如，<strong>select name from user where name = ‘张三’;</strong></p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910203424203.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910203424203"></p>
<h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p>
<h2 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h2><p>注意：最左前缀原则、最左匹配原则、最左前缀匹配原则这三个都是一个概念。</p>
<p><strong>最左匹配原则</strong> ：在InnoDB的联合索引中，查询的时候只有匹配了前一个/左边的值之后，才能匹配下一个。</p>
<p>根据最左匹配原则，我们创建了一个组合索引，如 (a1,a2,a3)，相当于创建了（a1）、(a1,a2)和 (a1,a2,a3) 三个索引。</p>
<p>为什么不从最左开始查，就无法匹配呢？</p>
<p>比如有一个user表，我们给 name 和 age 建立了一个组合索引。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token keyword">user</span> <span class="token keyword">add</span> <span class="token keyword">INDEX</span> comidx_name_phone <span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>组合索引在 B+Tree 中是复合的数据结构，它是按照从左到右的顺序来建立搜索树的 (name 在左边，age 在右边)。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910203812088.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910203812088"></p>
<p>从这张图可以看出来，name 是有序的，age 是无序的。当 name 相等的时候， age 才是有序的。</p>
<p>这个时候我们使用where name= ‘张三‘ and age = ‘20 ‘去查询数据的时候， B+Tree 会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。如果 name 相同的时候再比较age。但是如果查询条件没有 name，就不知道下一步应该查哪个 节点，因为建立搜索树的<br>时候 name 是第一个比较因子，所以就没用上索引。</p>
<h2 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化"></a>索引下推优化</h2><p>索引条件下推优化（<strong>Index Condition Pushdown (ICP)</strong> ）是MySQL5.6添加的，用于优化数据查询。</p>
<ul>
<li>不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL Server，MySQL Server进行过滤条件的判断。</li>
<li>当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL Server将这一部分判断条件下推给存储引擎，然后由存储引擎通过判断索引是否符合MySQLServer传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。</li>
</ul>
<p>例如一张表，建了一个联合索引（name, age），查询语句：*<em>select * from t_user where name like ‘张%’ and age=10*</em>;，由于name使用了范围查询，根据最左匹配原则：</p>
<p>不使用ICP，引擎层查找到name like ‘张%’的数据，再由Server层去过滤age=10这个条件，这样一来，就回表了两次，浪费了联合索引的另外一个字段age。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910205005074.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910205005074"></p>
<p>但是，使用了索引下推优化，把where的条件放到了引擎层执行，直接根据name like ‘张%’ and age=10的条件进行过滤，减少了回表的次数。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910205110920.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910205110920"></p>
<p>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p>
<h2 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h2><p><strong>1.选择合适的字段创建索引：</strong></p>
<ul>
<li><p><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</p>
</li>
<li><p><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</p>
</li>
<li><p><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p>
</li>
<li><p><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p>
</li>
<li><p><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p>
</li>
</ul>
<p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<p><strong>4.注意避免冗余索引</strong> 。</p>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h2 id="索引哪些情况下会失效呢"><a href="#索引哪些情况下会失效呢" class="headerlink" title="索引哪些情况下会失效呢"></a>索引哪些情况下会失效呢</h2><ul>
<li>查询条件包含<strong>or</strong>，可能导致索引失效</li>
<li>如果字段类型是字符串，where时一定用引号括起来，否则会因为<strong>隐式类型转换</strong>，索引失效</li>
<li><strong>like通配符</strong>可能导致索引失效。</li>
<li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li>
<li>在索引列上使用mysql的<strong>内置函数</strong>，索引失效。</li>
<li>对<strong>索引列运算</strong>（如，+、-、*、/），索引失效。</li>
<li>索引字段上使用（<strong>！=</strong> 或者 <strong>&lt; &gt;，not in</strong>）时，可能会导致索引失效。</li>
<li>索引字段上使用<strong>is null， is not null</strong>，可能导致索引失效。</li>
<li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li>
<li>MySQL优化器估计使用全表扫描要比使用索引快,则不使用索引。</li>
</ul>
<h2 id="MySQL-如何为表字段添加索引？"><a href="#MySQL-如何为表字段添加索引？" class="headerlink" title="MySQL 如何为表字段添加索引？"></a>MySQL 如何为表字段添加索引？</h2><p>1.添加 PRIMARY KEY（主键索引）</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span> <span class="token identifier"><span class="token punctuation">`</span>column<span class="token punctuation">`</span></span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>2.添加 UNIQUE(唯一索引)</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">UNIQUE</span> <span class="token punctuation">(</span> <span class="token identifier"><span class="token punctuation">`</span>column<span class="token punctuation">`</span></span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>3.添加 INDEX(普通索引)</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span> <span class="token identifier"><span class="token punctuation">`</span>column<span class="token punctuation">`</span></span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>4.添加 FULLTEXT(全文索引)</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> FULLTEXT <span class="token punctuation">(</span> <span class="token identifier"><span class="token punctuation">`</span>column<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>5.添加多列索引</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>table_name<span class="token punctuation">`</span></span> <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span> <span class="token identifier"><span class="token punctuation">`</span>column1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>column2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>column3<span class="token punctuation">`</span></span> <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910205630795.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910205630795"></p>
<p>如果按锁粒度划分，有以下 3 种：</p>
<ul>
<li>表锁： 开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。</li>
<li>行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</li>
<li>页锁： 开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li>
</ul>
<p>如果按照兼容性，有两种，</p>
<ul>
<li>共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。</li>
<li>排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。</li>
</ul>
<h2 id="InnoDB里的行锁实现"><a href="#InnoDB里的行锁实现" class="headerlink" title="InnoDB里的行锁实现"></a>InnoDB里的行锁实现</h2><p>我们拿这么一个用户表来表示行级锁，其中插入了 4 行数据，主键值分别是1,6,8,12，现在简化它的聚簇索引结构，只保留数据记录。</p>
<p><img src="./%E9%9D%A2%E8%AF%95-MySQL/image-20220910214409739.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910214409739"></p>
<p>InnoDB的行锁的主要实现如下：</p>
<ul>
<li><strong>Record Lock 记录锁</strong></li>
</ul>
<p>记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如*<em>select * from t where id =6 for update*</em>;就会将id=6的记录锁定。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910214828711.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910214828711"></p>
<ul>
<li><strong>Gap Lock 间隙锁</strong></li>
</ul>
<p>间隙锁(Gap Locks) 的间隙指的是两个记录之间逻辑上尚未填入数据的部分,是一个<strong>左开右开空间</strong> 。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910214941003.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910214941003"></p>
<p>间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个record，此时就会将对应的间隙区间锁定。例如<strong>select * from t where id =3 for update**;或者**select * from t where id &gt; 1 and id &lt; 6 for update</strong>;就会将(1,6)区间锁定。</p>
<ul>
<li><strong>Next-key Lock 临键锁</strong></li>
</ul>
<p>临键指的是间隙加上它右边的记录组成的 <strong>左开右闭区间</strong> 。比如上述的(1,6]、(6,8]等。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910215510444.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910215510444"></p>
<p>临键锁就是<strong>记录锁(Record Locks)**和</strong>间隙锁(Gap Locks)<strong>的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分</strong>record<strong>记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个</strong>record*<em>的右边的临键区间。例如<br>**select * from t where id &gt; 5 and id &lt;= 7*</em> for update;会锁住**(4,7]、(7,+∞)**。</p>
<p><strong>mysql</strong>默认行锁类型就是临键锁(<strong>Next-Key Locks</strong>)。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(<strong>Next-Key Locks</strong>)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。</p>
<p><strong>间隙锁(Gap Locks)**和</strong>临键锁(Next-Key Locks)<strong>都是用来解决</strong>幻读问题**的，在已提交读（READ COMMITTED）隔离级别下，间隙锁(Gap Locks)和临键锁(Next-Key Locks)都会失效！</p>
<p>上面是行锁的三种实现算法，除此之外，在行上还存在插入意向锁。</p>
<ul>
<li><strong>Insert Intention Lock 插入意向锁</strong></li>
</ul>
<p>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了意向锁 ，如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某个 间隙 中插入新记录，但是现在在等待。这种类型的锁命名为 <strong>Insert Intention Locks</strong> ，也就是<strong>插入意向锁</strong> 。</p>
<p>假如我们有个<strong>T1事务</strong>，给(1,6)区间加上了<strong>意向锁</strong>，现在有个<strong>T2事务</strong>，要插入一个数据，id为4 ，它会获取一个（1,6）区间的插入意向锁，又有有个T3事务，想要插入一个数据，id为 3 ，它也会获取一个（1,6）区间的插入意向锁，但是，这两个插入意向锁锁不会互斥。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220910222457105.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220910222457105"></p>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>意向锁是一个<strong>表级锁</strong>，不要和插入意向锁搞混。</p>
<p>意向锁的出现是为了支持InnoDB的多粒度锁，<strong>它解决的是表锁和行锁共存的问题</strong>。</p>
<p>当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。</p>
<p>假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；</p>
<p>有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。</p>
<p>有了意向锁之后，要执行的事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务B申请表的互斥锁时会被阻塞。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911123822324.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911123822324"></p>
<h2 id="MySQL的乐观锁和悲观锁"><a href="#MySQL的乐观锁和悲观锁" class="headerlink" title="MySQL的乐观锁和悲观锁"></a>MySQL的乐观锁和悲观锁</h2><ul>
<li><strong>悲观锁（Pessimistic Concurrency Control）</strong></li>
</ul>
<p>悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</p>
<p>数据库中的<strong>行锁，表锁，读锁，写锁</strong>均为悲观锁。</p>
<ul>
<li><strong>乐观锁（Optimistic Concurrency Control）</strong></li>
</ul>
<p>乐观锁认为数据的变动不会太频繁。</p>
<p>乐观锁通常是通过在表中增加一个**版本(version)或时间戳(timestamp)**来实现，其中，版本最为常用。</p>
<p>事务在从数据库中取数据时，会将该数据的版本也取出来(v1)，当事务对数据变动完毕想要将其更新到表中时，会将之前取出的版本v1与数据中最新的版本v2相对比，如果v1=v2，那么说明在数据变动期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时version会加 1 ，以此来表明数据已被变动。</p>
<p>如果，v1不等于v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。</p>
<h2 id="MySQL-死锁问题"><a href="#MySQL-死锁问题" class="headerlink" title="MySQL 死锁问题"></a>MySQL 死锁问题</h2><p>排查死锁的一般步骤是这样的：</p>
<ul>
<li>（ 1 ）查看死锁日志 show engine innodb status;</li>
<li>（ 2 ）找出死锁 sql</li>
<li>（ 3 ）分析 sql 加锁情况</li>
<li>（ 4 ）模拟死锁案发</li>
<li>（ 5 ）分析死锁日志</li>
<li>（ 6 ）分析死锁结果</li>
</ul>
<p>当然，这只是一个简单的流程说明，实际上生产中的死锁千奇百怪，排查和解决起来没那么简单</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="MySQL-事务的四大特性"><a href="#MySQL-事务的四大特性" class="headerlink" title="MySQL 事务的四大特性"></a>MySQL 事务的四大特性</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911152256595.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911152256595"></p>
<ul>
<li><strong>原子性</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li><strong>一致性</strong>：指在事务开始之前和事务结束以后，数据不会被破坏，假如 A 账户给 B 账户转10 块钱，不管成功与否，A 和 B 的总金额是不变的。</li>
<li><strong>隔离性</strong>：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。</li>
<li><strong>持久性</strong>：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li>
</ul>
<h2 id="那ACID靠什么保证的呢？"><a href="#那ACID靠什么保证的呢？" class="headerlink" title="那ACID靠什么保证的呢？"></a>那ACID靠什么保证的呢？</h2><ul>
<li>事务的隔离性是通过数据库锁的机制实现的。</li>
<li>事务的一致性由undo log来保证：undo log是逻辑日志，记录了事务的insert、update、delete操作，回滚的时候做相反的delete、update、insert操作来恢复数据。</li>
<li>事务的原子性和持久性由redo log来保证：redolog被称作重做日志，是物理日志，事务提交的时候，必须先将事务的所有日志写入redo log持久化，到事务的提交操作才算完成。</li>
</ul>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911152812313.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911152812313"></p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911153038317.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911153038317"></p>
<ul>
<li><strong>读未提交（Read Uncommitted）</strong></li>
<li><strong>读已提交（Read Committed）</strong></li>
<li><strong>可重复读（Repeatable Read）</strong></li>
<li><strong>串行化（Serializable）</strong></li>
</ul>
<p>MySQL默认的事务隔离级别是**可重复读 (Repeatable Read)**。</p>
<h2 id="幻读，脏读，不可重复读"><a href="#幻读，脏读，不可重复读" class="headerlink" title="幻读，脏读，不可重复读"></a>幻读，脏读，不可重复读</h2><ul>
<li>事务 A、B 交替执行，事务 A 读取到事务 B 未提交的数据，这就是脏读。</li>
<li>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。</li>
<li>事务 A 查询一个范围的结果集，另一个并发事务 B 往这个范围中插入 / 删除了数据，并静悄悄地提交，然后事务 A 再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。</li>
</ul>
<p>不同的隔离级别，在并发事务下可能会发生的问题：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911154336548.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911154336548"></p>
<p><strong>不可重复读和幻读有什么区别呢？</strong></p>
<ul>
<li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li>
<li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li>
</ul>
<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p>
<p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p>
<h2 id="事务的各个隔离级别的实现"><a href="#事务的各个隔离级别的实现" class="headerlink" title="事务的各个隔离级别的实现"></a>事务的各个隔离级别的实现</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>读未提交，就不用多说了，采取的是<strong>读不加锁原理</strong>。</p>
<ul>
<li>事务读不加锁，不阻塞其他事务的读和写</li>
<li>事务写阻塞其他事务写，但不阻塞其他事务读；</li>
</ul>
<h3 id="读取已提交-amp-可重复读"><a href="#读取已提交-amp-可重复读" class="headerlink" title="读取已提交&amp;可重复读"></a>读取已提交&amp;可重复读</h3><p>读取已提交和可重复读级别利用了<strong>ReadView和MVCC</strong>，也就是每个事务只能读取它能看到的<br>版本（ReadView）。</p>
<ul>
<li><strong>READ COMMITTED</strong>：每次读取数据前都生成一个ReadView</li>
<li><strong>REPEATABLE READ</strong> ： 在第一次读取数据时生成一个ReadView串行化</li>
</ul>
<h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>串行化的实现采用的是<strong>读写都加锁</strong>的原理。</p>
<p>串行化的情况下，对于同一行事务，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：<strong>select … lock in share mode(共享锁)**，</strong>select … for update、update、insert、delete(排他锁)**都是一种当前读。</p>
<p>测试：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911175944047.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911175944047"></p>
<p>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内 容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们 加排他锁的时候，也是当前读操作。</p>
<h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>简单的select（不加锁）就是快照读，快照读，读取的是<strong>记录数据的可见版本</strong>，有可能是<strong>历史数据</strong>， 不加锁，是非阻塞读。</p>
<ul>
<li> <strong>Read Committed</strong>：每次select，都生成一个快照读。</li>
<li> <strong>Repeatable Read</strong>：开启事务后第一个select语句才是快照读的地方。</li>
<li> <strong>Serializable</strong>：快照读会退化为当前读。</li>
</ul>
<p>测试:</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911180508766.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911180508766"></p>
<p>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照 读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同 的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p>
<h4 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h4><p>全称 Multi-Version Concurrency Control，<strong>多版本并发控制</strong>。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的<strong>三个隐式字段、undo log日志、readView</strong>。</p>
<h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911180815226.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911180815226"></p>
<p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了 这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911180839960.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911180839960"></p>
<p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键， 如果有主键，则不会添加该隐藏字段。</p>
<h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。 </p>
<h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><p>有一张表原始数据为：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191234515.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911191234515"></p>
<ul>
<li><strong>DB_TRX_ID</strong> : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是 自增的。</li>
<li><strong>DB_ROLL_PTR</strong> ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</li>
</ul>
<p>然后，有四个并发事务同时在访问这张表。</p>
<p>A. 第一步</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191339478.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911191339478"></p>
<p>当事务2执行第一条修改语句时，会记录<strong>undo log</strong>日志，记录数据变更之前的样子; 然后更新记录， 并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191424281.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911191424281"></p>
<p>B.第二步</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191456083.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911191456083"></p>
<p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191614690.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911191614690"></p>
<p>C. 第三步</p>
<p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191648058.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911191648058"></p>
<p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p>
<h4 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h4><p><strong>ReadView（读视图）</strong>是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p>
<p>ReadView中包含了四个核心字段：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911191829890.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911191829890"></p>
<p>而在<strong>readview</strong>中就规定了版本链数据的访问规则： <strong>trx_id 代表当前undolog版本链对应事务ID</strong>。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911192407624.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911192407624"></p>
<p>不同的隔离级别，生成<strong>ReadView</strong>的时机不同： </p>
<ul>
<li><strong>READ COMMITTED</strong> ：在事务中<strong>每一次</strong>执行快照读时生成ReadView。 </li>
<li><strong>REPEATABLE READ</strong>：仅在事务中<strong>第一次</strong>执行快照读时生成ReadView，后续复用该ReadView。</li>
</ul>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="RC隔离级别"><a href="#RC隔离级别" class="headerlink" title="RC隔离级别"></a>RC隔离级别</h4><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p>
<p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的? 在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读 都会生成一个ReadView，那么两次生成的ReadView如下。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911192724348.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911192724348"></p>
<p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则， 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p>
<p>A. 先来看第一次快照读具体的读取过程：</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911192812721.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911192812721"></p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911192833689.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911192833689"></p>
<p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p>
<ul>
<li>先匹配<img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193540427.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911193540427" style="zoom:25%;" />这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li>
<li>再匹配第二条<img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193723009.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911193723009" style="zoom:25%;" />，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也 不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li>
<li>再匹配第三条<img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193756104.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911193756104" style="zoom:25%;" />，这条记 录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照 读，返回的数据就是版本链中记录的这条数据。</li>
</ul>
<p>B. 再来看第二次快照读具体的读取过程:</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193850811.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911193850811"></p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911193905500.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911193905500"></p>
<p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p>
<ul>
<li>先匹配<img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911194012918.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911194012918" style="zoom:25%;" />这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li>
<li>再匹配第二条<img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911194036373.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911194036373" style="zoom:25%;" />，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次 快照读，返回的数据就是版本链中记录的这条数据。</li>
</ul>
<h4 id="RR隔离级别"><a href="#RR隔离级别" class="headerlink" title="RR隔离级别"></a>RR隔离级别</h4><p>RR隔离级别下，仅在事务中第一次执行快照读时生成<strong>ReadView</strong>，后续<strong>复用该ReadView</strong>。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p>
<p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911194218075.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911194218075"></p>
<p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返 回的结果也是一样的。</p>
<p>所以呢，MVCC的实现原理就是通过 <strong>InnoDB表的隐藏字段、UndoLog 版本链、ReadView</strong>来实现的。 而<strong>MVCC + 锁</strong>，则实现了事务的隔离性。 而<strong>一致性则是由redolog 与 undolog保证</strong>。</p>
<p><img src=".//%E9%9D%A2%E8%AF%95-MySQL/image-20220911194425916.png" srcset="/WeiShao-996.github.io/img/loading.gif" lazyload alt="image-20220911194425916"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/WeiShao-996.github.io/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/WeiShao-996.github.io/tags/%E9%9D%A2%E8%AF%95/">#面试</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试-Mysql</div>
      <div>https://weishao-996.github.io/2022/09/08/面试-MySQL/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wei Shao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月8日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/WeiShao-996.github.io/2022/09/12/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/" title="面试-Java容器">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面试-Java容器</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/WeiShao-996.github.io/2022/09/06/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/" title="面试-Java基础">
                        <span class="hidden-mobile">面试-Java基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-left: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="面试"
        id="heading-1573c74e227f14ded2daa71bb049ecda" role="tab" data-toggle="collapse" href="#collapse-1573c74e227f14ded2daa71bb049ecda"
        aria-expanded="true"
      >
        面试
        <span class="list-group-count">(6)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-1573c74e227f14ded2daa71bb049ecda"
           role="tabpanel" aria-labelledby="heading-1573c74e227f14ded2daa71bb049ecda">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/WeiShao-996.github.io/2022/09/06/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/" title="面试-Java基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Java基础</span>
        </a>
      
    
      
      
        <a href="/WeiShao-996.github.io/2022/09/12/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/" title="面试-Java容器"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Java容器</span>
        </a>
      
    
      
      
        <a href="/WeiShao-996.github.io/2022/09/02/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="面试-Java并发编程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Java并发编程</span>
        </a>
      
    
      
      
        <a href="/WeiShao-996.github.io/2022/08/31/%E9%9D%A2%E8%AF%95-Mybatis/" title="面试-Mybatis"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Mybatis</span>
        </a>
      
    
      
      
        <a href="/WeiShao-996.github.io/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL/" title="面试-Mysql"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">面试-Mysql</span>
        </a>
      
    
      
      
        <a href="/WeiShao-996.github.io/2022/08/29/%E9%9D%A2%E8%AF%95-Spring/" title="面试-Spring"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Spring</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/WeiShao-996.github.io/js/events.js" ></script>
<script  src="/WeiShao-996.github.io/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/WeiShao-996.github.io/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/WeiShao-996.github.io/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/WeiShao-996.github.io/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
