

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/bg/%E7%83%A4%E9%B8%A1.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wei Shao">
  <meta name="keywords" content="">
  
    <meta name="description" content="基础使用多线程的意义先从总体上来说：  从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。  从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以">
<meta property="og:type" content="article">
<meta property="og:title" content="面试-Java并发编程">
<meta property="og:url" content="https://weishao-996.github.io/2022/09/02/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="WeiBlog">
<meta property="og:description" content="基础使用多线程的意义先从总体上来说：  从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。  从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114109343.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114143558.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140118921.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140459345.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141434005.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141608203.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902145605462.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160048587.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160358011.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160517970.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160908374.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2019-4%E6%AD%BB%E9%94%811.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918115033820.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902163020732.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902170811800.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902173027266.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902193325147.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902194739313.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902212750305.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213343066.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213432939.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114356751.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114449779.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903115952545.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133213700.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133644636.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134841710.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134956909.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903135524735.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140353177.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140503354.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140518029.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903180902786.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903181654514.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190305715.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190457240.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903215849935.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903221140669.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904142059373.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904142838070.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904163310518.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904165058873.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904165133380.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904165250668.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904184232357.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904184726138.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904192625392.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904223156739.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904223443822.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918121651211.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918121920193.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918122012568.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918122033551.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918135430290.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918135520635.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918142156123.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918142311472.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918142854632.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918143618945.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918152257483.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918144833661.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918145055227.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918160628630.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918161137672.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918161756915.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918162414278.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918162917701.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918163436617.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918184846167.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918185038624.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918191909826.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918191935001.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918192126850.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918192216120.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918205234717.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918205449640.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918215540646.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918220618330.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920095255427.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920095502269.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920131528319.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920131709222.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920131947647.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920132118614.png">
<meta property="og:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920132354314.png">
<meta property="og:image" content="https://weishao-996.github.io/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920134119485.png">
<meta property="article:published_time" content="2022-09-02T03:30:31.000Z">
<meta property="article:modified_time" content="2022-10-08T05:04:24.000Z">
<meta property="article:author" content="Wei Shao">
<meta property="article:tag" content="Java并发编程">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://weishao-996.github.io/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114109343.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>面试-Java并发编程 - WeiBlog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"weishao-996.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"Java"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>威少のBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/bg/iTab-6ozkzl.jfif') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试-Java并发编程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-02 11:30" pubdate>
          2022年9月2日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试-Java并发编程</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="使用多线程的意义"><a href="#使用多线程的意义" class="headerlink" title="使用多线程的意义"></a>使用多线程的意义</h2><p>先从总体上来说：</p>
<ul>
<li><p><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p>
</li>
<li><p><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而<strong>多线程并发编程</strong>正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p>
</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><p><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</p>
</li>
<li><p><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</p>
</li>
</ul>
<h2 id="使用多线程带来的问题"><a href="#使用多线程带来的问题" class="headerlink" title="使用多线程带来的问题"></a>使用多线程带来的问题</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。</p>
<h2 id="并行跟并发"><a href="#并行跟并发" class="headerlink" title="并行跟并发"></a>并行跟并发</h2><p>从操作系统的角度来看，线程是CPU分配的最小单位。</p>
<ul>
<li>并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。</li>
<li>并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114109343.png" srcset="/img/loading.gif" lazyload alt="image-20220902114109343"></p>
<p>就好像我们去食堂打饭，并行就是我们在多个窗又排队，几个阿姨同时打菜；并发就是我们挤在一个窗又，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114143558.png" srcset="/img/loading.gif" lazyload alt="image-20220902114143558"></p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>要说线程，必须得先说说进程。</p>
<ul>
<li>进程：进程是代码在数据集合上的一次运行活动，是<strong>系统进行资源分配和调度的基本单位</strong>。</li>
<li>线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</li>
</ul>
<p>操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。</p>
<p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p>
<p>一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140118921.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><p>Java中创建线程主要有三种方式，分别为继承<strong>Thread</strong>类、实现<strong>Runnable</strong>接口、实现<strong>Callable</strong>接口。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140459345.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><h3 id="继承Thread类，重写run-方法，调用start-方法启动线程"><a href="#继承Thread类，重写run-方法，调用start-方法启动线程" class="headerlink" title="继承Thread类，重写run()方法，调用start()方法启动线程"></a>继承Thread类，重写run()方法，调用start()方法启动线程</h3></li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">/**

    继承Thread类
    */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"This is child thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<ul>
<li><h3 id="实现-Runnable-接口，重写run-方法"><a href="#实现-Runnable-接口，重写run-方法" class="headerlink" title="实现 Runnable 接口，重写run()方法"></a>实现 Runnable 接口，重写run()方法</h3></li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunnableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Runnable!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">RunnableTask</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunnableTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？</p>
<ul>
<li><h3 id="实现Callable接又，重写call-方法，这种方式可以通过FutureTask获取任务执行的返回值"><a href="#实现Callable接又，重写call-方法，这种方式可以通过FutureTask获取任务执行的返回值" class="headerlink" title="实现Callable接又，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值"></a>实现Callable接又，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值</h3></li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallerTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
    	<span class="token keyword">return</span> <span class="token string">"Hello,i am running!"</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">//创建异步任务</span>
                <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> task<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CallerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//启动线程</span>
                <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">//等待执行完成，并获取返回结果</span>
                <span class="token class-name">String</span> result<span class="token operator">=</span>task<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h3 id="为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？"><a href="#为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？" class="headerlink" title="为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？"></a>为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？</h3><p>JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141434005.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>为什么我们不能直接调用run()方法？</strong> 也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。</p>
<h2 id="线程的调度方法"><a href="#线程的调度方法" class="headerlink" title="线程的调度方法"></a>线程的调度方法</h2><p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141608203.png" srcset="/img/loading.gif" lazyload alt="image-20220902141608203"></p>
<h3 id="线程等待与通知"><a href="#线程等待与通知" class="headerlink" title="线程等待与通知"></a>线程等待与通知</h3><p>在Object类中有一些函数可以用于线程的等待与通知。</p>
<ul>
<li><p>**wait()**：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：</p>
<ul>
<li><p>（ 1 ） 线程A调用了共享对象 notify()或者 notifyAll()方法；</p>
</li>
<li><p>（ 2 ）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</p>
</li>
</ul>
</li>
<li><p><strong>wait(long timeout)</strong> ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。</p>
</li>
<li><p>**wait(long timeout, int nanos)**，其内部调用的是 wait(long timout）函数。</p>
</li>
</ul>
<p>上面是线程等待的方法，而唤醒线程主要是下面两个方法：</p>
<ul>
<li><strong>notify()</strong> : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</li>
<li><strong>notifyAll()</strong> ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li>
</ul>
<p>Thread类也提供了一个方法用于等待的方法：</p>
<ul>
<li>**join()**：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。</li>
</ul>
<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul>
<li><strong>sleep(long millis)</strong> :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</li>
</ul>
<h3 id="让出优先权"><a href="#让出优先权" class="headerlink" title="让出优先权"></a>让出优先权</h3><ul>
<li><strong>yield()</strong> ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。</li>
</ul>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p>
<ul>
<li><strong>void interrupt()</strong> ：中断线程，例如，当线程A运行时，线程B可以调用钱程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。</li>
<li><strong>boolean isInterrupted() 方法</strong>： 检测当前线程是否被中断。</li>
<li><strong>boolean interrupted() 方法</strong>： 检测当前线程是否被中断，与 <strong>isInterrupted</strong> 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>在Java中，线程共有六种状态：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902145605462.png" srcset="/img/loading.gif" lazyload alt="image-20220902145605462"></p>
<p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160048587.png" srcset="/img/loading.gif" lazyload alt="image-20220902160048587"></p>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。<img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160358011.png" srcset="/img/loading.gif" lazyload alt="image-20220902160358011"></p>
<p>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160517970.png" srcset="/img/loading.gif" lazyload alt="image-20220902160517970"></p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ul>
<li>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。</li>
<li>在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。</li>
<li>那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。</li>
</ul>
<h2 id="线程间通信方式"><a href="#线程间通信方式" class="headerlink" title="线程间通信方式"></a>线程间通信方式</h2><p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160908374.png" srcset="/img/loading.gif" lazyload alt="image-20220902160908374"></p>
<h3 id="volatile和synchronized关键字"><a href="#volatile和synchronized关键字" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h3><ul>
<li><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p>
</li>
<li><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
</li>
</ul>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a><strong>等待/通知机制</strong></h3><ul>
<li>可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</li>
</ul>
<h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a><strong>管道输入/输出流</strong></h3><ul>
<li><p><strong>管道输入/输出流</strong>和<strong>普通的文件输入/输出流</strong>或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
</li>
<li><p>管道输入/输出流主要包括了如下 4 种具体实现：<strong>PipedOutputStream、PipedInputStream、PipedReader和PipedWriter</strong>，前两种面向字节，而后两种面向字符。</p>
</li>
</ul>
<h3 id="使用Thread-join"><a href="#使用Thread-join" class="headerlink" title="使用Thread.join()"></a>使用Thread.join()</h3><ul>
<li>如果一个线程A执行了<strong>thread.join()**语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了</strong>join(long millis)<strong>和</strong>join(long millis,int nanos)**两个具备超时特性的方法。</li>
</ul>
<h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><ul>
<li><p><strong>ThreadLocal</strong>，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p>
</li>
<li><p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
</li>
</ul>
<h2 id="sleep-方法和-wait-方法区别和共同点"><a href="#sleep-方法和-wait-方法区别和共同点" class="headerlink" title="sleep() 方法和 wait() 方法区别和共同点"></a>sleep() 方法和 wait() 方法区别和共同点</h2><ul>
<li><p>两者最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</p>
</li>
<li><p>两者都可以<strong>暂停线程</strong>的执行。</p>
</li>
<li><p><strong>wait()</strong> 通常被用于线程间交互/通信，<strong>sleep()</strong> 通常被用于暂停执行。</p>
</li>
<li><p><strong>wait()</strong> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <strong>notify()</strong> 或者 <strong>notifyAll()</strong> 方法。<strong>sleep()</strong> 方法执行完成后，线程会自动苏醒。或者可以使用 <strong>wait(long timeout)</strong> 超时后线程会自动苏醒。</p>
</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器主要有下面两个作用：</p>
<p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。<br>在多线程的情况下，<strong>程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>需要注意的是，如果执行的是 <strong>native</strong> 方法，那么程序计数器记录的是 <strong>undefined</strong> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，<strong>程序计数器私有主要是为了线程切换后能恢复到正确的执行位置</strong>。</p>
<h2 id="虚拟机栈和本地方法栈"><a href="#虚拟机栈和本地方法栈" class="headerlink" title="虚拟机栈和本地方法栈"></a>虚拟机栈和本地方法栈</h2><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个<strong>栈帧</strong>用于存储<strong>局部变量表、操作数栈、常量池</strong>引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是<strong>线程私有的</strong>。</p>
<h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2019-4%E6%AD%BB%E9%94%811.png" srcset="/img/loading.gif" lazyload alt="线程死锁示意图 "></p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 1</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 2</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>Output</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource1
<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource2
<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource2
<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>
<p>上面的例子符合产生死锁的四个必要条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h3><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<blockquote>
<p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p>
</blockquote>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>输出：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource1
<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource2
<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource2
<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource1
<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>waiting get resource2
<span class="token class-name">Thread</span><span class="token punctuation">[</span>线程 <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>main<span class="token punctuation">]</span>get resource2

<span class="token class-name">Process</span> finished <span class="token keyword">with</span> <span class="token namespace">exit</span> code <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h3 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a>死锁排查</h3><p>可以使用jk自带的命令行工具排查:</p>
<ul>
<li>使用<code>jps</code>查找运行的Java进程:<code>jps -l</code></li>
<li>使用<code>jstack</code>查看线程堆栈信息:<code>jstack -1 进程id</code></li>
</ul>
<p>基本就可以看到死锁的信息。</p>
<p>还可以利用图形化工具，比如<code>JConsole</code>。出现线程死锁以后，点击<code>JConsole</code>线程面板的检测到死锁按钮，将会看到线程的死锁信息。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918115033820.png" srcset="/img/loading.gif" lazyload alt="image-20220918115033820"></p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal定义"><a href="#ThreadLocal定义" class="headerlink" title="ThreadLocal定义"></a>ThreadLocal定义</h2><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902163020732.png" srcset="/img/loading.gif" lazyload alt="image-20220902163020732"></p>
<ul>
<li><p>创建</p>
<p>创建了一个<strong>ThreadLocal</strong>变量<strong>localVariable</strong>，任何一个线程都能并发访问<strong>localVariable</strong>。</p>
</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//创建一个ThreadLocal变量</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> localVariable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>

<ul>
<li><p>写入</p>
<p>线程可以在任何地方使用<strong>localVariable</strong>，写入变量。</p>
</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">localVariable<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>"鄙人三某”<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<ul>
<li>读取<br>线程在任何地方读取的都是它写入的变量。</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">localVariable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<h2 id="ThreadLocal的实际使用场景"><a href="#ThreadLocal的实际使用场景" class="headerlink" title="ThreadLocal的实际使用场景"></a>ThreadLocal的实际使用场景</h2><p>有用到过的，用来做用户信息上下文的存储。</p>
<p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接又，都会在请求头中携带</p>
<p>一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p>
<p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p>
<p>这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取ThreadLocal中存的用户数据。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902170811800.png" srcset="/img/loading.gif" lazyload alt="image-20220902170811800"></p>
<p>很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。</p>
<p>我们常用的数据库连接池也用到了ThreadLocal：</p>
<ul>
<li>数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。</li>
</ul>
<h2 id="ThreadLocal的实现方式"><a href="#ThreadLocal的实现方式" class="headerlink" title="ThreadLocal的实现方式"></a>ThreadLocal的实现方式</h2><p>我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取ThreadLocalMap，然后把元素存到这个map中。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token class-name">T</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//获取当前线程</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//获取ThreadLocalMap</span>
    <span class="token class-name">ThreadLocalMap</span> map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//讲当前元素存入map</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    	map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    	<span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><strong>ThreadLocal</strong>实现的秘密都在这个<strong>ThreadLocalMap</strong>了，Thread类中定义了一个类型为<strong>ThreadLocal.ThreadLocalMap</strong>的成员变量<strong>threadLocals</strong>。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//ThreadLocal.ThreadLocalMap是Thread的属性</span>
    <span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>ThreadLocalMap既然被称为Map，那么毫无疑问它是&lt;key,value&gt;型的数据结构。我们都知道map的本质是一个个&lt;key,value&gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token comment">/** The value associated with this ThreadLocal. */</span>
    <span class="token class-name">Object</span> value<span class="token punctuation">;</span>
    <span class="token comment">//节点类</span>
    <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//key赋值</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//value赋值</span>
        value <span class="token operator">=</span> v<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个 <strong>弱引用</strong> ，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">WeakReference</span><span class="token punctuation">(</span><span class="token class-name">T</span> referent<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">super</span><span class="token punctuation">(</span>referent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<p>key的赋值，使用的是WeakReference的赋值。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902173027266.png" srcset="/img/loading.gif" lazyload alt="image-20220902173027266"></p>
<p>所以，怎么回答ThreadLocal原理？要答出这几个点：</p>
<ul>
<li>Thread类有一个类型为<strong>ThreadLocal.ThreadLocalMap</strong>的实例变量<strong>threadLocals</strong>，每个线程都有一个属于自己的<strong>ThreadLocalMap</strong>。</li>
<li><strong>ThreadLocalMap</strong>内部维护着Entry数组，每个Entry代表一个完整的对象，key是<strong>ThreadLocal的弱引用</strong>，value是<strong>ThreadLocal的泛型值</strong>。</li>
<li>每个线程在往<strong>ThreadLocal</strong>里设置值的时候，都是往自己的<strong>ThreadLocalMap</strong>里存，读也是以某个<strong>ThreadLocal</strong>作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li>
<li>ThreadLocal本身不存储值，它只是作为一个<strong>key</strong>来让线程往<strong>ThreadLocalMap</strong>里存取值。</li>
</ul>
<h2 id="ThreadLocal的内存泄露问题"><a href="#ThreadLocal的内存泄露问题" class="headerlink" title="ThreadLocal的内存泄露问题"></a>ThreadLocal的内存泄露问题</h2><p>我们先来分析一下使用<strong>ThreadLocal</strong>时的内存，我们都知道，在<strong>JVM</strong>中，<strong>栈内存线程私有</strong>，存储了对象的引用，<strong>堆内存线程共享</strong>，存储了对象实例。</p>
<p>所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902193325147.png" srcset="/img/loading.gif" lazyload alt="image-20220902193325147"></p>
<p><strong>ThreadLocalMap</strong>中使用的 key 为 <strong>ThreadLocal</strong> 的弱引用。</p>
<p><em>“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”</em></p>
<p>那么现在问题就来了，弱引用很容易被回收，如果<strong>ThreadLocal（ThreadLocalMap的Key）</strong>被垃圾回收器回收了，但是<strong>ThreadLocalMap</strong>生命周期和<strong>Thread</strong>是一样的，它这时候如果不被回收，就会出现这种情况：<strong>ThreadLocalMap</strong>的<strong>key</strong>没了，<strong>value</strong>还在，这就会 <strong>造成了内存泄漏问题</strong> 。</p>
<h3 id="内存泄漏问题的解决"><a href="#内存泄漏问题的解决" class="headerlink" title="内存泄漏问题的解决"></a>内存泄漏问题的解决</h3><p>很简单，使用完<strong>ThreadLocal</strong>后，及时调用<strong>remove</strong>()方法释放内存空间。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> localVariable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    	localVariable<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>"鄙人三某”<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
    	localVariable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>那为什么key还要设计成弱引用？</p>
<p>key设计成弱引用同样是为了防止内存泄漏。</p>
<p>假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。</p>
<h2 id="ThreadLocalMap的结构"><a href="#ThreadLocalMap的结构" class="headerlink" title="ThreadLocalMap的结构"></a>ThreadLocalMap的结构</h2><p>ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接又的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：<strong>元素数组和散列方法。</strong></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902194739313.png" srcset="/img/loading.gif" lazyload alt="image-20220902194739313"></p>
<p><strong>元素数组</strong></p>
<p>一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p><strong>散列方法</strong></p>
<p>散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;运算（相当于取余）。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>这里的<strong>threadLocalHashCode</strong>计算有点东西，每创建一个<strong>ThreadLocal</strong>对象，它就会新增<strong>0x61c88647</strong>，这个值很特殊，它是 <strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong> 。hash增量为 这个数字，带来的好处就是 hash <strong>分布非常均匀</strong> 。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">HASH_INCREMENT</span> <span class="token operator">=</span> <span class="token number">0x61c88647</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token constant">HASH_INCREMENT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h2 id="ThreadLocalMap解决Hash冲突的方式"><a href="#ThreadLocalMap解决Hash冲突的方式" class="headerlink" title="ThreadLocalMap解决Hash冲突的方式"></a>ThreadLocalMap解决Hash冲突的方式</h2><p>我们可能都知道<strong>HashMap</strong>使用了链表来解决冲突，也就是所谓的链地址法。</p>
<p><strong>ThreadLocalMap</strong>没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式—— <strong>开放定址法</strong> 。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902212750305.png" srcset="/img/loading.gif" lazyload alt="image-20220902212750305"></p>
<p>如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。</p>
<p>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</p>
<h2 id="ThreadLocalMap扩容机制"><a href="#ThreadLocalMap扩容机制" class="headerlink" title="ThreadLocalMap扩容机制"></a>ThreadLocalMap扩容机制</h2><p>在<strong>ThreadLocalMap.set()**方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中</strong>Entry<strong>的数量已经达到了列表的扩容阈值</strong>(len*2/3)<strong>，就开始执行</strong>rehash()**逻辑：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>
<span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>

<p>再着看<strong>rehash</strong>()具体实现：这里会先去清理过期的<strong>Entry</strong>，然后还要根据条件判断<strong>size &gt;=threshold - threshold / 4</strong> 也就是*<em>size &gt;= threshold</em> 3/4**来决定是否需要扩容。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>
    <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//清理过期Entry</span>
        <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold <span class="token operator">-</span> threshold <span class="token operator">/</span> <span class="token number">4</span> <span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//清理过期Entry</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">expungeStaleEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Entry</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>接着看看具体的<strong>resize</strong>()方法，扩容后的<strong>newTab</strong>的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的newTab，遍历完成之后，<strong>oldTab</strong>中所有的<strong>entry</strong>数据都已经放入到<strong>newTab</strong>中了，然后table引用指向<strong>newTab</strong></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213343066.png" srcset="/img/loading.gif" lazyload alt="image-20220902213343066"></p>
<p>具体代码：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213432939.png" srcset="/img/loading.gif" lazyload alt="image-20220902213432939"></p>
<h2 id="父子线程怎么共享数据"><a href="#父子线程怎么共享数据" class="headerlink" title="父子线程怎么共享数据"></a>父子线程怎么共享数据</h2><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p>
<p>这时候可以用到另外一个类——<code>InheritableThreadLocal</code>。</p>
<p>使用起来很简单，在主线程的<code>InheritableThreadLocal</code>实例设置值，在子线程中就可以拿到了。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InheritableThreadLocalTest</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span> threadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InheritableThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 主线程</span>
            threadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"不擅技术"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//子线程</span>
            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"鄙人三某 ，"</span> <span class="token operator">+</span> threadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>原理很简单，在Thread类里还有另外一个变量：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>在<strong>Thread.init</strong>的时候，如果父线程的<strong>inheritableThreadLocals</strong>不为空，就把它赋给当前线程（子线程）的<strong>inheritableThreadLocals</strong>。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>inheritThreadLocals <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">createInheritedMap</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>inheritableThreadLocals<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div></figure>

<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h2><p>Java内存模型（<strong>Java Memory Model</strong>，JMM），是一种<strong>抽象的模型</strong>，被定义出来屏蔽各种硬件和操作系统的<strong>内存访问差异</strong>。</p>
<p>JMM定义了<strong>线程和主内存</strong>之间的抽象关系：线程之间的<strong>共享变量</strong>存储在主内存（<strong>Main Memory</strong>）中，每个线程都有一个私有的本地内存（<strong>Local Memory</strong>），本地内存中存储了该线程<strong>以读/写共享变量的副本</strong>。</p>
<p>Java内存模型的抽象图：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114356751.png" srcset="/img/loading.gif" lazyload alt="image-20220903114356751"></p>
<p>本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114449779.png" srcset="/img/loading.gif" lazyload alt="image-20220903114449779"></p>
<p>图里面的是一个<strong>双核 CPU 系统架构</strong> ，每个核有自己的<strong>控制器和运算器</strong>，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的<strong>一级缓存</strong>，在有些架构里面还有一个<strong>所有 CPU 共享的二级缓存</strong>。 那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。</p>
<h2 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h2><p>原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。</p>
<ul>
<li><strong>原子性</strong>：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。</li>
<li><strong>可见性</strong>：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。</li>
<li><strong>有序性</strong>：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。</li>
</ul>
<h3 id="分析下面几行代码的原子性？"><a href="#分析下面几行代码的原子性？" class="headerlink" title="分析下面几行代码的原子性？"></a>分析下面几行代码的原子性？</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
i<span class="token operator">++</span><span class="token punctuation">;</span>
i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<ul>
<li>第 1 句是基本类型赋值，是原子性操作。</li>
<li>第 2 句先读i的值，再赋值到j，两步操作，不能保证原子性。</li>
<li>第 3 和第 4 句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</li>
</ul>
<h3 id="原子性、可见性、有序性的实现原理"><a href="#原子性、可见性、有序性的实现原理" class="headerlink" title="原子性、可见性、有序性的实现原理"></a>原子性、可见性、有序性的实现原理</h3><ul>
<li><strong>原子性</strong>：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<strong>synchronized</strong> 。</li>
<li><strong>可见性</strong>：Java是利用<strong>volatile</strong> 关键字来保证可见性的，除此之外，<strong>final</strong> 和<strong>synchronized</strong> 也能保证可见性。</li>
<li><strong>有序性</strong>：<strong>synchronized</strong> 或者<strong>volatile</strong> 都可以保证多线程之间操作的有序性。</li>
</ul>
<h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><p>在执行程序时，为了提高性能，<strong>编译器和处理器</strong>常常会对指令做重排序。重排序分 3 种类型。</p>
<ol>
<li><p><strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</p>
</li>
<li><p><strong>内存系统的重排序</strong>。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
</li>
</ol>
<p>从Java源代码到最终实际执行的指令序列，会分别经历下面 3 种重排序，如图：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903115952545.png" srcset="/img/loading.gif" lazyload alt="image-20220903115952545"></p>
<p>我们比较熟悉的<strong>双重校验单例模式</strong>就是一个经典的指令重排的例子，<strong>Singleton instance=new Singleton()；</strong>对应的JVM指令分为三步：<strong>分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间</strong>，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133213700.png" srcset="/img/loading.gif" lazyload alt="image-20220903133213700"></p>
<p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h4 id="指令重排有限制吗？happens-before了解吗？"><a href="#指令重排有限制吗？happens-before了解吗？" class="headerlink" title="指令重排有限制吗？happens-before了解吗？"></a>指令重排有限制吗？happens-before了解吗？</h4><p>指令重排也是有一些限制的，有两个规则<strong>happens-before和as-if-serial</strong>来约束。</p>
<p><strong>happens-before</strong>的定义：</p>
<ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ul>
<p>happens-before和我们息息相关的有<strong>六大规则</strong>：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133644636.png" srcset="/img/loading.gif" lazyload alt="image-20220903133644636"></p>
<ul>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ul>
<h4 id="as-if-serial又是什么？单线程的程序一定是顺序的吗"><a href="#as-if-serial又是什么？单线程的程序一定是顺序的吗" class="headerlink" title="as-if-serial又是什么？单线程的程序一定是顺序的吗"></a>as-if-serial又是什么？单线程的程序一定是顺序的吗</h4><p>as-if-serial语义的意思是：<strong>不管怎么重排序（编译器和处理器为了提高并行度）</strong>， <strong>单线程程序的执行结果不能被改变</strong> 。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span> <span class="token comment">// A</span>
<span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> <span class="token comment">// B</span>
<span class="token keyword">double</span> area <span class="token operator">=</span> pi <span class="token operator">*</span> r <span class="token operator">*</span> r<span class="token punctuation">;</span> <span class="token comment">// C</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<p>上面 3 个操作的数据依赖关系：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134841710.png" srcset="/img/loading.gif" lazyload alt="image-20220903134841710"></p>
<p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。所以最终，程序可能会有两种执行顺序：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134956909.png" srcset="/img/loading.gif" lazyload alt="image-20220903134956909"></p>
<p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。</p>
<h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><p>volatile有两个作用，保证 <strong>可见性</strong> 和 <strong>有序性</strong> 。</p>
<h3 id="volatile怎么保证可见性"><a href="#volatile怎么保证可见性" class="headerlink" title="volatile怎么保证可见性"></a>volatile怎么保证可见性</h3><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p>
<p>volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p>
<p>例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903135524735.png" srcset="/img/loading.gif" lazyload alt="image-20220903135524735"></p>
<h3 id="volatile怎么保证有序性"><a href="#volatile怎么保证有序性" class="headerlink" title="volatile怎么保证有序性"></a>volatile怎么保证有序性</h3><p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140353177.png" srcset="/img/loading.gif" lazyload alt="image-20220903140353177"></p>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p><strong>1.</strong> 在每个volatile写操作的前面插入一个StoreStore 屏障<br><strong>2.</strong> 在每个volatile写操作的后面插入一个StoreLoad 屏障<br><strong>3.</strong> 在每个volatile读操作的后面插入一个LoadLoad 屏障<br><strong>4.</strong> 在每个volatile读操作的后面插入一个LoadStore 屏障</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140503354.png" srcset="/img/loading.gif" lazyload alt="image-20220903140503354"></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140518029.png" srcset="/img/loading.gif" lazyload alt="image-20220903140518029"></p>
<h3 id="双重校验锁实现对象单例（线程安全）"><a href="#双重校验锁实现对象单例（线程安全）" class="headerlink" title="双重校验锁实现对象单例（线程安全）"></a>双重校验锁实现对象单例（线程安全）</h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">//类对象加锁</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="基于synchronized"><a href="#基于synchronized" class="headerlink" title="基于synchronized"></a>基于synchronized</h2><h3 id="synchronized的用法"><a href="#synchronized的用法" class="headerlink" title="synchronized的用法"></a>synchronized的用法</h3><p>synchronized经常用的，用来保证代码的原子性。</p>
<p>synchronized主要有三种用法：</p>
<ul>
<li><strong>修饰实例方法</strong>: 作用于当前<strong>对象实例</strong>加锁，进入同步代码前要获得 当前对象实例的锁</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token comment">//业务代码</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<ul>
<li><strong>修饰静态方法</strong> ：也就是给<strong>当前类加锁</strong>，会作用于类的所有对象实例 ，进入同步代码前要获得当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> staic <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token comment">//业务代码</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<ul>
<li><strong>修饰代码块</strong> ：<strong>指定加锁对象，对给定对象/类加锁</strong>。 <strong>synchronized(this|object)</strong> 表示进入同步代码库前要获得给定对象的锁。 <strong>synchronized(类.class)</strong> 表示进入同步代码前要获得 当前<strong>class</strong> 的锁</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token comment">//业务代码</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<h3 id="synchronized的实现原理"><a href="#synchronized的实现原理" class="headerlink" title="synchronized的实现原理"></a>synchronized的实现原理</h3><h3 id="synchronized的加锁方式"><a href="#synchronized的加锁方式" class="headerlink" title="synchronized的加锁方式"></a>synchronized的加锁方式</h3><p>我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。</p>
<p><strong>1.</strong> <strong>synchronized修饰代码块时</strong>，JVM采用<strong>monitorenter、monitorexit</strong>两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。反编译一段synchronized修饰代码块代码，<strong>javap -c -s -v -l</strong><br><strong>SynchronizedDemo.class</strong>，可以看到相应的字节码指令。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903180902786.png" srcset="/img/loading.gif" lazyload alt="image-20220903180902786"></p>
<p><strong>2.</strong> <strong>synchronized修饰同步方法时</strong>，JVM采用ACC_SYNCHRONIZED标记符来实现同步，这个标识指明了该方法是一个同步方法。<br>同样可以写段代码反编译看一下。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903181654514.png" srcset="/img/loading.gif" lazyload alt="image-20220903181654514"></p>
<h3 id="synchronized锁住的是什么呢？"><a href="#synchronized锁住的是什么呢？" class="headerlink" title="synchronized锁住的是什么呢？"></a>synchronized锁住的是什么呢？</h3><p>monitorenter、monitorexit或者ACC_SYNCHRONIZED都是 <strong>基于Monitor实现</strong> 的。</p>
<p>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了<strong>monitor</strong> 。</p>
<p>所谓的Monitor其实是一种 <strong>同步工具</strong> ，也可以说是一种 <strong>同步机制</strong> 。在Java虚拟机（HotSpot）中，Monitor是由 <strong>ObjectMonitor实现</strong> 的，可以叫做内部锁，或者Monitor锁。</p>
<p>ObjectMonitor的工作原理：</p>
<ul>
<li>ObjectMonitor有两个队列：WaitSet、EntryList，用来保存ObjectWaiter 对象列表。</li>
<li>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait()方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入WaitSet 中，等待被唤醒。</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ObjectMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
_header <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
_count <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> <span class="token comment">// 记录线程获取锁的次数</span>
_waiters <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span>
_recursions <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> <span class="token comment">//锁的重入次数</span>
_object <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
_owner <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 指向持有ObjectMonitor对象的线程</span>
_WaitSet <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 处于wait状态的线程，会被加入到_WaitSet</span>
_WaitSetLock <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
_Responsible <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
_succ <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
_cxq <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
<span class="token class-name">FreeNext</span> <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span>
_EntryList <span class="token operator">=</span> <span class="token constant">NULL</span> <span class="token punctuation">;</span> <span class="token comment">// 处于等待锁block状态的线程，会被加入到该列表</span>
_SpinFreq <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
_SpinClock <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
<span class="token class-name">OwnerIsThread</span> <span class="token operator">=</span> <span class="token number">0</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>可以类比一个去医院就诊的例子[18]：</p>
<ul>
<li><p>首先，患者在 门诊大厅 前台或自助挂号机 进行挂号 ；</p>
</li>
<li><p>随后，挂号结束后患者找到对应的 诊室就诊 ：</p>
<ul>
<li>诊室每次只能有一个患者就诊；</li>
<li>如果此时诊室空闲，直接进入就诊；</li>
<li>如果此时诊室内有其它患者就诊，那么当前患者进入候诊室，等待叫号；</li>
</ul>
</li>
<li><p>就诊结束后， 走出就诊室 ，候诊室的 下一位候诊患者 进入就诊室。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190305715.png" srcset="/img/loading.gif" lazyload alt="image-20220903190305715"></p>
</li>
</ul>
<p>这个过程就和<strong>Monitor机制</strong>比较相似：</p>
<ul>
<li>门诊大厅：所有待进入的线程都必须先在入口Entry Set挂号才有资格；</li>
<li>就诊室：就诊室_Owner里里只能有一个线程就诊，就诊完线程就自行离开</li>
<li>候诊室：就诊室繁忙时，进入等待区（Wait Set），就诊室空闲的时候就从等待区（Wait Set）叫新的线程</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190457240.png" srcset="/img/loading.gif" lazyload alt="image-20220903190457240"></p>
<p>所以我们就知道了，同步是锁住的什么东西：</p>
<ul>
<li><strong>monitorenter</strong>，在判断拥有同步标识 <strong>ACC_SYNCHRONIZED</strong> 抢先进入此方法的线程会优先拥有 <strong>Monitor</strong> 的 <strong>owner</strong> ，此时计数器 +1。</li>
<li><strong>monitorexit</strong>，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</li>
</ul>
<h3 id="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"><a href="#除了原子性，synchronized可见性，有序性，可重入性怎么实现？" class="headerlink" title="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"></a>除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h3><h3 id="synchronized怎么保证可见性？"><a href="#synchronized怎么保证可见性？" class="headerlink" title="synchronized怎么保证可见性？"></a>synchronized怎么保证可见性？</h3><ul>
<li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li>
<li>线程加锁后，其它线程无法获取主内存中的共享变量。</li>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li>
</ul>
<h3 id="synchronized怎么保证有序性？"><a href="#synchronized怎么保证有序性？" class="headerlink" title="synchronized怎么保证有序性？"></a>synchronized怎么保证有序性？</h3><ul>
<li>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。</li>
<li>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</li>
<li>所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。</li>
</ul>
<h3 id="synchronized怎么实现可重入的呢？"><a href="#synchronized怎么实现可重入的呢？" class="headerlink" title="synchronized怎么实现可重入的呢？"></a>synchronized怎么实现可重入的呢？</h3><ul>
<li>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。</li>
<li>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码、块之后，计数器就会-1，直到计数器清零，就释放锁了。</li>
<li>之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</li>
</ul>
<h3 id="锁升级？synchronized优化了解吗？"><a href="#锁升级？synchronized优化了解吗？" class="headerlink" title="锁升级？synchronized优化了解吗？"></a>锁升级？synchronized优化了解吗？</h3><p>了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？</p>
<p>Java对象头里，有一块结构，叫<strong>Mark Word</strong>标记字段，这块结构会随着锁的状态变化而变化。64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903215849935.png" srcset="/img/loading.gif" lazyload alt="image-20220903215849935"></p>
<p>Mark Word存储对象自身的运行数据，如<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）</strong> 等。</p>
<h3 id="synchronized做了哪些优化？"><a href="#synchronized做了哪些优化？" class="headerlink" title="synchronized做了哪些优化？"></a>synchronized做了哪些优化？</h3><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong> 。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。</p>
<ul>
<li><strong>偏向锁</strong>：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</li>
<li><strong>轻量级锁</strong>：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。</li>
<li><strong>自旋锁</strong>：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</li>
<li><strong>锁粗化</strong>：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li>
<li><strong>锁消除</strong>：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</li>
</ul>
<h3 id="锁升级的过程是什么样的？"><a href="#锁升级的过程是什么样的？" class="headerlink" title="锁升级的过程是什么样的？"></a>锁升级的过程是什么样的？</h3><p>锁升级方向：无锁–&gt;偏向锁—&gt; 轻量级锁—-&gt;重量级锁，这个方向基本上是不可逆的。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903221140669.png" srcset="/img/loading.gif" lazyload alt="image-20220903221140669"></p>
<p>我们看一下升级的过程：</p>
<p><strong>偏向锁：</strong></p>
<p><strong>偏向锁的获取：</strong></p>
<p><strong>1.</strong> 判断是否为可偏向状态–MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’<br><strong>2.</strong> 如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤’5’，否则进入步骤‘3’<br><strong>3.</strong> 通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’<br><strong>4.</strong> CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块<br>**5. ** 执行同步代码</p>
<p><strong>偏向锁的撤销：</strong></p>
<ol>
<li> 偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到<strong>safepoint</strong>时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况；</li>
<li>撤销—-T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态—-该状态达到阈值 20 则执行批量重偏向</li>
<li>升级—-T线程还在同步代码块中，则将T线程的偏向锁升级为轻量级锁，当前线程执行轻量级锁状态下的锁获取步骤—-该状态达到阈值 40 则执行批量撤销</li>
</ol>
<p><strong>轻量级锁：</strong></p>
<p><strong>轻量级锁的获取：</strong></p>
<p><strong>1.</strong> 进行加锁操作时，jvm会判断是否已经时重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中<br><strong>2.</strong> 复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’<br><strong>3.</strong> 更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态<br><strong>4.</strong> 更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘6’<br><strong>5.</strong> 表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。<br><strong>6.</strong> 表示该锁对象已经被其他线程抢占，则进行自旋等待（默认 10 次），等待次数达到阈值仍未获取到锁，则升级为重量级锁</p>
<p>大体上省简的升级过程：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904142059373.png" srcset="/img/loading.gif" lazyload alt="image-20220904142059373"></p>
<p>完整的升级过程：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904142838070.png" srcset="/img/loading.gif" lazyload alt="image-20220904142838070"></p>
<h3 id="说说synchronized和ReentrantLock的区别？"><a href="#说说synchronized和ReentrantLock的区别？" class="headerlink" title="说说synchronized和ReentrantLock的区别？"></a>说说synchronized和ReentrantLock的区别？</h3><p>可以从<strong>锁的实现、功能特点、性能</strong>等几个维度去回答这个问题：</p>
<ul>
<li><strong>锁的实现</strong>： synchronized是<strong>Java语言的关键字</strong>，基于<strong>JVM</strong>实现。而ReentrantLock是基于JDK的<strong>API层面</strong>实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）</li>
<li><strong>性能</strong>： 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。</li>
<li><strong>功能特点</strong>： ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。<ul>
<li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</li>
<li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li>
<li>synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接又与newCondition()方法实现。</li>
<li>ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。</li>
</ul>
</li>
</ul>
<p>下面的表格列出出了两种锁之间的区别：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904163310518.png" srcset="/img/loading.gif" lazyload alt="image-20220904163310518"></p>
<h2 id="基于AQS"><a href="#基于AQS" class="headerlink" title="基于AQS"></a>基于AQS</h2><h3 id="AQS了解多少？"><a href="#AQS了解多少？" class="headerlink" title="AQS了解多少？"></a>AQS了解多少？</h3><p>AbstractQueuedSynchronizer <strong>抽象同步队列</strong>，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p>
<ul>
<li>AQS是基于一个<strong>FIFO的双向队列</strong>，其内部定义了一个节点类Node，Node 节点内部的SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE用来标记线程是 取独占资源时被挂起后放入AQS 队列</li>
<li>AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性</li>
<li>获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。</li>
<li>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904165058873.png" srcset="/img/loading.gif" lazyload alt="image-20220904165058873"></p>
<p>先简单了解一下CLH：Craig、Landin and Hagersten 队列，是 <strong>单向链表实现的队列</strong> 。申请线程只在本地变量上自旋， <strong>它不断轮询前驱的状态</strong> ，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904165133380.png" srcset="/img/loading.gif" lazyload alt="image-20220904165133380"></p>
<p>AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904165250668.png" srcset="/img/loading.gif" lazyload alt="image-20220904165250668"></p>
<p>AQS 中的 CLH 变体等待队列拥有以下特性：</p>
<ul>
<li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li>
<li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li>
<li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li>
<li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li>
</ul>
<h3 id="ReentrantLock实现原理？"><a href="#ReentrantLock实现原理？" class="headerlink" title="ReentrantLock实现原理？"></a>ReentrantLock实现原理？</h3><p>ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。</p>
<p>看看ReentrantLock的加锁操作：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建非公平锁</span>
<span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取锁操作</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 执行代码逻辑</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 解锁操作</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>new ReentrantLock()构造函数默认创建的是非公平锁 NonfairSync。</p>
<h3 id="公平锁-FairSync"><a href="#公平锁-FairSync" class="headerlink" title="公平锁 FairSync"></a>公平锁 FairSync</h3><ul>
<li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁</li>
<li>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞,CPU 唤醒阻塞线程的开销比非公平锁大</li>
</ul>
<h3 id="非公平锁-NonfairSync"><a href="#非公平锁-NonfairSync" class="headerlink" title="非公平锁 NonfairSync"></a><strong>非公平锁 NonfairSync</strong></h3><ul>
<li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁</li>
<li>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</li>
</ul>
<p>默认创建的对象lock()的时候：</p>
<ul>
<li>如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为 1 ，然后直接返回。</li>
<li>如果当前线程之前己经获取过该锁，则这次只是简单地把 AQS 的状态值加 1 后返回。如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法程会被放入 AQS 队列阻塞挂起。</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904184232357.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="ReentrantLock怎么实现公平锁的？"><a href="#ReentrantLock怎么实现公平锁的？" class="headerlink" title="ReentrantLock怎么实现公平锁的？"></a>ReentrantLock怎么实现公平锁的？</h3><p>new ReentrantLock()构造函数默认创建的是非公平锁 NonfairSync</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">-</span> <span class="token class-name">ReentrantLock</span>
<span class="token comment">// true 代表公平锁，false 代表非公平锁</span>
<span class="token keyword">public</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
sync <span class="token operator">=</span> fair<span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。</p>
<p><strong>非公平锁和公平锁的两处不同：</strong></p>
<ul>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904184726138.png" srcset="/img/loading.gif" lazyload alt="image-20220904184726138"></p>
<p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="CAS的定义"><a href="#CAS的定义" class="headerlink" title="CAS的定义"></a>CAS的定义</h2><p>CAS叫做<strong>CompareAndSwap</strong>，<strong>比较并交换</strong>，主要是通过处理器的指令来保证操作的原子性的。</p>
<p>CAS 指令包含 3 个参数：<strong>共享变量的内存地址 A、预期的值 B 和共享变量的新值 C</strong>。只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条CPU 指令，CAS 指令本身是能够保证原子性的 。</p>
<h2 id="CAS-产生的问题"><a href="#CAS-产生的问题" class="headerlink" title="CAS 产生的问题"></a>CAS 产生的问题</h2><p>CAS的经典三大问题：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904192625392.png" srcset="/img/loading.gif" lazyload alt="image-20220904192625392"></p>
<h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。</p>
<h4 id="怎么解决ABA问题？"><a href="#怎么解决ABA问题？" class="headerlink" title="怎么解决ABA问题？"></a>怎么解决ABA问题？</h4><ul>
<li>加版本号</li>
</ul>
<p>每次修改变量，都在这个变量的版本号上加 1 ，这样，刚刚A-&gt;B-&gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。</p>
<p>Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。</p>
<h3 id="循环性能开销"><a href="#循环性能开销" class="headerlink" title="循环性能开销"></a>循环性能开销</h3><p>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</p>
<h4 id="怎么解决循环性能开销问题？"><a href="#怎么解决循环性能开销问题？" class="headerlink" title="怎么解决循环性能开销问题？"></a>怎么解决循环性能开销问题？</h4><p>在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。</p>
<h3 id="只能保证一个变量的原子操作"><a href="#只能保证一个变量的原子操作" class="headerlink" title="只能保证一个变量的原子操作"></a><strong>只能保证一个变量的原子操作</strong></h3><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p>
<h4 id="怎么解决只能保证一个变量的原子操作问题？"><a href="#怎么解决只能保证一个变量的原子操作问题？" class="headerlink" title="怎么解决只能保证一个变量的原子操作问题？"></a>怎么解决只能保证一个变量的原子操作问题？</h4><ul>
<li>可以考虑改用锁来保证操作的原子性</li>
<li>可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。</li>
</ul>
<h2 id="Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？"><a href="#Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？" class="headerlink" title="Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？"></a>Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？</h2><p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904223156739.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>使用循环原子类，例如AtomicInteger，实现i++原子操作</li>
<li>使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性</li>
<li>使用synchronized，对i++操作加锁</li>
</ul>
<h1 id="原子操作类"><a href="#原子操作类" class="headerlink" title="原子操作类"></a>原子操作类</h1><h2 id="原子操作类-1"><a href="#原子操作类-1" class="headerlink" title="原子操作类"></a>原子操作类</h2><p>当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量i=1，A线程更新i+1，B线程也更新i+1，经过两个线程操作之后可能i不等于 3 ，而是等于 2 。因为A和B线程在更新变量i的时候拿到的i都是 1 ，这就是线程不安全的更新操作，一般我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p>
<p>其实除此之外，还有更轻量级的选择，Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p>
<p>因为变量的类型有很多种，所以在Atomic包里一共提供了 13 个类，属于 4 种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904223443822.png" srcset="/img/loading.gif" lazyload alt="image-20220904223443822"></p>
<p>Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<p>使用原子的方式更新基本类型，Atomic包提供了以下 3 个类：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">AtomicBoolean</span>：原子更新布尔类型。
<span class="token class-name">AtomicInteger</span>：原子更新整型。
<span class="token class-name">AtomicLong</span>：原子更新长整型。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下 4 个类：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">AtomicIntegerArray</span>：原子更新整型数组里的元素。
<span class="token class-name">AtomicLongArray</span>：原子更新长整型数组里的元素。
<span class="token class-name">AtomicReferenceArray</span>：原子更新引用类型数组里的元素。
<span class="token class-name">AtomicIntegerArray</span>类主要是提供原子的方式更新数组里的整型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下 3 个类：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">AtomicReference</span>：原子更新引用类型。
<span class="token class-name">AtomicReferenceFieldUpdater</span>：原子更新引用类型里的字段。
<span class="token class-name">AtomicMarkableReference</span>：原子更新带有标记位的引用类型。可以原子更新一个布尔类型
的标记位和引用类型。构造方法是<span class="token class-name">AtomicMarkableReference</span>（<span class="token class-name">V</span> initialRef，<span class="token keyword">boolean</span>
initialMark）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下 3 个类进行原子字段更新：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">AtomicIntegerFieldUpdater</span>：原子更新整型的字段的更新器。
<span class="token class-name">AtomicLongFieldUpdater</span>：原子更新长整型字段的更新器。
<span class="token class-name">AtomicStampedReference</span>：原子更新带有版本号的引用类型。该类将整数值与引用关联起
来，可用于原子的更新数据和数据的版本号，可以解决使用<span class="token constant">CAS</span>进行原子更新时可能出现
的 <span class="token constant">ABA</span>问题。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>



<h2 id="AtomicInteger-的原理"><a href="#AtomicInteger-的原理" class="headerlink" title="AtomicInteger 的原理"></a>AtomicInteger 的原理</h2><p><strong>一句话概括： 使用CAS实现 。</strong></p>
<p>以AtomicInteger的添加方法为例：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<p>通过Unsafe类的实例来进行添加操作，来看看具体的CAS操作：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var4<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> var5<span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
    	var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getIntVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var5<span class="token punctuation">,</span> var5 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> var5<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><code>compareAndSwapInt</code> 是一个<code>native</code>方法，基于<code>CAS</code>来操作 <code>int</code>类型变量。其它的原子操作类基本都是大同小异。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的含义"><a href="#线程池的含义" class="headerlink" title="线程池的含义"></a>线程池的含义</h2><p>线程池:简单理解,它就是一个管理线程的池子。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918121651211.png" srcset="/img/loading.gif" lazyload alt="image-20220918121651211"></p>
<ul>
<li><strong>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗</strong>。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li>
<li><strong>提高响应速度</strong>。如果任务到达了，相对于从线程池拿线程，里新去创建一余线住执门，速度肯定慢很多。</li>
<li><strong>重复利用</strong>。线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li>
</ul>
<h2 id="线程池的实际应用场景"><a href="#线程池的实际应用场景" class="headerlink" title="线程池的实际应用场景"></a>线程池的实际应用场景</h2><p>之前我们有一个和第三方对接的需求，需要向第三方推送数据，引入了多线程来提升数据推送的效率，其中用到了线程池来管理线程。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918121920193.png" srcset="/img/loading.gif" lazyload alt="image-20220918121920193"></p>
<p>主要代码如下：</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918122012568.png" srcset="/img/loading.gif" lazyload alt="image-20220918122012568"></p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918122033551.png" srcset="/img/loading.gif" lazyload alt="image-20220918122033551"></p>
<p>完整可运行代码地址: <a target="_blank" rel="noopener" href="https://gitee.com/fighter3/thread-demo.git">https://gitee.com/fighter3/thread-demo.git</a></p>
<p>线程池的参数如下:</p>
<ul>
<li><code>corePoolSize</code>:线程核心参数选择了CPU数×2</li>
<li><code>maximumPoolSize</code>:最大线程数选择了和核心线程数相同</li>
<li><code>keepAliveTime</code>:非核心闲置线程存活时间直接置为0</li>
<li><code>unit</code>:非核心线程保持存活的时间选择了<code>TimeUnit.SECONDS</code>秒.</li>
<li><code>workQueue</code>:线程池等待队列，使用<code>LinkedBlockingQueue</code>阻塞队列</li>
</ul>
<p>同时还用了<code>synchronized</code>来加锁,保证数据不会被重复推送:</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">PushProcessServiceImpl</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<p>ps:这个例子只是简单地进行了数据推送，实际上还可以结合其他的业务，像什么数据清洗啊、数据统计啊，都可以套用。</p>
<h2 id="线程池的工作流程"><a href="#线程池的工作流程" class="headerlink" title="线程池的工作流程"></a>线程池的工作流程</h2><p>用一个通俗的比喻:</p>
<p>有一个营业厅，总共有六个窗口，现在开放了三个窗口，现在有三个窗口坐着三个营业员小姐姐在营业。<br>老三去办业务，可能会遇到什么情况呢?</p>
<p>1.老三发现有空间的在营业的窗口，直接去找小姐姐办理业务。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918135430290.png" srcset="/img/loading.gif" lazyload alt="image-20220918135430290"></p>
<ol start="2">
<li>老三发现没有空闲的窗口，就在排队区排队等。</li>
</ol>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918135520635.png" srcset="/img/loading.gif" lazyload alt="image-20220918135520635"></p>
<p>3.老三发现没有空闲的窗口，等待区也满了，蚌埠住了，经理一看，就让休息的小姐姐赶紧回来上班，等待区号靠前的赶紧去新窗口办，老三去排队区排队。小姐姐比较辛苦，假如一段时间发现他们可以不用接着营业，经理就让她们接着休息。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918142156123.png" srcset="/img/loading.gif" lazyload alt="image-20220918142156123"></p>
<p>4．老三一看，六个窗口都满了，等待区也没位置了。老三急了，要闹，经理赶紧出来了，经理该怎么办呢?</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918142311472.png" srcset="/img/loading.gif" lazyload alt="image-20220918142311472"></p>
<ul>
<li><p>1.我们银行系统已经瘫痪</p>
</li>
<li><p>2.谁叫你来办的你找谁去</p>
</li>
<li><p>3.看你比较急,去队里加个塞</p>
</li>
<li><p>4.今天没办法,不行你看改一天</p>
</li>
<li><p>上面的这个流程几乎就跟JDK线程池的人致流程类似，</p>
</li>
<li><p>营业中的3个窗口对应核心线程池数: <code>corePoolSize</code></p>
</li>
<li><p>总的营业窗口数6对应: <code>maximumPoolSize</code></p>
</li>
<li><p>打开的临时窗口在多少时问内无人办理则关闭对应: <code>unit</code></p>
</li>
<li><p>排队区就是等待队列: <code>workQueue</code></p>
</li>
<li><p>无法办理的时候银行给出的解决方法对应:<code>RejectedExecutionHandler</code></p>
</li>
<li><p><code>threadFactory</code>该参数在<code>JDK</code>中是线程工厂，用来创建线程对象，一般不会动。</p>
</li>
</ul>
<p>所以我们线程池的工作流程也比较好理解了:</p>
<ol>
<li><p>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p>
</li>
<li><p>当调用<code>execute()</code>方法添加一个任务时，线程池会做如下判断:</p>
</li>
</ol>
<ul>
<li><p>如果正在运行的线程数量小于<code>corePoolSize</code>，那么马上创建线程运行这个任务;</p>
</li>
<li><p>如果正在运行的线程数量大于或等于<code>corePoolSize</code>，那么将这个任务放入队列;</p>
</li>
<li><p>如果这时候队列满了，而且正在运行的线程数量小于<code>maximumPoolSize</code>，那么还是要创建非核心线程立刻运行这个任务;</p>
</li>
<li><p>如果队列满了，而且正在运行的线程数量大于或等于<code>maximumPoolSize</code>，那么线程池会根据拒绝策略来对应处理。</p>
</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918142854632.png" srcset="/img/loading.gif" lazyload alt="image-20220918142854632"></p>
<ol start="3">
<li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li>
<li>当一个线程无事可做，超过一定的时间<code>(keepAliveTime)</code>时，线程池会判断，如果当前运行的线程数大于<code>corePoolSize</code>,那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到<code>corePoolSize</code> 的大小。</li>
</ol>
<h2 id="线程池主要参数"><a href="#线程池主要参数" class="headerlink" title="线程池主要参数"></a>线程池主要参数</h2><p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918143618945.png" srcset="/img/loading.gif" lazyload alt="image-20220918143618945"></p>
<p>线程池有七大参数，需要重点关注<br><code>corePoolSize</code>、<code>maximumPoolSize</code> 、<code>workQueue</code> 、<code>handler</code>这四个。</p>
<ol>
<li><p><strong>corePoolSize</strong><br>此值是用来初始化线程池中核心线程数，当线程池中线程池数&lt;<code>corePoolSize</code>时，系统默认是添加一个任务才创建一个线程池。当线程数= <code>corePoolSize</code>时，新任务会追加到<code>workQueue</code>中。</p>
</li>
<li><p><strong>maximumPoolSize</strong></p>
<p><code>maximumPoolSize</code>表示允许的**最大线程数=(非核心线程数+核心线程数)**，<br>当<code>BlockingQueue</code>也满了，但线程池中总线程数&lt;<code>maximumPoolSize</code>时候就会再次创建新的线程。</p>
</li>
<li><p><strong>keepAliveTime</strong><br>非核心线程=(<code>maximumPoolSize</code> - <code>corePoolSize</code> ) ,非核心线程闲置下来不干活最多存活时间。</p>
</li>
<li><p><strong>unit</strong><br> 线程池中非核心线程保持存活的时间的单位</p>
<p><code>TimeUnit.DAYS;天</code></p>
<p><code>TimeUnit.HOURS;小时</code></p>
<p><code>TimeUnit.MINUTES;分钟</code></p>
<p><code>TimeUnit.SECONDS;秒</code></p>
<p><code>TimeUnit.MILLISECONDS;毫秒</code></p>
<p><code>TimeUnit.MICROSECONDS;微秒</code></p>
<p><code>TimeUnit.NANOSECONDS;纳秒</code></p>
</li>
<li><p><strong>workQueue</strong><br>线程池等待队列，维护着等待执行的<code>Runnable</code>对象。当运行当线程数= <code>corePoolSize</code>时，新的任务会被添加到<code>workQueue</code>中，如果workQueue也满了则尝试用非核心线程执行任务，等待队列应该尽量用有界的。</p>
</li>
<li><p><strong>threadFactory</strong><br>创建一个新线程时使用的工厂，可以用来设定线程名、是否为<code>daemon</code>线程等等。</p>
</li>
<li><p><strong>handler</strong><br><code>corePoolSize</code> 、 <code>workQueue</code> 、<code>maximumPoolSize</code>都不可用的时候执行的饱和策略。</p>
</li>
</ol>
<h2 id="线程池的线程数的配置"><a href="#线程池的线程数的配置" class="headerlink" title="线程池的线程数的配置"></a>线程池的线程数的配置</h2><p>线程在Java中属于稀缺资源﹐线程池不是越大越好也不是越小越好。任务分为计算<strong>密集型、IO密集型、混合型</strong>。</p>
<ol>
<li>计算密集型:大部分都在用CPU跟内存，加密，逻辑操作业务处理等。</li>
<li>IO密集型:数据库链接，网络通讯传输等。</li>
</ol>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918152257483.png" srcset="/img/loading.gif" lazyload alt="image-20220918152257483"></p>
<p>一般的经验，不同类型线程池的参数配置：</p>
<ol>
<li><strong>计算密集型</strong>一般推荐线程池不要过大，一般是<code>CPU数 + 1</code>，<code>+1</code>是因为可能存在页缺失(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前<code>CPU核心数</code>代码如下：</li>
</ol>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div></figure>

<ol start="2">
<li><strong>IO密集型</strong>：线程数适当大一点，机器的<code>Cpu核心数*2</code>。</li>
<li><strong>混合型</strong>：可以考虑根绝情况将它拆分成<code>CPU密集型</code>和<code>IO密集型任务</code>，如果执行时间相差不大，拆分可以提升吞吐量，反之没有必要。</li>
</ol>
<p>当然，实际应用中没有固定的公式，需要结合测试和监控来进行调整。</p>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>类比前面的例子，无法办理业务时的处理方式，帮助记忆:</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918144833661.png" srcset="/img/loading.gif" lazyload alt="image-20220918144833661"></p>
<ul>
<li><strong>AbortPolicy</strong> :直接抛出异常，默认使用此策略. </li>
<li><strong>CallerRunsPolicy</strong>:用调用者所在的线程来执行任务</li>
<li><strong>DiscardOldestPolicy</strong>:丢弃阻塞队列里最老的任务，也就是队列里靠前的任务. </li>
<li><strong>DiscardPolicy</strong> :当前任务直接丢弃</li>
</ul>
<p>想实现自己的拒绝策略，实现<code>RejectedExecutionHandler</code>接口即可。</p>
<h2 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h2><p>常用的阻塞队列主要有以下几种:</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918145055227.png" srcset="/img/loading.gif" lazyload alt="image-20220918145055227"></p>
<ul>
<li><code>ArrayBlockingQueue</code>: ArrayBlockingQueue(有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</li>
<li><code>LinkedBlockingQueue</code>: LinkedBlockingQueue(可设置容量队列）是基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene;newFixedThreadPool线程池使用了这个队列</li>
<li><code>DelayQueue</code>: DelayQueue(延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</li>
<li><code>PriorityBlockingQueue</code>: PriorityBlockingQueue(优先级队列）是具有优先级的无界阻塞队列</li>
<li><code>SynchronousQueue</code>: SynchronousQueue(同步队列）是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</li>
</ul>
<h2 id="线程池提交execute和submit"><a href="#线程池提交execute和submit" class="headerlink" title="线程池提交execute和submit"></a>线程池提交execute和submit</h2><p><strong>1.</strong> <code>execute</code>用于提交不需要返回值的任务</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">threadsPool.execute(new Runnable() &#123;
@Override public void run() &#123;
&#x2F;&#x2F; TODO Auto-generated method stub &#125;
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><strong>2.</strong> <code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个<code>future</code>类型的对象，通过这个<code>future</code>对象可以判断任务是否执行成功，并且可以通过<code>future</code>的<code>get()</code>方法来获取返回值</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>harReturnValuetask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">&#123;</span> <span class="token class-name">Object</span> s <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token comment">// 处理中断异常</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token comment">// 处理无法执行任务异常</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
<span class="token comment">// 关闭线程池 executor.shutdown();</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>可以通过调用线程池的<code>shutdown</code> 或<code>shutdownNow</code>方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的<code>interrupt</code>方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>
<p><strong>shutdown()将线程池状态置为shutdown,并不会立即停止</strong>∶</p>
<ol>
<li>停止接收外部<code>submit</code>的任务</li>
<li>内部正在跑的任务和队列里等待的任务，会执行完</li>
<li>等到第二步完成后，才真正停止</li>
</ol>
<p><strong>shutdownNow()将线程池状态置为stop。一般会立即停止，事实上不一定</strong>:</p>
<ol>
<li>和<code>shutdown()</code>一样，先停止接收外部提交的任务</li>
<li>忽略队列里等待的任务</li>
<li>尝试将正在跑的任务interrupt中断</li>
<li>返回未执行的任务列表</li>
</ol>
<p><strong>shutdown和shutdownnow简单来说区别如下</strong>:</p>
<ul>
<li><code>shutdownNow()</code>能立即停止线程池，正在跑的和正在等待的任务都停下了。这样做立即生效，但是风险也比较大。</li>
<li><code>shutdown()</code>只是关闭了提交通道，用<code>submit()</code>是无效的;而内部的任务该怎么跑还是怎么跑，跑完再彻底停止线程池。</li>
</ul>
<h2 id="四种常见的线程池"><a href="#四种常见的线程池" class="headerlink" title="四种常见的线程池"></a>四种常见的线程池</h2><p>面试常问，主要有四种，都是通过工具类<code>Excutors</code>创建出来的，需要注意，阿里巴巴《Java开发手册》里禁止使用这种方式来创建线程池。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918160628630.png" srcset="/img/loading.gif" lazyload alt="image-20220918160628630"></p>
<ul>
<li><strong>newFixedThreadPool(固定数目线程的线程池)</strong></li>
<li><strong>newCachedThreadPool (可缓存线程的线程池)</strong></li>
<li><strong>newSingleThreadExecutor(单线程的线程池)</strong></li>
<li><strong>newScheduledThreadPool(定时及周期执行的线程池)</strong></li>
</ul>
<h2 id="四种常见线程池的原理"><a href="#四种常见线程池的原理" class="headerlink" title="四种常见线程池的原理"></a>四种常见线程池的原理</h2><p>前三种线程池的构造直接调用<code>ThreadPoolExecutor</code>的构造方法</p>
<h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>
<span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">,</span><span class="token number">0L</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">,</span>
<span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>threadFactory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h5 id="线程池特点"><a href="#线程池特点" class="headerlink" title="线程池特点"></a>线程池特点</h5><ul>
<li>核心线程数为 1</li>
<li>最大线程数也为 1</li>
<li>阻塞队列是无界队列LinkedBlockingQueue，可能会导致OOM</li>
<li>keepAliveTime为 0</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918161137672.png" srcset="/img/loading.gif" lazyload alt="image-20220918161137672"></p>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><ul>
<li>提交任务</li>
<li>线程池是否有一条线程在，如果没有，新建线程执行任务</li>
<li>如果有，将任务加到阻塞队列</li>
<li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个线程执行任务。</li>
</ul>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><p>适用于串行执行任务的场景，一个任务一个任务地执行。</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><strong>newFixedThreadPool</strong></h3><h4 id="线程池特点-1"><a href="#线程池特点-1" class="headerlink" title="线程池特点"></a>线程池特点</h4><ul>
<li>核心线程数和最大线程数大小一样</li>
<li>没有所谓的非空闲时间，即<code>keepAliveTime</code>为 0</li>
<li>阻塞队列为无界队列<code>LinkedBlockingQueue</code>，可能会导致<code>OOM</code></li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918161756915.png" srcset="/img/loading.gif" lazyload alt="image-20220918161756915"></p>
<h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><ul>
<li>提交任务</li>
<li>如果线程数少于核心线程，创建核心线程执行任务</li>
<li>如果线程数等于核心线程，把任务添加到<code>LinkedBlockingQueue</code>阻塞队列</li>
<li>如果线程执行完任务，去阻塞队列取任务，继续执行。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><code>FixedThreadPool</code> 适用于处理CPU密集型的任务，确保CPU在长期被工作线程使用的情况下，尽可能的少的分配线程，即适用执行长期的任务。</p>
<h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><strong>newCachedThreadPool</strong></h3><h4 id="线程池特点-2"><a href="#线程池特点-2" class="headerlink" title="线程池特点"></a>线程池特点</h4><ul>
<li>核心线程数为 0</li>
<li>最大线程数为<code>Integer.MAX_VALUE</code>，即无限大，可能会因为无限创建线程，导致<code>OOM</code></li>
<li>阻塞队列是<code>SynchronousQueue</code></li>
<li>非核心线程空闲存活时间为 60 秒</li>
</ul>
<p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。由于空闲 60 秒的线程会被终止，长时间保持空闲的 <code>CachedThreadPool</code> 不会占用任何资源。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918162414278.png" srcset="/img/loading.gif" lazyload alt="image-20220918162414278"></p>
<h4 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h4><ul>
<li>提交任务</li>
<li>因为没有核心线程，所以任务直接加到<code>SynchronousQueue</code>队列。</li>
<li>判断是否有空闲线程，如果有，就去取出任务执行。</li>
<li>如果没有空闲线程，就新建一个线程执行。</li>
<li>执行完任务的线程，还可以存活 60 秒，如果在这期间，接到任务，可以继续活下去；否则，被销毁。</li>
</ul>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><p>用于并发执行大量短期的小任务。</p>
<h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a><strong>newScheduledThreadPool</strong></h3><figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">,</span> <span class="token constant">NANOSECONDS</span><span class="token punctuation">,</span>
			<span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h4 id="线程池特点-3"><a href="#线程池特点-3" class="headerlink" title="线程池特点"></a>线程池特点</h4><ul>
<li>最大线程数为<code>Integer.MAX_VALUE</code>，也有<code>OOM</code>的风险</li>
<li>阻塞队列是<code>DelayedWorkQueue</code></li>
<li><code>keepAliveTime</code>为 0</li>
<li><code>scheduleAtFixedRate()</code> ：按某种速率周期执行</li>
<li><code>scheduleWithFixedDelay()</code>：在某个延迟后执行</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918162917701.png" srcset="/img/loading.gif" lazyload alt="image-20220918162917701"></p>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><ul>
<li>线程从<code>DelayQueue</code>中获取已到期的<code>ScheduledFutureTask（DelayQueue.take()）</code>。到期任务是指<code>ScheduledFutureTask</code>的<code>time</code>大于等于当前时间。</li>
<li>线程执行这个<code>ScheduledFutureTask</code>。</li>
<li>线程修改<code>ScheduledFutureTask</code>的<code>time</code>变量为下次将要被执行的时间。</li>
<li>线程把这个修改<code>time</code>之后的<code>ScheduledFutureTask</code>放回<code>DelayQueue</code>中（<code>DelayQueue.add()</code>）。</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918163436617.png" srcset="/img/loading.gif" lazyload alt="image-20220918163436617"></p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>周期性执行任务的场景，需要限制线程数量的场景</p>
<blockquote>
<p>使用无界队列的线程池会导致什么问题吗？</p>
</blockquote>
<p>例如<code>newFixedThreadPool</code>使用了无界的阻塞队列<code>LinkedBlockingQueue</code>，如果线程获取一个任务后，任务的执行时间比较长，会导致队列的任务越积越多，导致机器内存使用不停飙升，最终导致<code>OOM</code>。</p>
<h2 id="线程的池异常处理"><a href="#线程的池异常处理" class="headerlink" title="线程的池异常处理"></a>线程的池异常处理</h2><p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p>
<p>常见的异常处理方式:</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918184846167.png" srcset="/img/loading.gif" lazyload alt="image-20220918184846167"></p>
<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>线程池有这几个状态:<code>RUNNING</code>,<code>SHUTDOWN</code>,<code>STOP</code>,<code>TIDYING</code>,<code>TERMINATED</code>。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//线程池状态</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">RUNNING</span> <span class="token operator">=</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SHUTDOWN</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">STOP</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TIDYING</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">TERMINATED</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">COUNT_BITS</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>线程池各个状态切换图:</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918185038624.png" srcset="/img/loading.gif" lazyload alt="image-20220918185038624"></p>
<p><strong>RUNNING</strong></p>
<ul>
<li>该状态的线程池会接收新任务，并处理阻塞队列中的任务;</li>
<li>调用线程池的shutdown()方法，可以切换到SHUTDOWN状态;</li>
<li>调用线程池的shutdownNow()方法，可以切换到STOP状态;</li>
</ul>
<p><strong>SHUTDOWN</strong></p>
<ul>
<li>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务;</li>
<li>队列为空，并且线程池中执行的任务也为空.进入TIDYING状态;</li>
</ul>
<p><strong>STOP</strong></p>
<ul>
<li>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务;</li>
<li>线程池中执行的任务为空,进入<code>TIDYING</code>状态;</li>
</ul>
<p><strong>TIDYING</strong></p>
<ul>
<li>该状态表明所有的任务已经运行终止，记录的任务数量为0。</li>
<li><code>terminated()</code>执行完毕，进入<code>TERMINATED</code>状态</li>
</ul>
<p><strong>TERMINATED</strong></p>
<ul>
<li>该状态表示线程池彻底终止</li>
</ul>
<h2 id="线程池实现参数的动态修改"><a href="#线程池实现参数的动态修改" class="headerlink" title="线程池实现参数的动态修改"></a>线程池实现参数的动态修改</h2><p>线程池提供了几个setter方法来设置线程池的参数。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918191909826.png" srcset="/img/loading.gif" lazyload alt="image-20220918191909826"></p>
<p>这里主要有两个思路:</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918191935001.png" srcset="/img/loading.gif" lazyload alt="image-20220918191935001"></p>
<ul>
<li>在我们微服务的架构下，可以利用配置中心如Nacos、Apollo等等，也可以自己开发配置中心。业务服务读取线程池配置，获取相应的线程池实例来修改线程池的参数。</li>
<li>如果限制了配置中心的使用，也可以自己去扩展ThreadPoolExecutor ,重写方法，监听线程池参数变化,来动态修改线程池参数。</li>
</ul>
<h2 id="线程池调优"><a href="#线程池调优" class="headerlink" title="线程池调优"></a>线程池调优</h2><p>线程池配置没有固定的公式，通常事前会对线程池进行一定评估，常见的评估方案如下:</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918192126850.png" srcset="/img/loading.gif" lazyload alt="image-20220918192126850"></p>
<p>上线之前也要进行充分的测试，上线之后要建立完善的线程池监控机制。<br>事中结合监控告警机制，分析线程池的问题，或者可优化点，结合线程池动态参数配置机制来调整配置。<br>事后要注意仔细观察，随时调整。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918192216120.png" srcset="/img/loading.gif" lazyload alt="image-20220918192216120"></p>
<p>具体的调优案例可以查看参考[7]美团技术博客。</p>
<h2 id="单机线程池执行断电了应该怎么处理"><a href="#单机线程池执行断电了应该怎么处理" class="headerlink" title="单机线程池执行断电了应该怎么处理"></a>单机线程池执行断电了应该怎么处理</h2><p>我们可以对正在处理和阻塞队列的任务做事务管理或者对阻塞队列中的任务持久化处理，并且当断电或者系统崩溃，操作无法继续下去的时候，可以通过回溯日志的方式来撤销正在处理的已经执行成功的操作。然后重新执行整个阻塞队列。</p>
<p>也就是说，对阻塞队列持久化;正在处理任务事务控制;断电之后正在处理任务的回滚，通过日志恢复该次操作;服务器重启后阻塞队列中的数据再加载。</p>
<h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p><code>Fork/Join</code>框架是<code>Java7</code>提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>
<p>要想掌握<code>Fork/Join</code>框架，首先需要理解两个点，<code>分而治之</code>和<code>工作窃取算法</code>。</p>
<p><strong>分而治之</strong></p>
<p><code>Fork/Join</code>框架的定义，其实就体现了分治思想:将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918205234717.png" srcset="/img/loading.gif" lazyload alt="image-20220918205234717"></p>
<p><strong>工作窃取算法</strong></p>
<p>大任务拆成了若干个小任务，把这些小任务放到不同的队列里，各自创建单独线程来执行队列里的任务。</p>
<p>那么问题来了，有的线程干活块，有的线程干活慢。干完活的线程不能让它空下来，得让它去帮没干完活的线程干活。它去其它线程的队列里窃取一个任务来执行，这就是所谓的<code>工作窃取</code>。<br>工作窃取发生的时候，它们会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常任务会使用双端队列，被窃取任务线程永远从双端队列的头部拿，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918205449640.png" srcset="/img/loading.gif" lazyload alt="image-20220918205449640"></p>
<p>看一个<code>Fork/Join</code>框架应用的例子，计算1~n之间的和:1+2+3+…+n</p>
<ul>
<li>设置一个分割阈值，任务大于阈值就拆分任务</li>
<li>任务有结果，所以需要继承<code>RecursiveTask</code></li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountTask</span> <span class="token keyword">extends</span> <span class="token class-name">RecursiveTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">THRESHOLD</span> <span class="token operator">=</span> <span class="token number">16</span> <span class="token punctuation">;</span> <span class="token comment">// 阈值</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> start<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> end<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> start<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> end<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token class-name">Integer</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>
    	<span class="token comment">// 如果任务足够小就计算任务</span>
    	<span class="token keyword">boolean</span> canCompute <span class="token operator">=</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token constant">THRESHOLD</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>canCompute<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    	<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 如果任务大于阈值，就分裂成两个子任务计算</span>
        <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> end<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token punctuation">;</span>
        <span class="token class-name">CountTask</span> leftTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CountTask</span> rightTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span>middle <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 执行子任务</span>
        leftTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rightTask<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待子任务执行完，并得到其结果</span>
        <span class="token keyword">int</span> leftResult <span class="token operator">=</span> leftTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> rightResult <span class="token operator">=</span> rightTask<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 合并子任务</span>
        sum <span class="token operator">=</span> leftResult <span class="token operator">+</span> rightResult<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ForkJoinPool</span> forkJoinPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 生成一个计算任务，负责计算1+2+3+4</span>
        <span class="token class-name">CountTask</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountTask</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行一个任务</span>
        <span class="token class-name">Future</span> result <span class="token operator">=</span> forkJoinPool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><code>ForkJoinTask</code>与一般<code>Task</code>的主要区别在于它需要实现<code>compute</code>方法，在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果比较大，就必须分割成两个子任务，每个子任务在调用<code>fork</code>方法时，又会进<code>compute</code>方法，看看当前子任务是否需要继续分割成子任务，如果不需要继续分割，则执行当前子任务并返回结果。使用<code>join</code>方法会等待子任务执行完并得到其结果。</p>
<h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="CountDownLatch-倒计数器"><a href="#CountDownLatch-倒计数器" class="headerlink" title="CountDownLatch(倒计数器)"></a>CountDownLatch(倒计数器)</h2><p><code>CountDownLatch</code>，倒计数器，有两个常见的应用场景[18]:</p>
<h3 id="场景1-协调子线程结束动作-等待所有手线程运行结束"><a href="#场景1-协调子线程结束动作-等待所有手线程运行结束" class="headerlink" title="场景1:协调子线程结束动作:等待所有手线程运行结束"></a>场景1:协调子线程结束动作:等待所有手线程运行结束</h3><p><code>CountDownLatch</code>允许一个或多个线程等待其他线程完成操作。<br>例如，我们很多人喜欢玩的王者荣耀，开黑的时候，得等所有人都上线之后，才能开打。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918215540646.png" srcset="/img/loading.gif" lazyload alt="image-20220918215540646"></p>
<p>CountDownLatch模仿这个场景(参考[18]):</p>
<p>创建大乔、兰陵王、安其拉、哪吒和铠等五个玩家，主线程必须在他们都完成确认后，才可以继续运行。</p>
<p>在这段代码中，<code>new CountDownLatch(5)</code>用户创建初始的<code>latch</code>数量，各玩家通过<code>countDownLatch.countDown()</code>完成状态确认，主线程通过<code>countDownLatch.await()</code>等待。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 大乔 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>countDownLatch<span class="token operator">::</span><span class="token function">countDown</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 兰陵王 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>countDownLatch<span class="token operator">::</span><span class="token function">countDown</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 安其拉 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>countDownLatch<span class="token operator">::</span><span class="token function">countDown</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 哪吒 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>countDownLatch<span class="token operator">::</span><span class="token function">countDown</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 铠 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 稍等，上个卫生间，⻢上到...</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span> <span class="token number">1500</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    	countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        大乔<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        兰陵王<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        安其拉<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        哪吒<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        铠<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"所有玩家已经就位！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<h3 id="场景2-协调子线程开始动作-统一各线程动作开始的时机"><a href="#场景2-协调子线程开始动作-统一各线程动作开始的时机" class="headerlink" title="场景2.协调子线程开始动作:统一各线程动作开始的时机"></a>场景2.协调子线程开始动作:统一各线程动作开始的时机</h3><p>王者游戏中也有类似的场景，游戏开始时，各玩家的初始状态必须一致。不能有的玩家都出完装了，有的才降生。</p>
<p>所以大家得一块出生，在这个场景中，仍然用五个线程代表大乔、兰陵王、安其拉、哪吒和铠等五个玩家。需要注意的是，各玩家虽然都调用了start()线程，但是它们在运行时都在等待countDownLatch的信号，在信号未收到前，它们不会往下执行。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220918220618330.png" srcset="/img/loading.gif" lazyload alt="image-20220918220618330"></p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 大乔 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 兰陵王 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 安其拉 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 哪吒 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> 铠 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">waitToFight</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    大乔<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    兰陵王<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    安其拉<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    哪吒<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    铠<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"敌方还有 5 秒达到战场，全军出击！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">waitToFight</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> countDownLatch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
    	countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在此等待信号再继续</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"收到，发起进攻！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p><code>CountDownLatch</code>的 <strong>核心方法</strong> 也不多：</p>
<ul>
<li><code>await()</code> ：等待<code>latch</code>降为 0 ；</li>
<li><code>boolean await(long timeout, TimeUnit unit)</code> ：等待<code>latch</code>降为 0 ，但是可以设置超时时间。比如有玩家超时未确认，那就重新匹配，总不能为了某个玩家等到天荒地老。</li>
<li><code>countDown()</code> ：<code>latch</code>数量减 1 ；</li>
<li><code>getCount()</code> ：获取当前的<code>latch</code>数量。</li>
</ul>
<h2 id="CyclicBarrier-同步屏障"><a href="#CyclicBarrier-同步屏障" class="headerlink" title="CyclicBarrier(同步屏障)"></a>CyclicBarrier(同步屏障)</h2><p><code>CyclicBarrier</code>的字面意思是可循环使用<code>(Cyclic</code>）的屏障<code>(Barrier)</code>。它要做的事情是，让组线程到达一个屏障（也可以叫<code>同步点</code>)时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。<br>它和<code>CountDownLatch</code>类似，都可以协调多线程的结束动作，在它们结束后都可以执行特定动作，但是为什么要有<code>CyclicBarrier</code>，自然是它有和<code>CountDownLatch</code>不同的地方。<br>不知道你听没听过一个新人UP主小约翰可汗，小约翰生平有两大恨――“想结衣结衣不依.迷爱理爱理不理。”我们来还原一下事情的经过:小约翰在亲政后认识了新垣结衣，于是决定第一次选妃，向结衣表白，等待回应。然而新垣结衣回应嫁给了星野源，小约翰伤心欲绝，发<br>誓生平不娶，突然发现了铃木爱理，于是小约翰决定第二次选妃，求爱理搭理，等待回应。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920095255427.png" srcset="/img/loading.gif" lazyload alt="image-20220920095255427"></p>
<p>我们拿代码模拟这一场景，发现<code>CountDownLatch</code>无能为力了，因为<code>CountDownLatch</code>的使用是一次性的，无法重复利用，而这里等待了两次。此时，我们用<code>CyclicBarrier</code>就可以实现，因为它可以重复利用。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920095502269.png" srcset="/img/loading.gif" lazyload alt="image-20220920095502269"></p>
<p>运行结果:</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920131528319.png" srcset="/img/loading.gif" lazyload alt="image-20220920131528319"></p>
<p><code>CyclicBarrier</code>最最核心的方法，仍然是<code>await()</code> :</p>
<p>如果当前线程不是第一个到达屏障的话，它将会进入等待，直到其他线程都到达，除非发生被中断、屏障被拆除、屏障被重设等情况;<br>上面的例子抽象一下，本质上它的流程就是这样就是这样:</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920131709222.png" srcset="/img/loading.gif" lazyload alt="image-20220920131709222"></p>
<h2 id="CyclicBarrier和CountDownLatch有什么区别"><a href="#CyclicBarrier和CountDownLatch有什么区别" class="headerlink" title="CyclicBarrier和CountDownLatch有什么区别"></a>CyclicBarrier和CountDownLatch有什么区别</h2><p>两者最核心的区别:</p>
<ul>
<li><code>CountDownLatch</code>是一次性的，而<code>CyclicBarrier</code>则可以多次设置屏障,实现重复利用;</li>
<li><code>CountDownLatch</code>中的各个子线程不可以等待其他线程，只能完成自己的任务;而CyclicBarrier中的各个线程可以等待其他线程</li>
</ul>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920131947647.png" srcset="/img/loading.gif" lazyload alt="image-20220920131947647"></p>
<h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore(信号量)"></a>Semaphore(信号量)</h2><p><code>Semaphore(信号量)</code>是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<br>听起来似乎很抽象，现在汽车多了，开车出门在外的一个老大难问题就是停车。停车场的车位是有限的，只能允许若干车辆停泊，如果停车场还有空位，那么显示牌显示的就是绿灯和剩余的车位，车辆就可以驶入;如果停车场没位了，那么显示牌显示的就是绿灯和数字0，车辆就得等待。如果满了的停车场有车离开，那么显示牌就又变绿,显示空车位数量，等待的车辆就能进停车场。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920132118614.png" srcset="/img/loading.gif" lazyload alt="image-20220920132118614"></p>
<p>我们把这个例子类比一下，车辆就是线程，进入停车场就是线程在执行，离开停车场就是线程执行完毕，看见红灯就表示线程被阻塞，不能执行，<code>Semaphore</code>的本质就是<code>协调多个线程对共享资源的获取</code>。</p>
<p><img src="/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920132354314.png" srcset="/img/loading.gif" lazyload alt="image-20220920132354314"></p>
<p>我们再来看一个<code>Semaphore的</code>用途:它可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。<br>假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用<code>Semaphore</code>来做流量控制，如下:</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreTest</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">THREAD_COUNT</span> <span class="token operator">=</span> <span class="token number">30</span> <span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> threadPool <span class="token operator">=</span><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token constant">THREAD_COUNT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Semaphore</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span> <span class="token number">10</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">THREAD_COUNT</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            s<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"save data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            s<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>在代码中，虽然有30个线程在执行，但是只允许10个并发执行。<code>Semaphore</code>的构造方法<code>Semaphore (int permits)</code>接受一个整型的数字，表示可用的许可证数量。<code>Semaphore(10)</code>表示允许10个线程获取许可证，也就是最大并发数是10。<code>Semaphore</code>的用法也很简单，首先线程使用<code>Semaphore</code>的<code>acquire()</code>方法获取一个许可证，使用完之后调用<code>release()</code>方法归还许可证。还可以用<code>tryAcquire()</code>方法尝试获取许可证。</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p><code>Exchanger(交换者</code>）是一个用于线程间协作的工具类。<code>Exchanger</code>用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。</p>
<p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220920134119485.png" srcset="/img/loading.gif" lazyload alt="image-20220920134119485"></p>
<p>这两个线程通过<code>exchange</code>方法交换数据，如果第一个线程先执行<code>exchange()</code>方法，它会一直等待第二个线程也执行<code>exchange</code>方法，当`两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<p><code>Exchanger</code>可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。<code>Exchanger</code>也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致。</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExchangerTest</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> exgr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Exchanger</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ExecutorService</span> threadPool <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token string">"银行流水A"</span><span class="token punctuation">;</span> <span class="token comment">// A录入银行流水数据</span>
        exgr<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> <span class="token class-name">B</span> <span class="token operator">=</span> <span class="token string">"银行流水B"</span><span class="token punctuation">;</span> <span class="token comment">// B录入银行流水数据</span>
        <span class="token class-name">String</span> <span class="token class-name">A</span> <span class="token operator">=</span> exgr<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A和B数据是否一致："</span> <span class="token operator">+</span> <span class="token class-name">A</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，A录入的是："</span><span class="token operator">+</span> <span class="token class-name">A</span> <span class="token operator">+</span> <span class="token string">"，B录入是："</span> <span class="token operator">+</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	threadPool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>假如两个线程有一个没有执行<code>exchange()</code>方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用<code>exchange(V x, long timeOut，TimeUnit unit)</code>设置最大等待时长。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">#Java并发编程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试-Java并发编程</div>
      <div>https://weishao-996.github.io/2022/09/02/面试-Java并发编程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wei Shao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月2日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/09/06/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/" title="面试-Java基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面试-Java基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/08/31/%E9%9D%A2%E8%AF%95-Mybatis/" title="面试-Mybatis">
                        <span class="hidden-mobile">面试-Mybatis</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'weishao-996/commit-utterance');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-left: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="面试"
        id="heading-1573c74e227f14ded2daa71bb049ecda" role="tab" data-toggle="collapse" href="#collapse-1573c74e227f14ded2daa71bb049ecda"
        aria-expanded="true"
      >
        面试
        <span class="list-group-count">(6)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-1573c74e227f14ded2daa71bb049ecda"
           role="tabpanel" aria-labelledby="heading-1573c74e227f14ded2daa71bb049ecda">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/2022/09/06/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/" title="面试-Java基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Java基础</span>
        </a>
      
    
      
      
        <a href="/2022/09/12/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/" title="面试-Java容器"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Java容器</span>
        </a>
      
    
      
      
        <a href="/2022/09/02/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="面试-Java并发编程"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">面试-Java并发编程</span>
        </a>
      
    
      
      
        <a href="/2022/08/31/%E9%9D%A2%E8%AF%95-Mybatis/" title="面试-Mybatis"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Mybatis</span>
        </a>
      
    
      
      
        <a href="/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL/" title="面试-Mysql"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Mysql</span>
        </a>
      
    
      
      
        <a href="/2022/08/29/%E9%9D%A2%E8%AF%95-Spring/" title="面试-Spring"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">面试-Spring</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
