<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="威少996">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://weishao-996.github.io/2022/08/29/面试-spring/"/>
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/img/bg/手绘火箭.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/bg/手绘火箭.png">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/img/bg/%E6%89%8B%E7%BB%98%E7%81%AB%E7%AE%AD.png">
    
    <title>
        
            面试-Spring |
        
        威少のBlog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/fonts.css">

    
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"weishao-996.github.io","root":"/","language":"zh-CN"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/img/bg/WechatIMG48.png","favicon":"/img/bg/手绘火箭.png","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Theme Redefine"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.0","friend_links":{"columns":2}};
    REDEFINE.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
    
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                威少のBlog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        归档
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    target="_blank" rel="noopener" href="https://status.evanluo.top/"  >
                                    
                                        
                                            <i class="fa-regular fa-chart-bar"></i>
                                        
                                        状态
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/about">ME
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/EvanNotFound/hexo-theme-redefine">GITHUB
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://www.evanluo.top">BLOG
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a href="/friends">FRIENDS
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                归档
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        target="_blank" rel="noopener" href="https://status.evanluo.top/"  >
                             
                                
                                    <i class="fa-regular fa-chart-bar"></i>
                                
                                状态
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/about">ME</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://github.com/EvanNotFound/hexo-theme-redefine">GITHUB</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://www.evanluo.top">BLOG</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/friends">FRIENDS</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular">面试-Spring</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/img/bg/WechatIMG48.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">威少996</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2022-08-29 09:36:37</span>
        <span class="mobile">2022-08-29 09:36</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a><strong>Spring 基础</strong></h1><h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h2><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！</p>
<p>题外话 ： 语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。</p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。</p>
<p>比如说 Spring 自带 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829094121471.png"
                      alt="image-20220829094121471"
                ></p>
<p>Spring 最核心的思想就是不重新造轮子，开箱即用！</p>
<p>Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！</p>
<ul>
<li><p>Spring 官网：<a class="link"   target="_blank" rel="noopener" href="https://spring.io/" >https://spring.io/open in new window <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>Github 地址： <a class="link"   target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework" >https://github.com/spring-projects/spring-framework <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<h2 id="Spring的特性"><a href="#Spring的特性" class="headerlink" title="Spring的特性"></a>Spring的特性</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829094232799.png"
                      alt="image-20220829094232799"
                ></p>
<p>Spring有很多优点：</p>
<p><strong>1.IOC 和 DI 的支持</strong></p>
<p>Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用<br>于生成 Bean，并且管理 Bean 的生命周期，实现 <strong>高内聚低耦合</strong> 的设计理念。</p>
<p><strong>2.AOP 编程的支持</strong></p>
<p>Spring 提供了 <strong>面向切面编程</strong> ，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p>
<p><strong>3. 声明式事务的支持</strong></p>
<p>支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提<br>交、回滚的JDBC代码，都可以不用自己写了。</p>
<p><strong>4. 快捷测试的支持</strong></p>
<p>Spring 对 Junit 提供支持，可以通过 <strong>注解</strong> 快捷地测试 Spring 程序。</p>
<p><strong>5. 快速集成功能</strong></p>
<p>方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架<br>（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p>
<p><strong>6. 复杂API模板封装</strong></p>
<p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板<br>化的封装，这些封装 API 的提供使得应用难度大大降低。</p>
<h2 id="列举一些重要的-Spring-模块？"><a href="#列举一些重要的-Spring-模块？" class="headerlink" title="列举一些重要的 Spring 模块？"></a>列举一些重要的 Spring 模块？</h2><p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829095453700.png"
                      alt="image-20220829095453700"
                ></p>
<p><strong>Spring Core</strong></p>
<p>核心模块， Spring 其他所有的功能基本都需要依赖于该模块，主要提供 IoC 依赖注入功能的支持。</p>
<p><strong>Spring Aspects</strong></p>
<p>该模块为与 AspectJ 的集成提供支持。</p>
<p><strong>Spring AOP</strong></p>
<p>提供了面向切面的编程实现。</p>
<p><strong>Spring Data Access/Integration ：</strong></p>
<p>Spring Data Access/Integration 由 5 个模块组成：</p>
<ul>
<li><p>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</p>
</li>
<li><p>spring-tx : 提供对事务的支持。</p>
</li>
<li><p>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。</p>
</li>
<li><p>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。</p>
</li>
<li><p>spring-jms : Java 消息服务。</p>
</li>
</ul>
<p><strong>Spring Web</strong></p>
<p>Spring Web 由 4 个模块组成：</p>
<ul>
<li><p>spring-web ：对 Web 功能的实现提供一些最基础的支持。</p>
</li>
<li><p>spring-webmvc ： 提供对 Spring MVC 的实现。</p>
</li>
<li><p>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</p>
</li>
<li><p>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.</p>
</li>
</ul>
<p><strong>Spring Test</strong></p>
<p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p>
<h2 id="Spring有哪些常用注解呢？"><a href="#Spring有哪些常用注解呢？" class="headerlink" title="Spring有哪些常用注解呢？"></a>Spring有哪些常用注解呢？</h2><p>Spring有很多模块，甚至广义的SpringBoot、SpringCloud也算是Spring的一部分，我们来分模块，按功能来看一下一些常用的注解：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829095848193.png"
                      alt="image-20220829095848193" style="zoom:67%;" 
                >

<p><strong>Web</strong> :</p>
<p><strong>@Controller</strong>：组合注解（组合了@Component注解），应用在MVC层（控制层）。<br><strong>@RestController</strong>：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。<br><strong>@RequestMapping</strong>：用于映射Web请求，包括访问路径和参数。如果是Restful风格接又，还可以根据请求类型使用不同的注解：<br><strong>@GetMapping</strong><br><strong>@PostMapping</strong><br><strong>@PutMapping</strong><br><strong>@DeleteMapping</strong><br><strong>@ResponseBody</strong>：支持将返回值放在response内，而不是一个页面，通常用户返回json数据。<br><strong>@RequestBody</strong>：允许request的参数在request体中，而不是在直接连接在地址后面。<br><strong>@PathVariable</strong>：用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</p>
<p><strong>容器</strong> :</p>
<p><strong>@Component</strong>：表示一个带注释的类是一个“组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解。<br><strong>@Service</strong>：组合注解（组合了@Component注解），应用在service层（业务逻辑层）。<br><strong>@Repository</strong>：组合注解（组合了@Component注解），应用在dao层（数据访问层）。<br><strong>@Autowired</strong>：Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。<br><strong>@Qualifier</strong>：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解<br><strong>@Configuration</strong>：声明当前类是一个配置类（相当于一个Spring配置的xml文件）<br><strong>@Value</strong>：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟 ${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。<br><strong>@Bean</strong>：注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行init，在销毁之前执行destroy。<br><strong>@Scope</strong>:定义我们采用什么模式去创建Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。</p>
<p><strong>AOP :</strong></p>
<p><strong>@Aspect</strong>:声明一个切面（类上） 使用@After、@Before、@Around定义建言（advice），<br>可直接将拦截规则（切点）作为参数。<br><strong>@After</strong> ：在方法执行之后执行（方法上）。<br><strong>@Before</strong> ： 在方法执行之前执行（方法上）。<br><strong>@Around</strong> ： 在方法执行之前与之后执行（方法上）。<br><strong>@PointCut</strong> ： 声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）。</p>
<p><strong>事务</strong>：<br><strong>@Transactional</strong>：在要开启事务的方法上使用@Transactional注解，即可声明式开启事务。</p>
<h2 id="Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间什么关系?"></a>Spring,Spring MVC,Spring Boot 之间什么关系?</h2><p>很多人对 <strong>Spring,Spring MVC,Spring Boot</strong> 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。</p>
<p>Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p>
<p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829100915670.png"
                      alt="image-20220829100915670" style="zoom:80%;" 
                >

<p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 **Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)**的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829101135375.png"
                      alt="image-20220829101135375"
                ></p>
<p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p>
<p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p>
<p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p>
<h1 id="Spring-IOC-amp-AOP"><a href="#Spring-IOC-amp-AOP" class="headerlink" title="Spring IOC &amp; AOP"></a><strong>Spring IOC &amp; AOP</strong></h1><h2 id="谈谈自己对于-Spring-IoC-的了解"><a href="#谈谈自己对于-Spring-IoC-的了解" class="headerlink" title="谈谈自己对于 Spring IoC 的了解"></a>谈谈自己对于 Spring IoC 的了解</h2><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p>
<p><strong>为什么叫控制反转？</strong></p>
<ul>
<li><p><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</p>
</li>
<li><p><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829101428860.png"
                      alt="image-20220829101428860" style="zoom:80%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829101503950.png"
                      alt="image-20220829101503950" style="zoom:67%;" 
                >

<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p><strong>为什么要使⽤IOC呢？</strong></p>
<p>最主要的是两个字 解耦 ，硬编码会造成对象间的过度耦合，使用IOC之后，我们可以不用关心对象间的依赖，专心开发应用就行。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829101858257.png"
                      alt="image-20220829101858257" style="zoom:67%;" 
                >

<p>DI（依赖注入） ：指的是容器在实例化对象的时候把它依赖的类注入给它。有的说法IOC和DI是一回事，有的说法是IOC是思想，DI是IOC的实现。</p>
<hr>
<h2 id="能简单说⼀下Spring-IOC的实现机制吗？"><a href="#能简单说⼀下Spring-IOC的实现机制吗？" class="headerlink" title="能简单说⼀下Spring IOC的实现机制吗？"></a>能简单说⼀下Spring IOC的实现机制吗？</h2><p>Spring的IOC本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？</p>
<p><strong>生产产品 ：</strong></p>
<p>一个工厂最核心的功能就是生产产品。在Spring里，不用Bean自己来实例化，而是交给Spring，应该怎么实现呢？——答案毫无疑问， 反射 。那么这个厂子的生产管理是怎么做的？你应该也知道—— 工厂模式 。</p>
<p><strong>库存产品 ：</strong></p>
<p>工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。</p>
<p><strong>订单处理</strong> ：</p>
<p>还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。在Spring里，也有这样的订单，它就是我们bean的定义和依赖关系，可以是xml形式，也可以是我们最熟悉的注解形式。</p>
<p>我们简单地实现一个mini版的Spring IOC：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829102611661.png"
                      alt="image-20220829102611661" style="zoom:80%;" 
                >

<p>Bean定义：</p>
<p>Bean通过一个配置文件定义，把它解析成一个类型。</p>
<p>beans.properties<br>这里直接用了最方便解析的properties，这里直接用一个&lt;key,value&gt;类型的配置来代表Bean的定义，其中key是beanName，value是class</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userDao:cn.fighter3.bean.UserDao</span><br></pre></td></tr></table></figure></div>

<p>BeanDefinition.java<br>bean定义类，配置文件中bean定义对应的实体</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> String beanName;</span><br><span class="line"> <span class="keyword">private</span> Class beanClass;</span><br><span class="line"> <span class="comment">//省略getter、setter </span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>ResourceLoader.java<br>资源加载器，用来完成配置文件中配置的加载</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, BeanDefinition&gt; <span class="title function_">getResource</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"> <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span></span><br><span class="line">ResourceLoader.class.getResourceAsStream(<span class="string">&quot;/beans.properties&quot;</span>);</span><br><span class="line">      properties.load(inputStream);</span><br><span class="line">     Iterator&lt;String&gt; it =</span><br><span class="line">properties.stringPropertyNames().iterator();</span><br><span class="line">     <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> it.next();</span><br><span class="line">         <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> properties.getProperty(key);</span><br><span class="line">         <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>();</span><br><span class="line">         beanDefinition.setBeanName(key);</span><br><span class="line">         <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">         beanDefinition.setBeanClass(clazz);</span><br><span class="line">         beanDefinitionMap.put(key, beanDefinition);</span><br><span class="line">         &#125;</span><br><span class="line">         inputStream.close();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> beanDefinitionMap;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>BeanRegister.java<br>对象注册器，这里用于单例bean的缓存，我们大幅简化，默认所有bean都是单例的。可以看到所谓单例注册，也很简单，不过是往HashMap里存对象。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanRegister</span> &#123;</span><br><span class="line"> <span class="comment">//单例Bean缓存</span></span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, Object&gt; singletonMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取单例Bean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName bean名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">getSingletonBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> singletonMap.get(beanName);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册单例bean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerSingletonBean</span><span class="params">(String beanName, Object bean)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (singletonMap.containsKey(beanName)) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> singletonMap.put(beanName, bean);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>BeanFactory.java</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829103144117.png"
                      alt="image-20220829103144117" style="zoom:80%;" 
                >

<p>对象工厂，我们最 核心 的一个类，在它初始化的时候，创建了bean注册器，完成了资源的加载。<br>获取bean的时候，先从单例缓存中取，如果没有取到，就创建并注册一个bean</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">     <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">private</span> BeanRegister beanRegister;</span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">BeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//创建bean注册器</span></span><br><span class="line">         beanRegister = <span class="keyword">new</span> <span class="title class_">BeanRegister</span>();</span><br><span class="line">         <span class="comment">//加载资源</span></span><br><span class="line">         <span class="built_in">this</span>.beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ResourceLoader</span>().getResource();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取bean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName bean名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">         <span class="comment">//从bean缓存中取</span></span><br><span class="line">         <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanRegister.getSingletonBean(beanName);</span><br><span class="line">         <span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">//根据bean定义，创建bean</span></span><br><span class="line">         <span class="keyword">return</span> createBean(beanDefinitionMap.get(beanName));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建Bean</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanDefinition bean定义</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">     <span class="keyword">private</span> Object <span class="title function_">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanDefinition.getBeanClass().newInstance();</span><br><span class="line"> <span class="comment">//缓存bean</span></span><br><span class="line"></span><br><span class="line">        beanRegister.registerSingletonBean(beanDefinition.getBeanName(),</span><br><span class="line">        bean);</span><br><span class="line">         <span class="keyword">return</span> bean;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e)</span><br><span class="line">&#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>测试 <ul>
<li>UserDao.java<br>我们的Bean类，很简单</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryUserInfo</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;A good man.&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>单元测试</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApiTest</span> &#123;</span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test_BeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">//1.创建bean⼯⼚(同时完成了加载资源、创建注册单例bean注册器的操作)</span></span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactory</span>();</span><br><span class="line">    <span class="comment">//2.第⼀次获取bean（通过反射创建bean，缓存bean）</span></span><br><span class="line">     <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) beanFactory.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">     userDao1.queryUserInfo();</span><br><span class="line">     <span class="comment">//3.第⼆次获取bean（从缓存中获取bean）</span></span><br><span class="line">     <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) beanFactory.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">     userDao2.queryUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>运行结果</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A good man.</span><br><span class="line">A good man.</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="谈谈自己对于-AOP-的了解"><a href="#谈谈自己对于-AOP-的了解" class="headerlink" title="谈谈自己对于 AOP 的了解"></a>谈谈自己对于 AOP 的了解</h2><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829104652577.png"
                      alt="image-20220829104652577" style="zoom:80%;" 
                >

<p>具体来说，假如我现在要crud写一堆业务，可是如何业务代码前后前后进行打印日志和参数的校验呢？</p>
<p>我们可以把日志记录和数据校验可重用的功能模块分离出来，然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829104940660.png"
                      alt="image-20220829104940660" style="zoom:80%;" 
                >

<p>业务逻辑代码中没有参和通用逻辑的代码，业务模块更简洁，只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离，便于维护和升级，降低了业务逻辑和通用逻辑的耦合性。</p>
<p>AOP 可以将遍布应用各处的功能分离出来形成可重用的组件。在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能。从而实现对业务逻辑的隔离，提高代码的模块化能力。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829105759783.png"
                      alt="image-20220829105759783" style="zoom:80%;" 
                >

<p>AOP 的核心其实就是 动态代理 ，如果是实现了接又的话就会使用 JDK 动态代理，否则使用CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829105922451.png"
                     
                ></p>
<p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<h2 id="AOP有哪些核心概念？"><a href="#AOP有哪些核心概念？" class="headerlink" title="AOP有哪些核心概念？"></a>AOP有哪些核心概念？</h2><ul>
<li><p><strong>切面 （Aspect）</strong>：类是对物体特征的抽象，切面就是对横切关注点的抽象</p>
</li>
<li><p><strong>连接点 （Joinpoint）</strong>：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
</li>
<li><p><strong>切点 （Pointcut）</strong>：对连接点进行拦截的定位</p>
</li>
<li><p><strong>通知 （Advice）</strong>：所谓通知指的就是指拦截到连接点之后要执行的代码，也可以称作增强</p>
</li>
<li><p><strong>目标对象 （Target）</strong>：代理的目标对象</p>
</li>
<li><p><strong>织入 （Weabing）</strong>：织入是将增强添加到目标类的具体连接点上的过程。</p>
<ul>
<li><p><strong>编译期织入</strong>：切面在目标类编译时被织入</p>
</li>
<li><p><strong>类加载期织入</strong>：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</p>
</li>
<li><p><strong>运行期织入</strong>：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。Spring采用运行期织入，而AspectJ采用编译期织入和类加载器织入。</p>
</li>
<li><p><strong>引介 （introduction）</strong>：引介是一种特殊的增强，可以动态地为类添加一些属性和方法</p>
</li>
</ul>
</li>
</ul>
<h2 id="AOP有哪些环绕方式？"><a href="#AOP有哪些环绕方式？" class="headerlink" title="AOP有哪些环绕方式？"></a>AOP有哪些环绕方式？</h2><p>AOP 一般有 <strong>5 种</strong> 环绕方式：</p>
<ul>
<li><strong>前置通知 (@Before)</strong></li>
<li><strong>返回通知 (@AfterReturning)</strong></li>
<li><strong>异常通知 (@AfterThrowing)</strong></li>
<li><strong>后置通知 (@After)</strong></li>
<li><strong>环绕通知 (@Around)</strong></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829110716136.png"
                      alt="image-20220829110716136" style="zoom:80%;" 
                >

<p>多个切面的情况下，可以通过 @Order 指定先后顺序，数字越小，优先级越高。</p>
<hr>
<h2 id="说说你平时有用到AOP吗？"><a href="#说说你平时有用到AOP吗？" class="headerlink" title="说说你平时有用到AOP吗？"></a>说说你平时有用到AOP吗？</h2><p>SpringBoot项目中，利用AOP打印接又的入参和出参日志，以及执行时间，还是比较快捷的。</p>
<p>引入依赖：引入AOP依赖</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>自定义注解：自定义一个注解作为切点</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>配置AOP切面：</p>
<p><strong>@Aspect</strong>：标识切面<br><strong>@Pointcut</strong>：设置切点，这里以自定义注解为切点，定义切点有很多其它种方式，自定<br>义注解是比较常用的一种。<br><strong>@Before</strong>：在切点之前织入，打印了一些入参信息<br><strong>@Around</strong>：环绕切点，打印返回参数和接又执行时间</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebLogAspect</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span>LoggerFactory.getLogger(WebLogAspect.class);</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 以自定义 <span class="doctag">@WebLog</span> 注解为切点</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">webLog</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在切点之前织入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Before(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBefore</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 开始打印请求日志</span></span><br><span class="line">    <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span></span><br><span class="line">    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();</span><br><span class="line">    <span class="comment">// 打印请求相关参数</span></span><br><span class="line">    logger.info(<span class="string">&quot;========================================== Start</span></span><br><span class="line"><span class="string">    ==========================================&quot;</span>);</span><br><span class="line">    <span class="comment">// 打印请求 url</span></span><br><span class="line">    logger.info(<span class="string">&quot;URL : &#123;&#125;&quot;</span>,</span><br><span class="line">    request.getRequestURL().toString());</span><br><span class="line">    <span class="comment">// 打印 Http method</span></span><br><span class="line">    logger.info(<span class="string">&quot;HTTP Method : &#123;&#125;&quot;</span>, request.getMethod());</span><br><span class="line">    <span class="comment">// 打印调用 controller 的全路径以及执行方法</span></span><br><span class="line">    logger.info(<span class="string">&quot;Class Method : &#123;&#125;.&#123;&#125;&quot;</span>,</span><br><span class="line">    joinPoint.getSignature().getDeclaringTypeName(),</span><br><span class="line">    joinPoint.getSignature().getName());</span><br><span class="line">    <span class="comment">// 打印请求的 IP</span></span><br><span class="line">    logger.info(<span class="string">&quot;IP : &#123;&#125;&quot;</span>, request.getRemoteAddr());</span><br><span class="line">    <span class="comment">// 打印请求入参</span></span><br><span class="line">    logger.info(<span class="string">&quot;Request Args : &#123;&#125;&quot;</span>,<span class="keyword">new</span></span><br><span class="line">    <span class="title class_">ObjectMapper</span>().writeValueAsString(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在切点之后织入</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@After(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfter</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 结束后打个分隔线，方便查看</span></span><br><span class="line">    logger.info(<span class="string">&quot;===========================================End===========================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 环绕</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Around(&quot;webLog()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAround</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proceedingJoinPoint.proceed();</span><br><span class="line">    <span class="comment">// 打印出参</span></span><br><span class="line">	logger.info(<span class="string">&quot;Response Args : &#123;&#125;&quot;</span>, <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">ObjectMapper</span>().writeValueAsString(result));</span><br><span class="line">    <span class="comment">// 执行耗时</span></span><br><span class="line">    logger.info(<span class="string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>,</span><br><span class="line">    System.currentTimeMillis() - startTime);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>使用：只需要在接又上加上自定义注解</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@WebLog(desc = &quot;这是一个欢迎接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>执行结果：可以看到日志打印了入参、出参和执行时间</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829135120441.png"
                      alt="image-20220829135120441"
                ></p>
<h2 id="说说JDK-动态代理和-CGLIB-代理-？"><a href="#说说JDK-动态代理和-CGLIB-代理-？" class="headerlink" title="说说JDK 动态代理和 CGLIB 代理 ？"></a>说说JDK 动态代理和 CGLIB 代理 ？</h2><p>Spring的AOP是通过<strong>动态代理</strong>来实现的，动态代理主要有两种方式<strong>JDK动态代理</strong>和<strong>Cglib动态代理</strong>，这两种动态代理的使用和原理有些不同。</p>
<p><strong>JDK 动态代理</strong></p>
<p><strong>1.</strong> <strong>Interface</strong>：对于 JDK 动态代理，目标类需要实现一个Interface。<br><strong>2.</strong> <strong>InvocationHandler</strong>：InvocationHandler是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。<br><strong>3.</strong> <strong>Proxy</strong>：Proxy利用InvocationHandler动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。</p>
<p><strong>CgLib 动态代理</strong></p>
<p><strong>1.</strong> 使用JDK创建代理有一大限制，它只能为接又创建代理实例，而CgLib 动态代理就没有这个限制。<br><strong>2.</strong> CgLib 动态代理是使用字节码处理框架 ASM，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。<br><strong>3.</strong> CgLib 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</p>
<p>我们来看一个常见的小场景，客服中转，解决用户问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829135838484.png"
                      alt="image-20220829135838484"
                ></p>
<p><strong>JDK动态代理实现：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829135923848.png"
                      alt="image-20220829135923848"
                ></p>
<ul>
<li>接口</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISolver</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>目标类:需要实现对应接口</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solver</span> <span class="keyword">implements</span> <span class="title class_">ISolver</span> &#123;</span><br><span class="line">	    <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;疯狂掉头发解决问题......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>动态代理工厂:ProxyFactory，直接用反射方式生成一个目标对象的代理对象，这里用了一个匿名内部类方式重写InvocationHandler方法，实现接口重写也差不多</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">	<span class="comment">// 维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为目标对象生成代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method,Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class="line">         	<span class="comment">// 调用目标对象方法</span></span><br><span class="line">        	<span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target,args);</span><br><span class="line">        	System.out.println(<span class="string">&quot;问题已经解决啦！&quot;</span>);</span><br><span class="line">        	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//目标对象:程序员</span></span><br><span class="line">		<span class="type">ISolver</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solver</span>();</span><br><span class="line">		<span class="comment">//代理：客服小姐姐</span></span><br><span class="line">		<span class="type">ISolver</span> <span class="variable">csProxy</span> <span class="operator">=</span> (ISolver) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class="line">		<span class="comment">//目标方法：解决问题</span></span><br><span class="line">		csProxy.solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>Cglib动态代理实现：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829141015357.png"
                      alt="image-20220829141015357"
                ></p>
<p>目标类：Solver，这里目标类不用再实现接口。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;疯狂掉头发解决问题......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>动态代理工厂：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为目标对象生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//工具类</span></span><br><span class="line">    <span class="type">Enhancer</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">    <span class="comment">//设置父类</span></span><br><span class="line">    en.setSuperclass(target.getClass());</span><br><span class="line">    <span class="comment">//设置回调函数</span></span><br><span class="line">    en.setCallback(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//创建子类对象代理</span></span><br><span class="line">    <span class="keyword">return</span> en.create();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args,MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请问有什么可以帮到您？&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行目标对象的方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">    System.out.println(<span class="string">&quot;问题已经解决啦！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>客户端：Client</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目标对象:程序员</span></span><br><span class="line">        <span class="type">Solver</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solver</span>();</span><br><span class="line">        <span class="comment">//代理：客服小姐姐</span></span><br><span class="line">        <span class="type">Solver</span> <span class="variable">csProxy</span> <span class="operator">=</span> (Solver) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(developer).getProxyInstance();</span><br><span class="line">        <span class="comment">//目标方法：解决问题</span></span><br><span class="line">        csProxy.solve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<p><strong>Spring AOP 属于运行时增强</strong>，主要具有如下特点：</p>
<p><strong>1.</strong> 基于动态代理来实现，默认如果使用接又的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现<br><strong>2.</strong> Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现<br><strong>3.</strong> 在性能上，由于 Spring AOP 是基于动态代理来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。<br><strong>4.</strong> Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</p>
<p><strong>AspectJ</strong></p>
<p><strong>AspectJ 是一个易用的功能强大的 AOP 框架，属于编译时增强</strong>， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。</p>
<p>AspectJ 属于 <strong>静态织入</strong> ，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p>
<p><strong>1.</strong> <strong>编译期织入</strong>（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。<br><strong>2.</strong> <strong>编译后织入</strong>（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。<br><strong>3.</strong> <strong>类加载后织入</strong>（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</p>
<p><strong>整体对比如下：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829170537767.png"
                      alt="image-20220829170537767"
                ></p>
<hr>
<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a><strong>Spring Bean</strong></h1><h2 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h2><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Constructor-arg with <span class="string">&#x27;value&#x27;</span> attribute --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;...&quot;</span> class=<span class="string">&quot;...&quot;</span>&gt;</span><br><span class="line">   &lt;constructor-arg value=<span class="string">&quot;...&quot;</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div>

<p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829170830985.png"
                      alt="image-20220829170830985"
                ></p>
<p><strong>org.springframework.beans</strong>和 <strong>org.springframework.context</strong> 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看</p>
<hr>
<h2 id="Bean定义和依赖定义有哪些方式？"><a href="#Bean定义和依赖定义有哪些方式？" class="headerlink" title="Bean定义和依赖定义有哪些方式？"></a>Bean定义和依赖定义有哪些方式？</h2><p>有三种方式： 直接编码方式 、 配置文件方式 、 注解方式 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829171034149.png"
                      alt="image-20220829171034149"
                ></p>
<ul>
<li><strong>直接编码方式</strong>：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。</li>
<li><strong>配置文件方式</strong>：通过xml、propreties类型的配置文件，配置相应的依赖关系，Spring读取配置文件，完成依赖关系的注入。</li>
<li><strong>注解方式</strong>：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring会扫描注解，完成依赖关系的注入。</li>
</ul>
<h2 id="有哪些依赖注入的方法？"><a href="#有哪些依赖注入的方法？" class="headerlink" title="有哪些依赖注入的方法？"></a>有哪些依赖注入的方法？</h2><p>Spring支持 <strong>构造方法注入</strong> 、 <strong>属性注入</strong> 、 <strong>工厂方法注入</strong> ,其中工厂方法注入，又可以分为 <strong>静态工厂方法注入</strong> 和 <strong>非静态工厂方法注入</strong> 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829172455414.png"
                      alt="image-20220829172455414"
                ></p>
<ul>
<li><h6 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a><strong>构造方法注入</strong></h6><p>通过调用类的构造方法，将接又实现类通过构造方法变量传入</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CatDaoImpl</span><span class="params">(String message)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>. message = message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;CatDaoImpl&quot;</span> class=<span class="string">&quot;com.CatDaoImpl&quot;</span>&gt;</span><br><span class="line">	&lt;constructor-arg value=<span class="string">&quot; message &quot;</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p><strong>属性注入</strong></p>
<p>通过Setter方法完成调用类所需依赖的注入</p>
</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Id</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123; <span class="built_in">this</span>.id = id; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;id&quot;</span> class=<span class="string">&quot;com.id &quot;</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;id&quot;</span> value=<span class="string">&quot;123&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>工厂方法注入</strong><ul>
<li><strong>静态工厂注入</strong></li>
</ul>
</li>
</ul>
<p>​            静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让Spring 管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过 Spring 注入的形式获取：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactory</span> &#123; <span class="comment">//静态工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FactoryDao <span class="title function_">getStaticFactoryDaoImpl</span><span class="params">()</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StaticFacotryDaoImpl</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAction</span> &#123;</span><br><span class="line">    <span class="comment">//注入对象</span></span><br><span class="line">    <span class="keyword">private</span> FactoryDao staticFactoryDao;</span><br><span class="line">    <span class="comment">//注入对象的 set 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStaticFactoryDao</span><span class="params">(FactoryDao staticFactoryDao)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.staticFactoryDao = staticFactoryDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法</span></span><br><span class="line">&lt;bean name=<span class="string">&quot;springAction&quot;</span> class=<span class="string">&quot; SpringAction&quot;</span> &gt;</span><br><span class="line">	&lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt;</span><br><span class="line">	&lt;property name=<span class="string">&quot;staticFactoryDao&quot;</span> ref=<span class="string">&quot;staticFactoryDao&quot;</span>&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt;</span><br><span class="line">&lt;bean name=<span class="string">&quot;staticFactoryDao&quot;</span> class=<span class="string">&quot;DaoFactory&quot;</span> factory-method=<span class="string">&quot;getStaticFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;	</span><br></pre></td></tr></table></figure></div>

<ul>
<li>非静态工厂注入<br>非静态工厂，也叫实例工厂，意思是工厂方法不是静态的，所以我们需要首先 new 一个工厂实例，再调用普通的实例方法。</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FactoryDao <span class="title function_">getFactoryDaoImpl</span><span class="params">()</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FacotryDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAction</span> &#123;</span><br><span class="line">    <span class="comment">//注入对象</span></span><br><span class="line">    <span class="keyword">private</span> FactoryDao staticFactoryDao;</span><br><span class="line">    <span class="comment">//注入对象的 set 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactoryDao</span><span class="params">(FactoryDao FactoryDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.FactoryDao = FactoryDao;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=<span class="string">&quot;springAction&quot;</span> class=<span class="string">&quot;SpringAction&quot;</span>&gt;</span><br><span class="line">    &lt;!--使用非静态工厂的方法注入对象,对应下面的配置文件--&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;factoryDao&quot;</span> ref=<span class="string">&quot;factoryDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;</span><br><span class="line">&lt;bean name=<span class="string">&quot;daoFactory&quot;</span> class=<span class="string">&quot;com.DaoFactory&quot;</span>&gt;&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;bean name=<span class="string">&quot;factoryDao&quot;</span> factory-bean=<span class="string">&quot;daoFactory&quot;</span> factory-method=<span class="string">&quot;getFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="什么是自动装配？"><a href="#什么是自动装配？" class="headerlink" title="什么是自动装配？"></a>什么是自动装配？</h2><p>Spring IOC容器知道所有Bean的配置信息，此外，通过Java反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有Bean的这些信息后，Spring IOC容器就可以按照某种规则对容器中的Bean进行自动装配，而无须通过显式的方式进行依赖配置。</p>
<p>Spring提供的这种方式，可以按照某些规则进行Bean的自动装配，元素提供了一个指定自动装配类型的属性：<br>autowire=”&lt;自动装配类型&gt;”</p>
<p>Spring提供了 4 种自动装配类型：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220829212327996.png"
                      alt="image-20220829212327996" style="zoom:80%;" 
                >

<ul>
<li><strong>byName</strong>：根据名称进行自动匹配，假设Boss又一个名为car的属性，如果容器中刚好有一个名为car的bean，Spring就会自动将其装配给Boss的car属性</li>
<li><strong>byType</strong>：根据类型进行自动匹配，假设Boss有一个Car类型的属性，如果容器中刚好有一个Car类型的Bean，Spring就会自动将其装配给Boss这个属性</li>
<li><strong>constructor</strong>：与 byType类似， 只不过它是针对构造函数注入而言的。如果Boss有一个构造函数，构造函数包含一个Car类型的入参，如果容器中有一个Car类型的Bean，则Spring将自动把这个Bean作为Boss构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的Bean，则Spring将抛出异常。</li>
<li><strong>autodetect</strong>：根据Bean的自省机制决定采用byType还是constructor进行自动装配，如果Bean提供了默认的构造函数，则采用byType，否则采用constructor。</li>
</ul>
<hr>
<h2 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些?"></a>将一个类声明为 Bean 的注解有哪些?</h2><ul>
<li><p><strong>@Component</strong> ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</p>
</li>
<li><p><strong>@Repository</strong> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p>
</li>
<li><p><strong>@Service</strong> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p>
</li>
<li><p><strong>@Controller</strong> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p>
</li>
</ul>
<hr>
<h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ul>
<li><p>@Component 注解作用于类，而@Bean注解作用于方法。</p>
</li>
<li><p>@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p>
</li>
<li><p>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</p>
</li>
</ul>
<p>@Bean注解使用示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>上面的代码相当于下面的 xml 配置</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;transferService&quot;</span> class=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></div>

<p>下面这个例子是通过 @Component 无法实现的。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OneService <span class="title function_">getService</span><span class="params">(status)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl1</span>();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl2</span>();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="Autowired-和-Resource-的区别是什么？"><a href="#Autowired-和-Resource-的区别是什么？" class="headerlink" title="@Autowired 和 @Resource 的区别是什么？"></a>@Autowired 和 @Resource 的区别是什么？</h2><p><strong>Autowired</strong> 属于 <strong>Spring 内置</strong>的注解，默认的注入方式为<strong>byType</strong>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p>
<p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p>
<p>这种情况下，注入方式会变为 <strong>byName</strong>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 smsService 就是我这里所说的名称，这样应该比较好理解了吧。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smsService 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></table></figure></div>

<p>举个例子，SmsService 接口有两个实现类: SmsServiceImpl1和 SmsServiceImpl2，且它们都已经被 Spring 容器所管理。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="comment">// smsServiceImpl1 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="Autowired的实现原理？"><a href="#Autowired的实现原理？" class="headerlink" title="@Autowired的实现原理？"></a>@Autowired的实现原理？</h2><p>实现@Autowired的关键是： <strong>AutowiredAnnotationBeanPostProcessor</strong></p>
<p>在Bean的初始化阶段，会通过Bean后置处理器来进行一些前置和后置的处理。</p>
<p>实现@Autowired的功能，也是通过后置处理器来完成的。这个后置处理器就是<strong>AutowiredAnnotationBeanPostProcessor</strong>。</p>
<p>Spring在创建bean的过程中，最终会调用到<strong>doCreateBean()**方法，在doCreateBean()方法中会调用</strong>populateBean()<strong>方法，来为bean进行属性填充，完成自动装配等工作。<br>在populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行</strong>第二次后置处理器<strong>的调用，这个时候，就会调用到<br>**AutowiredAnnotationBeanPostProcessor</strong>的<strong>postProcessPropertyValues()**方法，在该方法中就会进行</strong>@Autowired注解**的解析，然后实现自动装配。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 属性赋值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd,<span class="meta">@Nullable</span> BeanWrapper bw)</span> &#123;</span><br><span class="line"><span class="comment">//............</span></span><br><span class="line">	<span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pvs == <span class="literal">null</span>) &#123;</span><br><span class="line">            pvs = mbd.getPropertyValues();</span><br><span class="line">        &#125;</span><br><span class="line">		PropertyValues pvsToUse;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">Iterator</span> <span class="variable">var9</span> <span class="operator">=</span><span class="built_in">this</span>.getBeanPostProcessorCache().instantiationAware.iterator();var9.hasNext(); pvs = pvsToUse) &#123;</span><br><span class="line">	<span class="type">InstantiationAwareBeanPostProcessor</span> <span class="variable">bp</span> <span class="operator">=</span>(InstantiationAwareBeanPostProcessor)var9.next();</span><br><span class="line">	pvsToUse =bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(),beanName);</span><br><span class="line">	<span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (filteredPds == <span class="literal">null</span>) &#123;</span><br><span class="line">        filteredPds =<span class="built_in">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行后处理器，填充属性，完成自动装配</span></span><br><span class="line">        <span class="comment">//调用InstantiationAwareBeanPostProcessor的</span></span><br><span class="line">		postProcessPropertyValues()方法</span><br><span class="line">pvsToUse =bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds,bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvsToUse == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>postProcessorPropertyValues()**方法的源码如下，在该方法中，会先调用</strong>findAutowiringMetadata()<strong>方法解析出bean中带有</strong>@Autowired注解、@Inject和@Value**注解的属性和方法。然后调用metadata.inject()方法，进行属性填充。</li>
</ul>
<hr>
<h2 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h2><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830105345669.png"
                      alt="image-20220830105345669" style="zoom:80%;" 
                >

<ul>
<li><p><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</p>
</li>
<li><p><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</p>
</li>
<li><p><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</p>
</li>
<li><p><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</p>
</li>
<li><p><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</p>
</li>
</ul>
<p><strong>如何配置 bean 的作用域呢？</strong></p>
<p><strong>xml 方式：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;...&quot;</span> class=<span class="string">&quot;...&quot;</span> scope=<span class="string">&quot;singleton&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></div>

<p><strong>注解方式：</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="单例-Bean-的线程安全问题了解吗？"><a href="#单例-Bean-的线程安全问题了解吗？" class="headerlink" title="单例 Bean 的线程安全问题了解吗？"></a>单例 Bean 的线程安全问题了解吗？</h2><p>首先结论在这：Spring中的单例Bean <strong>不是线程安全的</strong> 。</p>
<p>因为单例Bean，是全局只有一个Bean，所有<strong>线程共享</strong>。如果说单例Bean，是一个无状态的，也就是线程中的操作不会对Bean中的成员变量执行 <strong>查询</strong> 以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p>
<p>假如这个Bean是有状态的，也就是会对Bean中的成员变量进行<strong>写操作</strong>，那么可能就存在线程安全的问题。</p>
<p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830110402167.png"
                      alt="image-20220830110402167"
                ></p>
<hr>
<h2 id="单例Bean线程安全问题怎么解决呢？"><a href="#单例Bean线程安全问题怎么解决呢？" class="headerlink" title="单例Bean线程安全问题怎么解决呢？"></a>单例Bean线程安全问题怎么解决呢？</h2><p>常见的有这么些解决办法：</p>
<p><strong>1.</strong> 将Bean定义为多例这样每一个线程请求过来都会创建一个新的Bean，但是这样容器就不好管理Bean，不能这么办。<br><strong>2.</strong> 在Bean对象中尽量避免定义可变的成员变量削足适履了属于是，也不能这么干。<br><strong>3.</strong> 将Bean中的成员变量保存在ThreadLocal中⭐我们知道ThredLoca能保证多线程下变量的隔离，可以在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal里，这是推荐的一种方式。</p>
<hr>
<h2 id="Bean-的生命周期了解么"><a href="#Bean-的生命周期了解么" class="headerlink" title="Bean 的生命周期了解么?"></a>Bean 的生命周期了解么?</h2><p>在Spring中，基本容器BeanFactory和扩展容器ApplicationContext的实例化时机不太一样，BeanFactory采用的是延迟初始化的方式，也就是只有在第一次getBean()的时候，才会实例化Bean；ApplicationContext启动之后会实例化所有的Bean定义。</p>
<p>Spring IOC 中Bean的生命周期大致分为四个阶段： <strong>实例化</strong> （Instantiation）、 <strong>属性赋值</strong>（Populate）、 <strong>初始化</strong> （Initialization）、 <strong>销毁</strong> （Destruction）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830113023936.png"
                      alt="image-20220830113023936"
                ></p>
<p><strong>实例化</strong>：第 1 步，实例化一个 Bean 对象<br><strong>属性赋值</strong>：第 2 步，为 Bean 设置相关属性和依赖<br><strong>初始化</strong>：初始化的阶段的步骤比较多， 5 、 6 步是真正的初始化，第 3 、 4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean就可以被使用了<br><strong>销毁</strong>：第 8~10步，第 8 步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接又，为了后面第 9 、 10 步真正销毁 Bean 时再执行相应的方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830113036173.png"
                      alt="image-20220830113036173"
                ></p>
<p>简单总结⼀下，Bean⽣命周期⾥初始化的过程相对步骤会多⼀些，⽐如前置、后置的处理。 最后通过⼀个实例来看⼀下具体的细节</p>
<p>定义一个PersonBean 类，实现DisposableBean ,InitializingBean ,BeanFactoryAware , BeanNameAware 这 4 个接又，同时还有自定义的init-method和destroy-method 。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, BeanFactoryAware,BeanNameAware, DisposableBean &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">身份证号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Integer no;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">姓名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">PersonBean</span><span class="params">()</span> &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;1.调用构造方法：我出生了！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(Integer no)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">System.out.println(<span class="string">&quot;2.设置属性：我的名字叫&quot;</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String s)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;3.调用BeanNameAware#setBeanName方法:我要上学了，起</span></span><br><span class="line"><span class="string">了个学名&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span></span><br><span class="line">BeansException &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;4.调用BeanFactoryAware#setBeanFactory方法：选好学</span></span><br><span class="line"><span class="string">校了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;6.InitializingBean#afterPropertiesSet方法：入学</span></span><br><span class="line"><span class="string">登记&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;7.自定义init方法：努力上学ing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;9.DisposableBean#destroy方法：平淡的一生落幕了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;10.自定义destroy方法:睡了，别想叫醒我&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Bean使用中：工作，只有对社会没有用的人才放假。。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String</span></span><br><span class="line"><span class="params">beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;5.BeanPostProcessor.postProcessBeforeInitialization方</span></span><br><span class="line"><span class="string">法：到学校报名啦&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String</span></span><br><span class="line"><span class="params">beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;8.BeanPostProcessor#postProcessAfterInitialization方</span></span><br><span class="line"><span class="string">法：终于毕业，拿到毕业证啦！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>配置文件，指定init-method 和destroy-method 属性</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"> 		<span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"> 		<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">		http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">		</span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;myBeanPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.fighter3.spring.life.MyBeanPostProcessor&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;personBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.fighter3.spring.life.PersonBean&quot;</span></span></span><br><span class="line"><span class="tag"> 	<span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;idNo&quot;</span> <span class="attr">value</span>= <span class="string">&quot;80669865&quot;</span>/&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张铁钢&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>测试</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">PersonBean</span> <span class="variable">personBean</span> <span class="operator">=</span> (PersonBean)</span><br><span class="line">        context.getBean(<span class="string">&quot;personBean&quot;</span>);</span><br><span class="line">        personBean.work();</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>调用构造方法：我出生了！</span><br><span class="line"><span class="number">2.</span>设置属性：我的名字叫张铁钢</span><br><span class="line"><span class="number">3.</span>调用BeanNameAware#setBeanName方法:我要上学了，起了个学名</span><br><span class="line"><span class="number">4.</span>调用BeanFactoryAware#setBeanFactory方法：选好学校了</span><br><span class="line"><span class="number">5.</span>BeanPostProcessor#postProcessBeforeInitialization方法：到学校报名啦</span><br><span class="line"><span class="number">6.</span>InitializingBean#afterPropertiesSet方法：入学登记</span><br><span class="line"><span class="number">7.</span>自定义init方法：努力上学ing</span><br><span class="line"><span class="number">8.</span>BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证</span><br><span class="line">啦！</span><br><span class="line">Bean使用中：工作，只有对社会没有用的人才放假。。</span><br><span class="line"><span class="number">9.</span>DisposableBean#destroy方法：平淡的一生落幕了</span><br><span class="line"><span class="number">10.</span>自定义destroy方法:睡了，别想叫醒我</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="说说循环依赖"><a href="#说说循环依赖" class="headerlink" title="说说循环依赖"></a>说说循环依赖</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830123010500.png"
                      alt="image-20220830123010500" style="zoom:80%;" 
                >

<p>Spring 循环依赖：简单说就是自己依赖自己，或者和别的Bean相互依赖。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830123040716.png"
                      alt="image-20220830123040716" style="zoom:80%;" 
                >

<p>只有单例的Bean才存在循环依赖的情况， <strong>原型</strong> (Prototype)情况下，Spring会直接抛出异常。原因很简单，AB循环依赖，A实例化的时候，发现依赖B，创建B实例，创建B的时候发现需要A，创建A1实例……无限套娃，直接把系统干垮。</p>
<h2 id="Spring可以解决哪些情况的循环依赖？"><a href="#Spring可以解决哪些情况的循环依赖？" class="headerlink" title="Spring可以解决哪些情况的循环依赖？"></a>Spring可以解决哪些情况的循环依赖？</h2><p>Spring不支持基于构造器注入的循环依赖，但是假如AB循环依赖，如果一个是构造器注入，一个是setter注入呢？</p>
<p>看看几种情形：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830124807448.png"
                      alt="image-20220830124807448" style="zoom:80%;" 
                >

<p>第四种可以而第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。</p>
<p>所以简单总结，当循环依赖的实例都采用setter方法注入的时候，Spring可以支持，都采用构造器注入的时候，不支持，构造器注入和setter注入同时存在的时候，看天。</p>
<hr>
<h2 id="那Spring怎么解决循环依赖的呢？"><a href="#那Spring怎么解决循环依赖的呢？" class="headerlink" title="那Spring怎么解决循环依赖的呢？"></a>那Spring怎么解决循环依赖的呢？</h2><p>我们都知道，单例Bean初始化完成，要经历三步：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830145252769.png"
                      alt="image-20220830145252769"
                ></p>
<p>注入就发生在第二步， <strong>属性赋值</strong> ，结合这个过程，Spring 通过 <strong>三级缓存</strong> 解决了循环依赖：</p>
<p><strong>1.</strong> 一级缓存 : Map&lt;String,Object&gt; singletonObjects，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例<br><strong>2.</strong> 二级缓存 : Map&lt;String,Object&gt; earlySingletonObjects，早期曝光对象，用于保存实例化完成的 bean 实例<br><strong>3.</strong> 三级缓存 : Map&lt;String,ObjectFactory&lt;?&gt;&gt; singletonFactories，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830145321038.png"
                      alt="image-20220830145321038"
                ></p>
<p>我们来看一下三级缓存解决循环依赖的过程：</p>
<p>当 A、B 两个类发生循环依赖时：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830145354533.png"
                      alt="image-20220830145354533" style="zoom:80%;" 
                >

<p>A实例的初始化过程：</p>
<ol>
<li>创建A实例，实例化的时候把A对象工厂放入三级缓存，表示A开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830145430449.png"
                      alt="image-20220830145430449" style="zoom:80%;" 
                >

<ol start="2">
<li><p>A注入属性时，发现依赖B，此时B还没有被创建出来，所以去实例化B</p>
</li>
<li><p>同样，B注入属性时发现依赖A，它就会从缓存里找A对象。依次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，发现A虽然不太完善，但是存在，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。</p>
</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830145515442.png"
                      alt="image-20220830145515442" style="zoom:80%;" 
                >

<ol start="4">
<li><p>接着A继续属性赋值，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存</p>
</li>
<li><p>最后，一级缓存中保存着实例化、初始化都完成的A、B对象</p>
</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830145605736.png"
                      alt="image-20220830145605736" style="zoom:80%;" 
                >

<p>所以，我们就知道为什么Spring能解决setter注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。</p>
<hr>
<h2 id="为什么要三级缓存？二级不行吗？"><a href="#为什么要三级缓存？二级不行吗？" class="headerlink" title="为什么要三级缓存？二级不行吗？"></a>为什么要三级缓存？二级不行吗？</h2><p>不行，主要是为了生成代理对象 。如果是没有代理的情况下，使用二级缓存解决循环依赖也是OK的。但是如果存在代理，三级没有问题，二级就不行了。</p>
<p>因为三级缓存中放的是生成具体对象的匿名内部类，获取Object的时候，它可以生成代理对象，也可以返回普通对象。使用三级缓存主要是为了保证不管什么时候使用的都是一个对象。</p>
<p>假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，Bean初始化过程中，通过 BeanPostProcessor 去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么可能就导致取到的Bean对象不一致了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830145941780.png"
                      alt="image-20220830145941780"
                ></p>
<hr>
<h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a><strong>Spring 事务</strong></h1><p>Spring 事务的本质其实就是<strong>数据库</strong>对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p>
<h2 id="Spring-事务的种类？"><a href="#Spring-事务的种类？" class="headerlink" title="Spring 事务的种类？"></a>Spring 事务的种类？</h2><p>Spring 支持<strong>编程式事务管理</strong>和<strong>声明式事务</strong>管理两种方式：</p>
<p><strong>1.**编程式事务<br>编程式事务管理使用 **TransactionTemplate</strong>，需要显式执行事务。</p>
<p><strong>2.</strong> 声明式事务<br><strong>3.</strong> 声明式事务管理建立在 <strong>AOP</strong> 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况<strong>提交或者回滚事务</strong><br><strong>4.</strong> 优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 <strong>@Transactional</strong> 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务<br>那样可以作用到代码块级别。</p>
<hr>
<h2 id="Spring-的事务传播机制？"><a href="#Spring-的事务传播机制？" class="headerlink" title="Spring 的事务传播机制？"></a>Spring 的事务传播机制？</h2><p>Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。</p>
<p>事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830174152992.png"
                      alt="image-20220830174152992"
                ></p>
<p>Spring默认的事务传播行为是PROPAFATION_REQUIRED，它适合绝大多数情况，如果多个ServiceX#methodX()都工作在事务环境下（均被Spring事务增强），且程序中存在调用链Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的三个方法通过Spring的事务传播机制都工作在同一个事务中。</p>
<h3 id="七种事务传播行为详解与示例"><a href="#七种事务传播行为详解与示例" class="headerlink" title="七种事务传播行为详解与示例"></a>七种事务传播行为详解与示例</h3><p>在介绍七种事务传播行为前，我们先设计一个场景，帮助大家理解，场景描述如下</p>
<p>现有两个方法A和B，方法A执行会在数据库ATable插入一条数据，方法B执行会在数据库BTable插入一条数据，伪代码如下:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将传入参数a存入ATable</span></span><br><span class="line">pubilc <span class="keyword">void</span> <span class="title function_">A</span><span class="params">(a)</span>&#123;</span><br><span class="line">    insertIntoATable(a);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将传入参数b存入BTable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">(b)</span>&#123;</span><br><span class="line">    insertIntoBTable(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>接下来，我们看看在如下场景下，没有事务，情况会怎样</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这里要做一个重要提示：<strong>Spring中事务的默认实现使用的是AOP，也就是代理的方式，如果大家在使用代码测试时，同一个Service类中的方法相互调用需要使用注入的对象来调用，不要直接使用this.方法名来调用，this.方法名调用是对象内部方法调用，不会通过Spring代理，也就是事务不会起作用</strong></p>
<p>以上伪代码描述的一个场景，方法testMain和testB都没有事务，执行testMain方法，那么结果会怎么样呢？</p>
<p>相信大家都知道了，就是a1数据成功存入ATable表，b1数据成功存入BTable表，而在抛出异常后b2数据存储就不会执行，也就是b2数据不会存入数据库，这就是没有事务的场景。</p>
<p>可想而知，在上一篇文章（认识事务）中举例的转账操作，如果在某一步发生异常，且没有事务，那么钱是不是就凭空消失了，所以事务在数据库操作中的重要性可想而知。接下我们就开始理解七种不同事务传播类型的含义</p>
<h4 id="REQUIRED-Spring默认的事务传播类型"><a href="#REQUIRED-Spring默认的事务传播类型" class="headerlink" title="REQUIRED(Spring默认的事务传播类型)"></a><strong>REQUIRED(Spring默认的事务传播类型)</strong></h4><p><strong>如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</strong></p>
<p>*(示例1)*根据场景举栗子,我们在testMain和testB上声明事务，设置传播行为REQUIRED，伪代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该场景下执行testMain方法结果如何呢？</p>
<p>数据库没有插入新的数据，数据库还是保持着执行testMain方法之前的状态，没有发生改变。testMain上声明了事务，在执行testB方法时就加入了testMain的事务（<strong>当前存在事务，则加入这个事务</strong>），在执行testB方法抛出异常后事务会发生回滚，又testMain和testB使用的同一个事务，所以事务回滚后testMain和testB中的操作都会回滚，也就使得数据库仍然保持初始状态。</p>
<p>*(示例2)*根据场景再举一个栗子,我们只在testB上声明事务，设置传播行为REQUIRED，伪代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这时的执行结果又如何呢？</p>
<p>数据a1存储成功，数据b1和b2没有存储。由于testMain没有声明事务，testB有声明事务且传播行为是REQUIRED，所以在执行testB时会自己新建一个事务（<strong>如果当前没有事务，则自己新建一个事务</strong>），testB抛出异常则只有testB中的操作发生了回滚，也就是b1的存储会发生回滚，但a1数据不会回滚，所以最终a1数据存储成功，b1和b2数据没有存储。</p>
<h4 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a><strong>SUPPORTS</strong></h4><p><strong>当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</strong></p>
<p>*(示例3)*根据场景举栗子，我们只在testB上声明事务，设置传播行为SUPPORTS，伪代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这种情况下，执行testMain的最终结果就是，a1，b1存入数据库，b2没有存入数据库。由于testMain没有声明事务，且testB的事务传播行为是SUPPORTS，所以执行testB时就是没有事务的（<strong>如果当前没有事务，就以非事务方法执行</strong>），则在testB抛出异常时也不会发生回滚，所以最终结果就是a1和b1存储成功，b2没有存储。</p>
<p>那么当我们在testMain上声明事务且使用REQUIRED传播方式的时候，这个时候执行testB就满足<strong>当前存在事务，则加入当前事务</strong>，在testB抛出异常时事务就会回滚，最终结果就是a1，b1和b2都不会存储到数据库。</p>
<h4 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a><strong>MANDATORY</strong></h4><p><strong>当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</strong></p>
<p>*(示例4)*场景举栗子，我们只在testB上声明事务，设置传播行为MANDATORY，伪代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.MANDATORY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这种情形的执行结果就是a1存储成功，而b1和b2没有存储。b1和b2没有存储，并不是事务回滚的原因，而是因为testMain方法没有声明事务，在去执行testB方法时就直接抛出事务要求的异常（<strong>如果当前事务不存在，则抛出异常</strong>），所以testB方法里的内容就没有执行。</p>
<p>那么如果在testMain方法进行事务声明，并且设置为REQUIRED，则执行testB时就会使用testMain已经开启的事务，遇到异常就正常的回滚了。</p>
<h4 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a><strong>REQUIRES_NEW</strong></h4><p><strong>创建一个新事务，如果存在当前事务，则挂起该事务。</strong></p>
<p>可以理解为设置事务传播类型为REQUIRES_NEW的方法，在执行时，不论当前是否存在事务，总是会新建一个事务。</p>
<p>*(示例5)*场景举栗子，为了说明设置REQUIRES_NEW的方法会开启新事务，我们把异常发生的位置换到了testMain，然后给testMain声明事务，传播类型设置为REQUIRED，testB也声明事务，设置传播类型为REQUIRES_NEW，伪代码如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这种情形的执行结果就是a1没有存储，而b1和b2存储成功，因为testB的事务传播设置为REQUIRES_NEW,所以在执行testB时会开启一个新的事务，testMain中发生的异常时在testMain所开启的事务中，所以这个异常不会影响testB的事务提交，testMain中的事务会发生回滚，所以最终a1就没有存储，而b1和b2就存储成功了。</p>
<p>与这个场景对比的一个场景就是testMain和testB都设置为REQUIRED，那么上面的代码执行结果就是所有数据都不会存储，因为testMain和testMain是在同一个事务下的，所以事务发生回滚时，所有的数据都会回滚。</p>
<h4 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a><strong>NOT_SUPPORTED</strong></h4><p><strong>始终以非事务方式执行,如果当前存在事务，则挂起当前事务</strong></p>
<p>可以理解为设置事务传播类型为NOT_SUPPORTED的方法，在执行时，不论当前是否存在事务，都会以非事务的方式运行。</p>
<p>*(示例6)*场景举栗子，testMain传播类型设置为REQUIRED，testB传播类型设置为NOT_SUPPORTED，且异常抛出位置在testB中，伪代码如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该场景的执行结果就是a1和b2没有存储，而b1存储成功。testMain有事务，而testB不使用事务，所以执行中testB的存储b1成功，然后抛出异常，此时testMain检测到异常事务发生回滚，但是由于testB不在事务中，所以只有testMain的存储a1发生了回滚，最终只有b1存储成功，而a1和b1都没有存储。</p>
<h4 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a><strong>NEVER</strong></h4><p><strong>不使用事务，如果当前事务存在，则抛出异常</strong></p>
<p>很容易理解，就是我这个方法不使用事务，并且调用我的方法也不允许有事务，如果调用我的方法有事务则我直接抛出异常。</p>
<p>*示例7)*场景举栗子，testMain设置传播类型为REQUIRED，testB传播类型设置为NEVER，并且把testB中的抛出异常代码去掉，则伪代码如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NEVER)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该场景执行，直接抛出事务异常，且不会有数据存储到数据库。由于testMain事务传播类型为REQUIRED，所以testMain是运行在事务中，而testB事务传播类型为NEVER，所以testB不会执行而是<strong>直接抛出事务异常</strong>，此时testMain检测到异常就发生了回滚，所以最终数据库不会有数据存入。</p>
<h4 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a><strong>NESTED</strong></h4><p><strong>如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）</strong></p>
<p>这里需要注意两点：</p>
<ul>
<li>和REQUIRES_NEW的区别</li>
</ul>
<blockquote>
<p>REQUIRES_NEW是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时（我们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务）。<br>在NESTED情况下父事务回滚时，子事务也会回滚，而在REQUIRES_NEW情况下，原有事务回滚，不会影响新开启的事务。</p>
</blockquote>
<ul>
<li>和REQUIRED的区别</li>
</ul>
<blockquote>
<p>REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否catch其异常，事务都会回滚<br>而在NESTED情况下，被调用方发生异常时，调用方可以catch其异常，这样只有子事务回滚，父事务不受影响</p>
</blockquote>
<p>*(示例8)*场景举栗子，testMain设置为REQUIRED，testB设置为NESTED，且异常发生在testMain中，伪代码如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>该场景下，所有数据都不会存入数据库，因为在testMain发生异常时，父事务回滚则子事务也跟着回滚了，可以与*(示例5)*比较看一下，就找出了与REQUIRES_NEW的不同</p>
<p>*(示例9)*场景举栗子，testMain设置为REQUIRED，testB设置为NESTED，且异常发生在testB中，伪代码如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        testB();    <span class="comment">//调用testB</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>（Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    A(a2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这种场景下，结果是a1,a2存储成功，b1和b2存储失败，因为调用方catch了被调方的异常，所以只有子事务回滚了。</p>
<p>同样的代码，如果我们把testB的传播类型改为REQUIRED，结果也就变成了：没有数据存储成功。就算在调用方catch了异常，整个事务还是会回滚，因为，调用方和被调方共用的同一个事务。</p>
<hr>
<h2 id="Spring-的事务隔离级别"><a href="#Spring-的事务隔离级别" class="headerlink" title="Spring 的事务隔离级别"></a>Spring 的事务隔离级别</h2><p>Spring的接又TransactionDefinition中定义了表示隔离级别的常量，当然其实主要还是对应数据<br>库的事务隔离级别：</p>
<p><strong>1.</strong> <strong>ISOLATION_DEFAULT</strong>：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。<br><strong>2.</strong> <strong>ISOLATION_READ_UNCOMMITTED</strong>：读未提交<br><strong>3.</strong> <strong>ISOLATION_READ_COMMITTED</strong>：读已提交<br><strong>4.</strong> <strong>ISOLATION_REPEATABLE_READ</strong>：可重复读<br><strong>5.</strong> <strong>ISOLATION_SERIALIZABLE</strong>：串行化</p>
<hr>
<h2 id="Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor = Exception.class)注解了解吗？"></a>@Transactional(rollbackFor = Exception.class)注解了解吗？</h2><p>Exception 分为运行时异常 RuntimeException 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 @Transactional 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在 @Transactional 注解中如果不配置rollbackFor属性,那么事务只会在遇到RuntimeException的时候才会回滚，加上 <strong>rollbackFor=Exception.class</strong>,可以让事务在遇到<strong>非运行时异常</strong>时也回滚。</p>
<hr>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a><strong>Spring MVC</strong></h1><h2 id="说说自己对于-Spring-MVC-了解"><a href="#说说自己对于-Spring-MVC-了解" class="headerlink" title="说说自己对于 Spring MVC 了解?"></a>说说自己对于 Spring MVC 了解?</h2><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830150347255.png"
                      alt="image-20220830150347255"
                ></p>
<p><strong>Model 1 时代</strong></p>
<p>很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。</p>
<p>这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830152500012.png"
                      alt="image-20220830152500012" style="zoom:80%;" 
                >

<p><strong>Model 2 时代</strong></p>
<p>学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。</p>
<ul>
<li><p>Model:系统涉及的数据，也就是 dao 和 bean。</p>
</li>
<li><p>View：展示模型中的数据，只是用来展示。</p>
</li>
<li><p>Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</p>
</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830152547208.png"
                      alt="image-20220830152547208" style="zoom:80%;" 
                >

<p>Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。</p>
<p>于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。</p>
<p><strong>Spring MVC 时代</strong></p>
<p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<hr>
<h2 id="Spring-MVC-的核心组件？"><a href="#Spring-MVC-的核心组件？" class="headerlink" title="Spring MVC 的核心组件？"></a>Spring MVC 的核心组件？</h2><p><strong>1.</strong> <strong>DispatcherServlet</strong>：<strong>前置控制器</strong>，是整个流程控制的核心，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。<br><strong>2.</strong> <strong>Handler</strong>：<strong>处理器</strong>，完成具体的业务逻辑，相当于 Servlet 或 Action。<br><strong>3.</strong> <strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。<br><strong>4.</strong> <strong>HandlerInterceptor</strong>：<strong>处理器拦截器</strong>，是一个接口，如果需要完成一些拦截处理，可以实现该接口。<br><strong>5.</strong> <strong>HandlerExecutionChain</strong>：<strong>处理器执行链</strong>，包括两部分内容：Handler 和 HandlerInterceptor(系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。<br><strong>6.</strong> <strong>HandlerAdapter</strong>：<strong>处理器适配器</strong>，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet<br>通过 HandlerAdapter 执行不同的 Handler。<br><strong>7.</strong> <strong>ModelAndView</strong>：<strong>装载了模型数据和视图信息</strong>，作为 Handler 的处理结果，返回给DispatcherServlet。<br><strong>8.</strong> <strong>ViewResolver</strong>：<strong>视图解析器</strong>，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</p>
<hr>
<h2 id="Spring-MVC-的工作流程？"><a href="#Spring-MVC-的工作流程？" class="headerlink" title="Spring MVC 的工作流程？"></a>Spring MVC 的工作流程？</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830154256885.png"
                      alt="image-20220830154256885"
                ></p>
<p><strong>1.</strong> 客户端向服务端发送一次请求，这个请求会先到<strong>前端控制器DispatcherServlet</strong>(也叫中央控制器)。<br><strong>2.</strong> DispatcherServlet接收到请求后会调用<strong>HandlerMapping处理器映射器</strong>。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）<br><strong>3.</strong> DispatcherServlet调用<strong>HandlerAdapter处理器适配器</strong>，告诉处理器适配器应该要去执行哪个Controller<br><strong>4.</strong> HandlerAdapter处理器适配器去执行Controller并得到<strong>ModelAndView(数据和视图)**，并层层返回给DispatcherServlet<br>**5.</strong> DispatcherServlet将ModelAndView交给<strong>ViewReslover视图解析器</strong>解析，然后返回真正的视图<br><strong>6.</strong> DispatcherServlet将模型数据填充到视图中<br><strong>7.</strong> DispatcherServlet将结果响应给客户端</p>
<p><strong>Spring MVC</strong> 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要开发人员创建和管理，只需要通过配置文件的方式完成配置即可，真正需要开发人员进行处理的只有<strong>Handler（Controller）</strong> 、 <strong>View</strong> 、 <strong>Model</strong> 。</p>
<p>当然我们现在大部分的开发都是前后端分离，Restful风格接口，后端只需要返回Json数据就行了。</p>
<h2 id="SpringMVC-Restful风格的接又的流程是什么样的呢？"><a href="#SpringMVC-Restful风格的接又的流程是什么样的呢？" class="headerlink" title="SpringMVC Restful风格的接又的流程是什么样的呢？"></a>SpringMVC Restful风格的接又的流程是什么样的呢？</h2><p>我们都知道Restful接又，响应格式是json，这就用到了一个常用注解： <strong>@ResponseBody</strong></p>
<p>加入了这个注解后，整体的流程上和使用ModelAndView大体上相同，但是细节上有一些不同：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830162855421.png"
                      alt="image-20220830162855421" style="zoom:80%;" 
                >

<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>( <span class="number">1</span> ,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>1.</strong> 客户端向服务端发送一次请求，这个请求会先到前端控制器<strong>DispatcherServlet</strong><br><strong>2.</strong> DispatcherServlet接收到请求后会调用<strong>HandlerMapping</strong>处理器映射器。由此得知，该请求该由哪个<strong>Controller</strong>来处理<br><strong>3.</strong> DispatcherServlet调用<strong>HandlerAdapter处理器适配器</strong>，告诉处理器适配器应该要去执行哪个Controller<br><strong>4.</strong> Controller被封装成了<strong>ServletInvocableHandlerMethod</strong>，HandlerAdapter处理器适配器去执行<strong>invokeAndHandle</strong>方法，完成对Controller的请求处理<br><strong>5.</strong> HandlerAdapter执行完对Controller的请求，会调用<strong>HandlerMethodReturnValueHandler</strong>去处理返回值，主要的过程：<br>    <strong>5.1.</strong> 调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例<br>    <strong>5.2.**使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中<br>    **5.3.**在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化<br>**6.</strong> 执行完请求后，返回的ModealAndView为null，ServletServerHttpResponse里也已经写入了响应，所以不用关心View的处理</p>
<hr>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a><strong>Spring Boot</strong></h1><h2 id="介绍一下SpringBoot，有哪些优点？"><a href="#介绍一下SpringBoot，有哪些优点？" class="headerlink" title="介绍一下SpringBoot，有哪些优点？"></a>介绍一下SpringBoot，有哪些优点？</h2><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p>
<p>Spring Boot 以<strong>约定大于配置核心思想</strong>开展工作，相比Spring具有如下优势：</p>
<p><strong>1.</strong> Spring Boot 可以<strong>快速创建</strong>独立的Spring应用程序。<br><strong>2.</strong> Spring Boot <strong>内嵌了如Tomcat，Jetty和Undertow</strong>这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。<br><strong>3.</strong> Spring Boot 无需再像Spring一样使用一堆<strong>繁琐的xml文件配置</strong>。<br><strong>4.</strong> Spring Boot 可以<strong>自动配置(核心)Spring</strong>。SpringBoot将原有的XML配置改为Java配置，将bean注入改为使用注解注入的方式(@Autowire)，并将多个xml、properties配置浓缩在一个<strong>appliaction.yml</strong>配置文件中。<br><strong>5.</strong> Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。<br><strong>6.</strong> Spring Boot 可以<strong>快速整合常用依赖</strong>（开发库，例如spring-webmvc、jackson-json、validation-api和tomcat等），提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自引入其他依赖。</p>
<hr>
<h2 id="SpringBoot自动配置原理了解吗？"><a href="#SpringBoot自动配置原理了解吗？" class="headerlink" title="SpringBoot自动配置原理了解吗？"></a>SpringBoot自动配置原理了解吗？</h2><p>SpringBoot开启自动配置的注解是**@EnableAutoConfiguration** ，启动类上的注解**@SpringBootApplication<strong>是一个</strong>复合注解<strong>，包含了</strong>@EnableAutoConfiguration**：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830164916522.png"
                      alt="image-20220830164916522"
                ></p>
<p><strong>EnableAutoConfiguration</strong> 只是一个简单的注解，自动装配核心功能的实现实际是通过 <strong>AutoConfigurationImportSelector</strong>类</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">//将main同级的包下的所有组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="comment">//加载自动装配类</span></span><br><span class="line">xxxAutoconfiguration</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="operator">=</span><span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>AutoConfigurationImportSelector</strong>实现了<strong>ImportSelector</strong>接口，这个接口的作用就是<strong>收集需要导入的配置类</strong>，配合**@Import(）<strong>就可以将相应的类导入到</strong>Spring容器<strong>中获取注入类的方法是</strong>selectImports()<strong>，它实际调用的是</strong>getAutoConfigurationEntry**，这个方法是获取自动装配类的关键，主要流程可以分为这么几步：</p>
<p><strong>1.</strong> 获取注解的属性，用于后面的排除<br><strong>2.</strong> 获取所有需要自动装配的配置类的路径：这一步是最关键的，从<strong>META-INF/spring.factories</strong>获取自动配置类的路径<br><strong>3.</strong> 去掉重复的配置类和需要排除的重复类，把需要自动加载的配置类的路径存储起来</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rotected AutoConfigurationImportSelector.AutoConfigurationEntry</span><br><span class="line"><span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取到注解的属性</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span><span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">//2.获取需要自动装配的所有配置类，读取META-INF/spring.factories，获取自动配置类路径</span></span><br><span class="line">        List&lt;String&gt; configurations =<span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        <span class="comment">//3.1.移除重复的配置</span></span><br><span class="line">        configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">        <span class="comment">//3.2.处理需要排除的配置</span></span><br><span class="line">        Set&lt;String&gt; exclusions =<span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations =<span class="built_in">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">        <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations,exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations,exclusions);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="如何自定义一个SpringBoot-Srarter"><a href="#如何自定义一个SpringBoot-Srarter" class="headerlink" title="如何自定义一个SpringBoot Srarter?"></a>如何自定义一个SpringBoot Srarter?</h2><p><strong>1.</strong> <strong>创建一个项目，命名为demo-spring-boot-starter，引入SpringBoot相关依赖</strong></p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>2.</strong> <strong>编写配置文件</strong></p>
<p>这里定义了属性配置的前缀</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//省略getter、setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3.自动装配</strong></p>
<p>创建自动配置类HelloPropertiesConfigure</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(HelloProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloPropertiesConfigure</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>4.配置自动类</strong></p>
<p>在/resources/META-INF/spring.factories文件中添加自动配置类路径</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">cn.fighter3.demo.starter.configure.HelloPropertiesConfigure</span><br></pre></td></tr></table></figure></div>

<p><strong>5.测试</strong></p>
<ul>
<li>创建一个工程，引入自定义starter依赖</li>
</ul>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.fighter3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>在配置文件里添加配置</li>
</ul>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello.name=张三</span><br></pre></td></tr></table></figure></div>

<ul>
<li>测试类</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloTest</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">HelloProperties helloProperties;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你好，&quot;</span>+helloProperties.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830171452171.png"
                      alt="image-20220830171452171" style="zoom:50%;" 
                >

<hr>
<h2 id="Springboot-启动原理？"><a href="#Springboot-启动原理？" class="headerlink" title="Springboot 启动原理？"></a>Springboot 启动原理？</h2><p>SpringApplication 这个类主要做了以下四件事情：</p>
<p><strong>1.</strong> 推断应用的类型是普通的项目还是 Web 项目<br><strong>2.</strong> 查找并加载所有可用初始化器 ， 设置到 initializers 属性中<br><strong>3.</strong> 找出所有的应用程序监听器，设置到 listeners 属性中<br><strong>4.</strong> 推断并设置 main 方法的定义类，找到运行的主类</p>
<p>SpringBoot 启动大致流程如下 ：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img/%E9%9D%A2%E8%AF%95-Spring/image-20220830171724441.png"
                      alt="image-20220830171724441"
                ></p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：面试-Spring</li>
        <li>本文作者：威少996</li>
        <li>创建时间：2022-08-29 09:36:37</li>
        <li>
            本文链接：https://weishao-996.github.io/2022/08/29/面试-Spring/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a>&nbsp;
                        </li>
                    
                </ul>
            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2022/08/29/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85-MySQL/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">软件安装-MySQL</span>
                                    <span class="post-nav-item">上一篇</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2022/08/26/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-SpringBoot2/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">黑马程序员-SpringBoot2</span>
                                    <span class="post-nav-item">下一篇</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">面试-Spring</div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-%E5%9F%BA%E7%A1%80"><span class="nav-text">Spring 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-%E6%A1%86%E6%9E%B6"><span class="nav-text">什么是 Spring 框架?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">Spring的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84-Spring-%E6%A8%A1%E5%9D%97%EF%BC%9F"><span class="nav-text">列举一些重要的 Spring 模块？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%91%A2%EF%BC%9F"><span class="nav-text">Spring有哪些常用注解呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Spring-MVC-Spring-Boot-%E4%B9%8B%E9%97%B4%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="nav-text">Spring,Spring MVC,Spring Boot 之间什么关系?</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-IOC-amp-AOP"><span class="nav-text">Spring IOC &amp; AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-Spring-IoC-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-text">谈谈自己对于 Spring IoC 的了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%BD%E7%AE%80%E5%8D%95%E8%AF%B4%E2%BC%80%E4%B8%8BSpring-IOC%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E5%90%97%EF%BC%9F"><span class="nav-text">能简单说⼀下Spring IOC的实现机制吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-AOP-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-text">谈谈自己对于 AOP 的了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9F"><span class="nav-text">AOP有哪些核心概念？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8E%AF%E7%BB%95%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">AOP有哪些环绕方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%B9%B3%E6%97%B6%E6%9C%89%E7%94%A8%E5%88%B0AOP%E5%90%97%EF%BC%9F"><span class="nav-text">说说你平时有用到AOP吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C-CGLIB-%E4%BB%A3%E7%90%86-%EF%BC%9F"><span class="nav-text">说说JDK 动态代理和 CGLIB 代理 ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-AOP-%E5%92%8C-AspectJ-AOP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">Spring AOP 和 AspectJ AOP 有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Bean"><span class="nav-text">Spring Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Bean%EF%BC%9F"><span class="nav-text">什么是 Spring Bean？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BE%9D%E8%B5%96%E5%AE%9A%E4%B9%89%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-text">Bean定义和依赖定义有哪些方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">有哪些依赖注入的方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-text">构造方法注入</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%9F"><span class="nav-text">什么是自动装配？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA-Bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">将一个类声明为 Bean 的注解有哪些?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Component-%E5%92%8C-Bean-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">@Component 和 @Bean 的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Autowired-%E5%92%8C-Resource-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">@Autowired 和 @Resource 的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Autowired%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">@Autowired的实现原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">Bean 的作用域有哪些?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B-Bean-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-text">单例 Bean 的线程安全问题了解吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8BBean%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="nav-text">单例Bean线程安全问题怎么解决呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86%E8%A7%A3%E4%B9%88"><span class="nav-text">Bean 的生命周期了解么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="nav-text">说说循环依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="nav-text">Spring可以解决哪些情况的循环依赖？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%A3Spring%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-text">那Spring怎么解决循环依赖的呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F%E4%BA%8C%E7%BA%A7%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="nav-text">为什么要三级缓存？二级不行吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-%E4%BA%8B%E5%8A%A1"><span class="nav-text">Spring 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%9F"><span class="nav-text">Spring 事务的种类？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-text">Spring 的事务传播机制？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E7%A7%8D%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-text">七种事务传播行为详解与示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#REQUIRED-Spring%E9%BB%98%E8%AE%A4%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%B1%BB%E5%9E%8B"><span class="nav-text">REQUIRED(Spring默认的事务传播类型)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SUPPORTS"><span class="nav-text">SUPPORTS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MANDATORY"><span class="nav-text">MANDATORY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#REQUIRES-NEW"><span class="nav-text">REQUIRES_NEW</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NOT-SUPPORTED"><span class="nav-text">NOT_SUPPORTED</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NEVER"><span class="nav-text">NEVER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NESTED"><span class="nav-text">NESTED</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">Spring 的事务隔离级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transactional-rollbackFor-Exception-class-%E6%B3%A8%E8%A7%A3%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-text">@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-MVC"><span class="nav-text">Spring MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-Spring-MVC-%E4%BA%86%E8%A7%A3"><span class="nav-text">说说自己对于 Spring MVC 了解?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-MVC-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-text">Spring MVC 的核心组件？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-MVC-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-text">Spring MVC 的工作流程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC-Restful%E9%A3%8E%E6%A0%BC%E7%9A%84%E6%8E%A5%E5%8F%88%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-text">SpringMVC Restful风格的接又的流程是什么样的呢？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Boot"><span class="nav-text">Spring Boot</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BSpringBoot%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-text">介绍一下SpringBoot，有哪些优点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-text">SpringBoot自动配置原理了解吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AASpringBoot-Srarter"><span class="nav-text">如何自定义一个SpringBoot Srarter?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Springboot-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">Springboot 启动原理？</span></a></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">威少996</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br> 
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.0</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2022/8/17 11:45:14
            </div>
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
        
            <script async data-pjax defer>
                function odometer_init(){
                        let el = document.getElementsByClassName('odometer');
                        for (i = 0; i < el.length; i++) {
                            od = new Odometer({
                                el: el[i],
                                format: '( ddd).dd',
                                duration: 200
                            });
                        }
                }
                odometer_init();
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/menu-shrink.js"></script>

<script src="/js/tools/go-top-bottom.js"></script>

<script src="/js/tools/dark-light-toggle.js"></script>





    
<script src="/js/tools/code-block.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/tools/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
